[{"title":"MemCache源码探索（一）——内存管理篇","date":"2018-02-06T11:50:21.000Z","path":"2018/02/06/Memcache源码探索/","text":"结构介绍MemCache有几种结构概念：slab_class、slab、chunk slab_class：拥有同样chunk大小的slab被组织在一起，成为slab_class。 slab：MemCache将内存空间分为一组slab，slab下面是若干个chunk，默认大小为1M。 chunk：chunk是真正存储数据的地方，同一个slab里面chunk的大小是一样的。chunk的增长因子由-f指定，默认1.25，起始大小为48字节； MemCache中的value过来存放的地方是由value的大小决定的，value总是会被存放到与chunk大小最接近的一个slab中，比如slabclass[1]的chunk大小为80字节、slabclass[2]的chunk大小为100字节、slabclass[3]的chunk大小为128字节（相邻slab_class内的chunk基本以1.25为比例进行增长，MemCache启动时可以用-f指定这个比例），那么过来一个88字节的value，这个value将被放到2号slab中。放slab的时候，首先slab要申请内存，申请内存是以slab为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的内存被分配给该slab。申请到后，slab会将内存按chunk的大小进行切分，这样就变成了一个chunk数组，最后从这个chunk数组中选择一个用于存储数据。 slab_class循着 slabs_init() 方法看下去发现，slab_class的个数是有限制的，数值定义在 memcached.h 文件当中。 12/* slab class max is a 6-bit number, -1. */#define MAX_NUMBER_OF_SLAB_CLASSES (63 + 1) 数值是直接写死的，也就是说我们没有办法改变它。当然我们也没有必要去修改他，因为chunk最大值是有限制的，最大不可以超过slab的大小（不然如果chunk超过了slab的大小，slab还怎么放得下这个chunk呢？）。同时默认的设置中,item的最大值也是限制为了1MB 1settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */ 接下来我们看看slab_class的结构是怎么样的。这里是slab_class结构的定义： 123456789101112131415typedef struct &#123; unsigned int size; /* sizes of items */ /* item的大小 */ unsigned int perslab; /* how many items per slab */ /* 每一个slab的item数量 */ void *slots; /* list of item ptrs */ /* 空闲item(被回收的item)链表的指针 */ unsigned int sl_curr; /* total free items in list */ /* 空闲item的总数量 */ unsigned int slabs; /* how many slabs were allocated for this class */ /* 在这个slabclass中已分配slab的数量 */ void **slab_list; /* array of slab pointers */ /* slab数组 */ unsigned int list_size; /* size of prev array */ /* 前一个数组的大小 */ unsigned int killing; /* index+1 of dying slab, or zero if none */ size_t requested; /* The number of requested bytes */ /* 被访问到的字节数 */&#125; slabclass_t; main函数十分的长，有一千多到两千行的代码。其中有很大一部分是在解析命令行传入的参数，并且对全局的settings变量进行设置。 12345678910111213typedef struct _strchunk &#123; struct _strchunk *next; /* points within its own chain. */ struct _strchunk *prev; /* can potentially point to the head. */ struct _stritem *head; /* always points to the owner chunk */ int size; /* available chunk space in bytes */ int used; /* chunk space used */ int nbytes; /* used. */ unsigned short refcount; /* used? */ uint8_t orig_clsid; /* For obj hdr chunks slabs_clsid is fake. */ uint8_t it_flags; /* ITEM_* above. */ uint8_t slabs_clsid; /* Same as above. */ char data[];&#125; item_chunk; 1234567891011121314151617181920212223242526/** * Structure for storing items within memcached. */typedef struct _stritem &#123; struct _stritem *next; /* 双向链表 */ struct _stritem *prev; struct _stritem *h_next; /* hash chain next */ /* 指向hash值相同的下一个元素 */ rel_time_t time; /* least recent access */ /* 最近访问的时间 */ rel_time_t exptime; /* expire time */ /* 过期时间 */ int nbytes; /* size of data */ /* 数据大小 */ unsigned short refcount; /* 被引用数 */ uint8_t nsuffix; /* length of flags-and-length string */ /* 后缀长度 */ uint8_t it_flags; /* ITEM_* above */ uint8_t slabs_clsid;/* which slab class we're in */ /* 此item所属哪个slabclass */ uint8_t nkey; /* key length, w/terminating null and padding */ /* 键的长度 */ /* this odd type prevents type-punning issues when we do * the little shuffle to save space when not using CAS. */ union &#123; uint64_t cas; char end; &#125; data[];//真实数据信息 /* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */ /* then null-terminated key */ /* then \" flags length\\r\\n\" (no terminating null) */ /* then data with terminating \\r\\n (no terminating null; it's binary!) */&#125; item; 高效的内存管理策略123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 在slabclass[id]中，分配一个size大小的item。失败返回0，成功返回item的地址 * * 1. id校验 * 2. 若slabclass[id]中没有空闲的item，则请求分配一个新的slab，若请求失败，则返回0 * 3. 返回slots链表中的第一个元素，slabclass[id]的空闲item数减一 */static void *do_slabs_alloc(const size_t size, unsigned int id) &#123; slabclass_t *p; void *ret = NULL; item *it = NULL; // id校验 if (id &lt; POWER_SMALLEST || id &gt; power_largest) &#123; MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0); return NULL; &#125; p = &amp;slabclass[id]; /* 当前slabclass[id]的可用chunk数为0， 或者slots的第一个元素的slabclass Id为0 */ assert(p-&gt;sl_curr == 0 || ((item *)p-&gt;slots)-&gt;slabs_clsid == 0); /* fail unless we have space at the end of a recently allocated page, we have something on our freelist, or we could allocate a new page */ if (! (p-&gt;sl_curr != 0 || do_slabs_newslab(id) != 0)) &#123; /* We don't have more memory available */ ret = NULL; &#125; else if (p-&gt;sl_curr != 0) &#123; /* return off our freelist */ /* 取出头节点的chunk，作为空间返回 */ it = (item *)p-&gt;slots; p-&gt;slots = it-&gt;next; if (it-&gt;next) it-&gt;next-&gt;prev = 0; p-&gt;sl_curr--; ret = (void *)it; &#125; if (ret) &#123; p-&gt;requested += size; MEMCACHED_SLABS_ALLOCATE(size, id, p-&gt;size, ret); &#125; else &#123; MEMCACHED_SLABS_ALLOCATE_FAILED(size, id); &#125; return ret;&#125; slots 是回收的 item 链表, 从某个 slabclass 分配出去一个 item, 当 item 回收的时候,不是把这 item 使用的内存交还给 slab, 而是让这个 item 挂在 slots 链表的尾部。sl_curr 表示当前链表中有多少个回收而来的空闲 item.chunk中的内存使用完毕后不是让系统回收内存，而是放置于slot当中，如果有需求时可以直接取掉头结点作为空间使用。若内存不足，则申请一块新的slab。这个回收策略大大减小了内存释放回收过程中造成的性能损耗。do_slabs_alloc() 这个函数做的事情是，检查slots当中是否有空闲的内存可以使用，有则从中取出使用，没有才从slab中分配一个空间的chunk 理解了memcache的内存申请和回收原理后，同理的，我们可以看一看内存的回收过程， do_slabs_free() 函数。 1234567891011121314151617181920212223242526272829/** * 将ptr所指向的item链入slabclass[id]的slot链表中 * */ //创建空闲链表static void do_slabs_free(void *ptr, const size_t size, unsigned int id) &#123; slabclass_t *p; item *it; assert(((item *)ptr)-&gt;slabs_clsid == 0); assert(id &gt;= POWER_SMALLEST &amp;&amp; id &lt;= power_largest); if (id &lt; POWER_SMALLEST || id &gt; power_largest) //检查id有效性 return; MEMCACHED_SLABS_FREE(size, id, ptr); p = &amp;slabclass[id]; it = (item *)ptr; it-&gt;it_flags |= ITEM_SLABBED; // 设置item的标志 it-&gt;prev = 0; it-&gt;next = p-&gt;slots; //头插 if (it-&gt;next) it-&gt;next-&gt;prev = it; p-&gt;slots = it; p-&gt;sl_curr++; // chunk可用数增1 p-&gt;requested -= size; return;&#125; do_slabs_free() 函数做的事情是把需要回收的item插入到slots链表中，这样子这个item就已经被回收完毕了。下次需要新的内存时直接从slots中取出即可，对内存的操作实际上只是对指针的操作而已，这样的效率是非常高的。 未完待续。。。 写在最后代码版本： MemCache 1.4.15 这个是我阅读的源码版本，旧版的代码可读性比较强，同时也有童鞋对此版本代码做了比较详细的注释，在此给大家分享一下。 https://github.com/weiweikaikai/Mecached-Source-code-analysis 参考 https://www.csdn.net/article/2016-03-16/2826609 http://www.programering.com/a/MzM3MjMwATU.html http://blog.itpub.net/15480802/viewspace-1422370/ https://github.com/weiweikaikai/Mecached-Source-code-analysis","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/kong36088/kong36088.github.io/tags/计算机网络/"},{"name":"网络协议","slug":"网络协议","permalink":"https://github.com/kong36088/kong36088.github.io/tags/网络协议/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://github.com/kong36088/kong36088.github.io/tags/WebSocket/"}]},{"title":"WebSocket协议小记","date":"2017-12-26T13:52:21.000Z","path":"2017/12/26/WebSocket协议小记/","text":"杂谈在一两年前就已经使用过websocket协议，但是当时也仅仅是停留在使用上，对于很多原理以及协议的实现没有过多的理解。在很长一段时间里，我对websocket都还只是停留在“会用”的阶段。 最近总算有时间来捣鼓捣鼓一些底层原理性的东西，算是查缺补漏吧。 让我们进入我们的主题——websocket。 WebSocket 初探首先，WebSocket是一个持久连接协议，WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） WebSocket和HTTP之前会有一些小小的共同点，比如：1、他们都是基于TCP。因为WebSocket是基于TCP的，所以连接可靠性得到了保障。2、他们都有“Header”，像 Cookie=xxxx;Content-Type=xxxx; 这样的键值对 他们之间的关系就像是这样的： WebSocket 之深入握手阶段一起来看看WebSocket建立连接的过程。 这里是浏览器发起的请求：12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 可以看到，比起传统的HTTP协议，多了几个头：Upgrade Sec-WebSocket-Key Sec-WebSocket-Protocol Sec-WebSocket-Version这些头部是用于给WebSocket握手建立连接用的，指定的是websocket协议Sec-WebSocket-Key 是浏览器随机生成的base64 encode的值，用来询问服务器是否是支持WebSocket。 再看看服务端返回的Response：12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat Sec-WebSocket-Accept是将请求包Sec-WebSocket-Key的值，与”258EAFA5-E914-47DA-95CA-C5AB0DC85B11″这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码得到的。用来说明自己是WebSocket助理服务器。 Data Frame（数据帧）WebSocket数据帧结构如下图所示：1234567891011121314151617180 1 2 30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len | Extended payload length ||I|S|S|S| (4) |A| (7) | (16/64) ||N|V|V|V| |S| | (if payload len==126/127) || |1|2|3| |K| | |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +| Extended payload length continued, if payload len == 127 |+ - - - - - - - - - - - - - - - +-------------------------------+| |Masking-key, if MASK set to 1 |+-------------------------------+-------------------------------+| Masking-key (continued) | Payload Data |+-------------------------------- - - - - - - - - - - - - - - - +: Payload Data continued ... :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +| Payload Data continued ... |+---------------------------------------------------------------+ 这是官方文档上给出的示例。 FIN：这里第一位FIN表示这是消息的最后一帧（结束帧），一个消息由一个或多个数据帧构成。若消息由一帧构成，起始帧即结束帧。FIN位占1bit。 RSV1，RSV2，RSV3：各1位MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST Fail the WebSocket Connection.大致意思是如果未定义扩展，各位是0；如果定义了扩展，即为非0值。如果接收的帧此处非0，扩展中却没有该值的定义，那么关闭连接。 OPCODE：4位解释PayloadData，如果接收到未知的opcode，接收端必须关闭连接。0x0表示附加数据帧0x1表示文本数据帧0x2表示二进制数据帧0x3-7暂时无定义，为以后的非控制帧保留0x8表示连接关闭0x9表示ping0xA表示pong0xB-F暂时无定义，为以后的控制帧保留 MASK：1位用于标识PayloadData是否经过掩码处理。如果是1，Masking-key域的数据即是掩码密钥，用于解码PayloadData。客户端发出的数据帧需要进行掩码处理，所以此位是1。 Payload length：7位，7+16位，7+64位PayloadData的长度（以字节为单位）。如果其值在0-125，则是payload的真实长度。如果值是126，则后面2个字节形成的16位无符号整型数的值是payload的真实长度。注意，网络字节序，需要转换。如果值是127，则后面8个字节形成的64位无符号整型数的值是payload的真实长度。注意，网络字节序，需要转换。长度表示遵循一个原则，用最少的字节表示长度（我理解是尽量减少不必要的传输）。举例说，payload真实长度是124，在0-125之间，必须用前7位表示；不允许长度1是126或127，然后长度2是124，这样违反原则。Payload长度是ExtensionData长度与ApplicationData长度之和。ExtensionData长度可能是0，这种情况下，Payload长度即是ApplicationData长度。 WebSocket协议规定数据通过帧序列传输。客户端必须对其发送到服务器的所有帧进行掩码处理。服务器一旦收到无掩码帧，将关闭连接。服务器可能发送一个状态码是1002（表示协议错误）的Close帧。而服务器发送客户端的数据帧不做掩码处理，一旦客户端发现经过掩码处理的帧，将关闭连接。客户端可能使用状态码1002。 WebSocket 心跳心跳主要是用于检测对端是否在线，以减小资源压力。 WebSocket的心跳主要是通过 Ping、Pong 控制帧进行控制。Ping的协议头是0x9，Pong的协议头是0xA 在一端发出 Ping 帧后，若对端收到该帧，则必须回应 Pong 帧以表示在线 参考https://datatracker.ietf.org/doc/rfc6455/ https://www.zhihu.com/question/20215561/answer/40316953 https://baike.baidu.com/item/WebSocket/1953845?fr=aladdin http://blog.csdn.net/ttdevs/article/details/62887058","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/kong36088/kong36088.github.io/tags/计算机网络/"},{"name":"网络协议","slug":"网络协议","permalink":"https://github.com/kong36088/kong36088.github.io/tags/网络协议/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://github.com/kong36088/kong36088.github.io/tags/WebSocket/"}]},{"title":"小记调试PHP-X一个吐血的core dump过程","date":"2017-12-05T11:05:21.000Z","path":"2017/12/05/小记调试PHP-X一个吐血的core dump过程/","text":"在使用PHP-X开发PHP拓展的过程中，发现一个非常奇怪的bug 在频繁地调用zend_wrong_paramers_count_error这个Zend API方法后，会导致发生core dump。这个方法的作用是抛出一个入参参数数量不正确的Warning级别异常 先看看我们的源码： 123456789101112131415161718ZEND_RESULT_CODE _check_args_num(zend_execute_data *data, int num_args)&#123; uint32_t min_num_args = data-&gt;func-&gt;common.required_num_args; uint32_t max_num_args = data-&gt;func-&gt;common.num_args; if (num_args &lt; min_num_args || (num_args &gt; max_num_args &amp;&amp; max_num_args &gt; 0)) &#123; #if PHP_MAJOR_VERSION &gt;= 7 &amp;&amp; PHP_MINOR_VERSION == 0 zend_wrong_paramers_count_error(num_args, min_num_args, max_num_args); #else zend_wrong_parameters_count_error(num_args, min_num_args, max_num_args); //出错所在 #endif return FAILURE; &#125; return SUCCESS;&#125; 使用gdb对core进行分析123456789101112131415161718192021222324252627282930$ gdb php -c /corefile/core.11[New LWP 2852]Core was generated by `php ../tests/main.php'.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x000000000085c681 in incomplete_class_message (object=0x7effd7a6b140, error_type=32511) at /usr/local/php-7.2.0/ext/standard/incomplete_class.c:4747 php_error_docref(NULL, error_type, INCOMPLETE_CLASS_MSG, \"unknown\")$ (gdb) bt#0 0x000000000085c681 in zend_mm_alloc_small (bin_num=8, size=79, heap=0x7f1cf8800040) at /usr/local/php-7.0.26/Zend/zend_alloc.c:1318#1 zend_mm_alloc_heap (size=79, heap=0x7f1cf8800040) at /usr/local/php-7.0.26/Zend/zend_alloc.c:1389#2 zend_mm_realloc_heap (heap=0x7f1cf8800040, ptr=0x0, size=79, copy_size=79) at /usr/local/php-7.0.26/Zend/zend_alloc.c:1485#3 0x000000000086409e in _erealloc (ptr=0x0, size=79) at /usr/local/php-7.0.26/Zend/zend_alloc.c:2506#4 0x00000000007f999c in xbuf_format_converter (xbuf=0x7ffeddbfe950, is_char=1 '\\001', fmt=0xe356e5 \"PHP %s: %s in %s on line %d\", ap=0x7ffeddbfe9a8) at /usr/local/php-7.0.26/main/spprintf.c:246#5 0x00000000007fc799 in vspprintf (pbuf=0x7ffeddbfeb40, max_len=0, format=0xe356e5 \"PHP %s: %s in %s on line %d\", ap=0x7ffeddbfe9a8) at /usr/local/php-7.0.26/main/spprintf.c:847#6 0x00000000007fc8af in spprintf (pbuf=0x7ffeddbfeb40, max_len=0, format=0xe356e5 \"PHP %s: %s in %s on line %d\") at /usr/local/php-7.0.26/main/spprintf.c:871#7 0x00000000007f2fd3 in php_error_cb (type=2, error_filename=0x7f1cf886a068 \"/share/docker/c/www/PHP-X-demo/args/tests/main.php\", error_lineno=10, format=0xe4b424 \"%s\", args=0x7ffeddbfed40) at /usr/local/php-7.0.26/main/main.c:1122#8 0x00000000008a398d in zend_error (type=2, format=0xe4b424 \"%s\") at /usr/local/php-7.0.26/Zend/zend.c:1172#9 0x00000000008a468b in zend_internal_type_error (throw_exception=0 '\\000', format=0xe4b520 \"%s%s%s() expects %s %d parameter%s, %d given\") at /usr/local/php-7.0.26/Zend/zend.c:1366#10 0x00000000008a5476 in zend_wrong_paramers_count_error (num_args=2, min_num_args=1, max_num_args=1) at /usr/local/php-7.0.26/Zend/zend_API.c:205#11 0x00007f1cf83ba69f in php::_check_args_num (data=0x7f1cf8813170, num_args=2) at /share/docker/c/www/PHP-X/src/base.cc:216#12 0x00007f1cf83ba54e in php::_exec_method (data=0x7f1cf8813170, return_value=0x7f1cf8813110) at /share/docker/c/www/PHP-X/src/base.cc:194#13 0x0000000000938799 in ZEND_DO_FCALL_SPEC_HANDLER () at /usr/local/php-7.0.26/Zend/zend_vm_execute.h:842#14 0x0000000000934566 in execute_ex (ex=0x7f1cf8813030) at /usr/local/php-7.0.26/Zend/zend_vm_execute.h:414#15 0x0000000000934efa in zend_execute (op_array=0x7f1cf887f000, return_value=0x0) at /usr/local/php-7.0.26/Zend/zend_vm_execute.h:458#16 0x00000000008a4a6d in zend_execute_scripts (type=8, retval=0x0, file_count=3) at /usr/local/php-7.0.26/Zend/zend.c:1445#17 0x00000000007f619f in php_execute_script (primary_file=0x7ffeddc01ac0) at /usr/local/php-7.0.26/main/main.c:2518#18 0x0000000000a103f7 in do_cli (argc=2, argv=0x2144a20) at /usr/local/php-7.0.26/sapi/cli/php_cli.c:977#19 0x0000000000a117bd in main (argc=2, argv=0x2144a20) at /usr/local/php-7.0.26/sapi/cli/php_cli.c:1347 看到这个backtrace后一头雾水，貌似是跟php的内存管理扯上边了？但其实不然 经过长时间的debug发现，原来是我的拓展某行代码写错了，导致发生了这种问题。 直接上我们的代码：1234567891011121314151617181920212223242526void printArgs(Args args)&#123; cout &lt;&lt; \"Args: \"; for (unsigned int i = 0; i &lt;args.count(); i++) &#123; if (args[i].type() == IS_ARRAY) &#123; Array arr(args[i]); cout &lt;&lt; '['; for (auto it = arr.begin(); it != arr.end(); it++) &#123; cout &lt;&lt; it.value().toString(); &#125; cout &lt;&lt; ']' &lt;&lt; ' '; &#125; else &#123; cout &lt;&lt; args[i].toString() &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; endl;&#125;PHPX_METHOD(ArgsTest,noneArgs)&#123; printArgs(args); cout &lt;&lt; \"noneArgs() called\" &lt;&lt; endl;&#125; 我们来看看PHPX_METHOD这个宏的定义1#define PHPX_METHOD(c, m) void c##_##m(Object &amp;_this, Args &amp;args, Variant &amp;retval) 注意上面的代码中printArgs(args);这一行代码传入了args参数，而从PHPX_METHOD定义我们可以看到，args是一个引用参数，但是在printArgs()函数定义时，没有把args作为引用参数而导致了错误。初步猜测是因为传参过程中，一些对象复制的问题导致了错误 正确写法应该是把void printArgs(Args args)改为void printArgs(Args &amp;args) 问题最终顺利解决~","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"},{"name":"PHP-X","slug":"PHP-X","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP-X/"}]},{"title":"nginx初探","date":"2017-10-18T09:45:21.000Z","path":"2017/10/18/nginx初探/","text":"worker模型 nginx架构每个请求会占用一个线程，一个worker进程可以处理成千上万的请求。 nginx采用多worker的方式来处理请求，每个worker里面只有一个主线程，那能够处理的并发数很有限啊，多少个worker就能处理多少个并发，何来高并发呢？非也，这就是nginx的高明之处，nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。 异步非阻塞的事件处理机制，具体到系统调用就是像select/poll/epoll/kqueue这样的系统调用。它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制正好解决了我们上面的两个问题，拿epoll为例，当事件没准备好时，放到epoll里面，事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里面。 nginx事件处理模型：1234567891011121314151617181920212223while (true) &#123; for t in run_tasks: t.handler(); update_time(&amp;now); timeout = ETERNITY; for t in wait_tasks: /* sorted already */ if (t.time &lt;= now) &#123; t.timeout_handler(); &#125; else &#123; timeout = t.time - now; break; &#125; nevents = poll_function(events, timeout); for i in nevents: task t; if (events[i].type == READ) &#123; t.handler = read_handler; &#125; else &#123; /* events[i].type == WRITE */ t.handler = write_handler; &#125; run_tasks_add(t);&#125; connection在这里，很多人会误解worker_connections这个参数的意思，认为这个值就是nginx所能建立连接的最大值。其实不然，这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。 每个worker分配到的请求数需要通过一定的机制进行调控，请求越多的worker被分配到请求的可能性越小。可以参考以下伪代码12345678910111213141516171819202122ngx_accept_disabled = ngx_cycle-&gt;connection_n / 8 - ngx_cycle-&gt;free_connection_n;if (ngx_accept_disabled &gt; 0) &#123; ngx_accept_disabled--;&#125; else &#123; if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123; return; &#125; if (ngx_accept_mutex_held) &#123; flags |= NGX_POST_EVENTS; &#125; else &#123; if (timer == NGX_TIMER_INFINITE || timer &gt; ngx_accept_mutex_delay) &#123; timer = ngx_accept_mutex_delay; &#125; &#125;&#125; 首先，nginx的处理得先打开accept_mutex选项，此时，只有获得了accept_mutex的进程才会去添加accept事件，也就是说，nginx会控制进程是否添加accept事件。nginx使用一个叫ngx_accept_disabled的变量来控制是否去竞争accept_mutex锁。在第一段代码中，计算ngx_accept_disabled的值，这个值是nginx单进程的所有连接总数的八分之一，减去剩下的空闲连接数量，得到的这个ngx_accept_disabled有一个规律，当剩余连接数小于总连接数的八分之一时，其值才大于0，而且剩余的连接数越小，这个值越大。再看第二段代码，当ngx_accept_disabled大于0时，不会去尝试获取accept_mutex锁，并且将ngx_accept_disabled减1，于是，每次执行到此处时，都会去减1，直到小于0。不去获取accept_mutex锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时，ngx_accept_disable越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。不去accept，自己的连接就控制下来了，其它进程的连接池就会得到利用，这样，nginx就控制了多进程间连接的平衡了。 requestnginx对于解析http协议也是通过一行一行地读取进行处理。 nginx会将整个请求头都放在一个buffer里面，这个buffer的大小通过配置项client_header_buffer_size来设置，如果用户的请求头太大，这个buffer装不下，那nginx就会重新分配一个新的更大的buffer来装请求头，这个大buffer可以通过large_client_header_buffers来设置，这个large_buffer这一组buffer，比如配置4 8k，就是表示有四个8k大小的buffer可以用。注意，为了保存请求行或请求头的完整性，一个完整的请求行或请求头，需要放在一个连续的内存里面，所以，一个完整的请求行或请求头，只会保存在一个buffer里面。这样，如果请求行大于一个buffer的大小，就会返回414错误，如果一个请求头大小大于一个buffer大小，就会返回400错误。在了解了这些参数的值，以及nginx实际的做法之后，在应用场景，我们就需要根据实际的需求来调整这些参数，来优化我们的程序了。 处理流程图： keepalive这里是http层的keepalive，与tcp层的不同。 nginx的keepalive可以对连接进行复用，一般来说，当客户端的一次访问，需要多次访问同一个server时，打开keepalive的优势非常大，比如图片服务器，通常一个网页会包含很多个图片。打开keepalive也会大量减少time-wait的数量。 pipe在http1.1中，引入了一种新的特性，即pipeline。它可以看作为keepalive的一种升华，因为pipeline也是基于长连接的，目的就是利用一个连接做多次请求。 lingering_closelingering_close，字面意思就是延迟关闭，也就是说，当nginx要关闭连接时，并非立即关闭连接，而是先关闭tcp连接的写，再等待一段时间后再关掉连接的读。 nginx在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而nginx在响应错误信息后，大分部情况下是需要关闭当前连接。nginx执行完write()系统调用把错误信息发送给客户端，write()系统调用返回成功并不表示数据已经发送到客户端，有可能还在tcp连接的write buffer里。接着如果直接执行close()系统调用关闭tcp连接，内核会首先检查tcp的read buffer里有没有客户端发送过来的数据留在内核态没有被用户态进程读取，如果有则发送给客户端RST报文来关闭tcp连接丢弃write buffer里的数据，如果没有则等待write buffer里的数据发送完毕，然后再经过正常的4次分手报文断开连接。所以,当在某些场景下出现tcp write buffer里的数据在write()系统调用之后到close()系统调用执行之前没有发送完毕，且tcp read buffer里面还有数据没有读，close()系统调用会导致客户端收到RST报文且不会拿到服务端发送过来的错误信息数据。那客户端肯定会想，这服务器好霸道，动不动就reset我的连接，连个错误信息都没有。 数据结构字符串ngx_str_t字符串型数据结构：1234typedef struct &#123; size_t len; u_char *data;&#125; ngx_str_t; 通过len指定字符串长度，这样做的好处是可以令一个字符串指针指向同一段字符串内存，从而节省内存。 相关的API：1234567#define ngx_string(str) &#123; sizeof(str) - 1, (u_char *) str &#125;#define ngx_null_string &#123; 0, NULL &#125;#define ngx_str_set(str, text) \\ (str)-&gt;len = sizeof(text) - 1; (str)-&gt;data = (u_char *) text#define ngx_str_null(str) (str)-&gt;len = 0; (str)-&gt;data = NULL... poolnginx_pool_t是一个非常重要的数据结构，在很多重要的场合都有使用，很多重要的数据结构也都在使用它。那么它究竟是一个什么东西呢？简单的说，它提供了一种机制，帮助管理一系列的资源（如内存，文件等），使得对这些资源的使用和释放统一进行，免除了使用过程中考虑到对各种各样资源的什么时候释放，是否遗漏了释放的担心。1234567891011typedef struct ngx_pool_s ngx_pool_t;struct ngx_pool_s &#123; ngx_pool_data_t d; size_t max; ngx_pool_t *current; ngx_chain_t *chain; ngx_pool_large_t *large; ngx_pool_cleanup_t *cleanup; ngx_log_t *log;&#125;; 数组ngx_array_t是nginx内部使用的数组结构。nginx的数组结构在存储上与大家认知的C语言内置的数组有相似性，比如实际上存储数据的区域也是一大块连续的内存。但是数组除了存储数据的内存以外还包含一些元信息来描述相关的一些信息。下面我们从数组的定义上来详细的了解一下。ngx_array_t的定义位于src/core/ngx_array.c|h里面。12345678typedef struct ngx_array_s ngx_array_t;struct ngx_array_s &#123; void *elts; ngx_uint_t nelts; size_t size; ngx_uint_t nalloc; ngx_pool_t *pool;&#125;; elts: 指向实际的数据存储区域。nelts: 数组实际元素个数。size: 数组单个元素的大小，单位是字节。nalloc: 数组的容量。表示该数组在不引发扩容的前提下，可以最多存储的元素的个数。当nelts增长到达nalloc 时，如果再往此数组中存储元素，则会引发数组的扩容。数组的容量将会扩展到原有容量的2倍大小。实际上是分配新的一块内存，新的一块内存的大小是原有内存大小的2倍。原有的数据会被拷贝到新的一块内存中。pool: 该数组用来分配内存的内存池。 hashngx_hash_t不像其他的hash表的实现，可以插入删除元素，它只能一次初始化，就构建起整个hash表以后，既不能再删除，也不能在插入元素了。ngx_hash_t的开链并不是真的开了一个链表，实际上是开了一段连续的存储空间，几乎可以看做是一个数组。这是因为ngx_hash_t在初始化的时候，会经历一次预计算的过程，提前把每个桶里面会有多少元素放进去给计算出来，这样就提前知道每个桶的大小了。那么就不需要使用链表，一段连续的存储空间就足够了。这也从一定程度上节省了内存的使用。 ngx_hash_t的初始化。1ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit, ngx_hash_key_t *names, ngx_uint_t nelts); 123456789101112typedef struct &#123; ngx_hash_t *hash; ngx_hash_key_pt key; ngx_uint_t max_size; ngx_uint_t bucket_size; char *name; ngx_pool_t *pool; ngx_pool_t *temp_pool;&#125; ngx_hash_init_t; hash: 该字段如果为NULL，那么调用完初始化函数后，该字段指向新创建出来的hash表。如果该字段不为NULL，那么在初始的时候，所有的数据被插入了这个字段所指的hash表中。key: 指向从字符串生成hash值的hash函数。nginx的源代码中提供了默认的实现函数ngx_hash_key_lc。max_size: hash表中的桶的个数。该字段越大，元素存储时冲突的可能性越小，每个桶中存储的元素会更少，则查询起来的速度更快。当然，这个值越大，越造成内存的浪费也越大，(实际上也浪费不了多少)。bucket_size: 每个桶的最大限制大小，单位是字节。如果在初始化一个hash表的时候，发现某个桶里面无法存的下所有属于该桶的元素，则hash表初始化失败。name: 该hash表的名字。pool: 该hash表分配内存使用的pool。temp_pool: 该hash表使用的临时pool，在初始化完成以后，该pool可以被释放和销毁掉。 12345typedef struct &#123; ngx_str_t key; ngx_uint_t key_hash; void *value;&#125; ngx_hash_key_t; 总的来说，nginx封装的数据结构十分之丰富，包括动态list、queue这样的结构。 参考http://tengine.taobao.org/book/chapter_02.html","tags":[{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Nginx/"},{"name":"C","slug":"C","permalink":"https://github.com/kong36088/kong36088.github.io/tags/C/"}]},{"title":"nginx配置location以及rewrite","date":"2017-09-27T09:45:21.000Z","path":"2017/09/27/nginx配置location以及rewrite/","text":"1. location正则写法一个示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ configuration G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ]&#125;location ~* /js/.*/\\.js 以=开头表示精确匹配如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。^~ 开头表示uri以某个常规字符串开头，不是正则匹配~ 开头表示区分大小写的正则匹配;~* 开头表示不区分大小写的正则匹配/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到顺序 no优先级：(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 上面的匹配结果按照上面的location写法，以下的匹配示例成立： / -&gt; config A精确完全匹配，即使/index.html也匹配不了/downloads/download.html -&gt; config B匹配B以后，往下没有任何匹配，采用B/images/1.gif -&gt; configuration D匹配到F，往下匹配到D，停止往下/images/abc/def -&gt; config D最长匹配到G，往下匹配D，停止往下你可以看到 任何以/images/开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序/documents/document.html -&gt; config C匹配到C，往下没有任何匹配，采用C/documents/1.jpg -&gt; configuration E匹配到C，往下正则匹配到E/documents/Abc.jpg -&gt; config CC最长匹配到C，往下正则顺序匹配到CC，不会往下到E 实际使用建议123456789101112131415161718192021所以实际使用中，个人觉得至少有三个匹配规则定义，如下：#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。#这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;#第三个规则就是通用规则，用来转发动态请求到后端应用服务器#非静态文件请求就默认是动态请求，自己根据实际把握#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125; http://tengine.taobao.org/book/chapter_02.htmlhttp://nginx.org/en/docs/http/ngx_http_rewrite_module.html 2. Rewrite规则rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在server{},location{},if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 http://seanlook.com/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。语法rewrite regex replacement [flag]; 如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。 表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是： 执行server块的rewrite指令执行location匹配执行选定的location中的rewrite指令如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。 2.1 flag标志位last : 相当于Apache的[L]标记，表示完成rewritebreak : 停止执行当前虚拟主机的后续rewrite指令集redirect : 返回302临时重定向，地址栏会显示跳转后的地址permanent : 返回301永久重定向，地址栏会显示跳转后的地址因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解：``last一般写在server和if中，而break一般使用在location中last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配break和last都能组织继续执行后面的rewrite指令2.2 if指令与全局变量if判断指令语法为if(condition){…}，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false直接比较变量和内容时，使用=或!=~正则表达式匹配，~*不区分大小写的匹配，!~区分大小写的不匹配-f和!-f用来判断是否存在文件-d和!-d用来判断是否存在目录-e和!-e用来判断是否存在文件或目录-x和!-x用来判断文件是否可执行 例如：12345678910111213141516171819202122232425if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break;&#125; //如果UA包含\"MSIE\"，rewrite请求到/msid/目录下if ($http_cookie ~* \"id=([^;]+)(?:;|$)\") &#123; set $id $1; &#125; //如果cookie匹配正则，设置变量$id等于正则引用部分if ($request_method = POST) &#123; return 405;&#125; //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302if ($slow) &#123; limit_rate 10k;&#125; //限速，$slow可以通过 set 指令设置if (!-f $request_filename)&#123; break; proxy_pass http://127.0.0.1;&#125; //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查if ($args ~ post=140)&#123; rewrite ^ http://example.com/ permanent;&#125; //如果query string中包含\"post=140\"，永久重定向到example.comlocation ~* \\.(gif|jpg|png|swf|flv)$ &#123; valid_referers none blocked www.jefflei.com www.leizhenfang.com; if ($invalid_referer) &#123; return 404; &#125; //防盗链&#125; 全局变量下面是可以用作if判断的全局变量 $args ： #这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段。$content_type ： 请求头中的Content-Type字段。$document_root ： 当前请求在root指令中指定的值。$host ： 请求主机头字段，否则为服务器名称。$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率。$request_method ： 客户端请求的动作，通常为GET或POST。$remote_addr ： 客户端的IP地址。$remote_port ： 客户端的端口。$remote_user ： 已经经过Auth Basic Module验证的用户名。$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme ： HTTP方法（如http，https）。$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。$server_name ： 服务器名称。$server_port ： 请求到达服务器的端口号。$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri ： 与$uri相同。例：http://localhost:88/test1/test2/test.php$host：localhost$server_port：88$request_uri：http://localhost:88/test1/test2/test.php$document_uri：/test1/test2/test.php$document_root：/var/www/html$request_filename：/var/www/html/test1/test2/test.php 2.3 常用正则. ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的介绍{n} ： 重复n次{n,} ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 2.4 rewrite实例例1： 12345678910111213141516171819202122232425262728http &#123; # 定义image日志格式 log_format imagelog '[$time_local] ' $image_file ' ' $image_type ' ' $body_bytes_sent ' ' $status; # 开启重写日志 rewrite_log on; server &#123; root /home/www; location / &#123; # 重写规则信息 error_log logs/rewrite.log notice; # 注意这里要用‘’单引号引起来，避免&#123;&#125; rewrite '^/images/([a-z]&#123;2&#125;)/([a-z0-9]&#123;5&#125;)/(.*)\\.(png|jpg|gif)$' /data?file=$3.$4; # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行 set $image_file $3; set $image_type $4; &#125; location /data &#123; # 指定针对图片的日志格式，来分析图片类型和大小 access_log logs/images.log mian; root /data/images; # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里 try_files /$arg_file /image404.html; &#125; location = /image404.html &#123; # 图片不存在返回特定的信息 return 404 \"image not found\\n\"; &#125;&#125; 对形如/images/ef/uh7b3/test.png的请求，重写到/data?file=test.png，于是匹配到location /data，先看/data/images/test.png文件存不存在，如果存在则正常响应，如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。 例2：1rewrite ^/images/(.*)_(\\d+)x(\\d+)\\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;height=$3? last; 对形如/images/bla_500x400.jpg的文件请求，重写到/resizer/bla.jpg?width=500&amp;height=400地址，并会继续尝试匹配location。 转载出处http://seanlook.com/2015/05/17/nginx-location-rewrite/","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"https://github.com/kong36088/kong36088.github.io/tags/配置/"}]},{"title":"PHP standard函数getcwd源码阅读小记","date":"2017-06-28T03:20:21.000Z","path":"2017/06/28/PHP standard函数getcwd源码阅读小记/","text":"遇到了php-fpm register_shutdown_function()的一个bug： 12345echo \"Expected:\" . getcwd() . \"&lt;br&gt;\";register_shutdown_function(function () &#123; echo \"In shutdown function:\" . getcwd() . \"&lt;br&gt;\";&#125;); php-fpm输出如下12Expected:/var/www/html/testIn shutdown function:/ 在cli模式下输出正常1Expected:/var/www/html/test&lt;br&gt;In shutdown function:/var/www/html/test&lt;br&gt; 去翻翻源码，找到getcwd的定义函数定义的位置在：ext/standard/dir.c的364行123456789101112131415161718192021PHP_FUNCTION(getcwd)&#123; char path[MAXPATHLEN]; char *ret=NULL; if (zend_parse_parameters_none() == FAILURE) &#123; return; &#125;#if HAVE_GETCWD ret = VCWD_GETCWD(path, MAXPATHLEN); //这里调用ZEND的方法，获取当前工作目录#elif HAVE_GETWD ret = VCWD_GETWD(path);#endif if (ret) &#123; RETURN_STRING(path); &#125; else &#123; RETURN_FALSE; &#125;&#125; 可见，此方法其实是关联到一个ZEND方法VCWD_GETWD()1#define VCWD_GETCWD(buff, size) virtual_getcwd(buff, size) PHP内核定义了十分之多的宏，所以需要找到真正定义还得费点劲最终找到真正定义位置，在Zend\\zend_virtual_cwd.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667CWD_API char *virtual_getcwd_ex(size_t *length)&#123; cwd_state *state; state = &amp;CWDG(cwd); //获取全局的virtual_getcwd if (state-&gt;cwd_length == 0) &#123; char *retval; *length = 1; retval = (char *) emalloc(2); if (retval == NULL) &#123; return NULL; &#125; retval[0] = DEFAULT_SLASH; retval[1] = '\\0'; return retval; &#125;#ifdef ZEND_WIN32 /* If we have something like C: */ if (state-&gt;cwd_length == 2 &amp;&amp; state-&gt;cwd[state-&gt;cwd_length-1] == ':') &#123; char *retval; *length = state-&gt;cwd_length+1; retval = (char *) emalloc(*length+1); if (retval == NULL) &#123; return NULL; &#125; memcpy(retval, state-&gt;cwd, *length); retval[0] = toupper(retval[0]); retval[*length-1] = DEFAULT_SLASH; retval[*length] = '\\0'; return retval; &#125;#endif if (!state-&gt;cwd) &#123; *length = 0; return NULL; &#125; *length = state-&gt;cwd_length; return estrdup(state-&gt;cwd);&#125;CWD_API char *virtual_getcwd(char *buf, size_t size)&#123; size_t length; char *cwd; cwd = virtual_getcwd_ex(&amp;length); // 真正获取cwd的地方 if (buf == NULL) &#123; return cwd; &#125; if (length &gt; size-1) &#123; efree(cwd); errno = ERANGE; /* Is this OK? */ return NULL; &#125; if (!cwd) &#123; return NULL; &#125; memcpy(buf, cwd, length+1); //复制内容 efree(cwd); // 防止内存泄漏 return buf;&#125; 找到CWDG定义1234567#ifdef ZTSextern ts_rsrc_id cwd_globals_id;# define CWDG(v) ZEND_TSRMG(cwd_globals_id, virtual_cwd_globals *, v)#elseextern virtual_cwd_globals cwd_globals;# define CWDG(v) (cwd_globals.v)#endif 可以看到，方法是获取一个全局变量，cwd_globals 根据上面源码的阅读，可以进一步推测应该是shutdown_function的时候cwd_globals已经被修改了这种情况只发生在php-fpm模式下，cli未发现","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"},{"name":"内核","slug":"内核","permalink":"https://github.com/kong36088/kong36088.github.io/tags/内核/"}]},{"title":"PSR规范总结：","date":"2017-04-19T06:24:25.000Z","path":"2017/04/19/PSR规范总结/","text":"能愿动词 必须 (MUST) ：绝对，严格遵循，请照做，无条件遵守； 一定不可 (MUST NOT) ：禁令，严令禁止； 应该 (SHOULD) ：强烈建议这样做，但是不强求； 不该 (SHOULD NOT) ：强烈不建议这样做，但是不强求； 可以 (MAY) 和 可选 (OPTIONAL) ：选择性高一点，在这个文档内，此词语使用较少； PSR-1（基础编码规范） PHP代码文件 必须 以 &lt;?php 或 &lt;?= 标签开始； PHP代码文件 必须 以 不带 BOM 的 UTF-8 编码； PHP代码中 应该 只定义类、函数、常量等声明，或其他会产生 副作用 的操作（如：生成文件输出以及修改 .ini 配置文件等），二者只能选其一； 命名空间以及类 必须 符合 PSR 的自动加载规范：PSR-4 中的一个； 类的命名 必须 遵循 StudlyCaps 大写开头的驼峰命名规范； 类中的常量所有字母都 必须 大写，单词间用下划线分隔； 方法名称 必须 符合 camelCase 式的小写开头驼峰命名规范。（这个类似于Java的命名方式） PSR-2（编码风格规范） 代码 必须 遵循 PSR-1 中的编码规范 。 代码 必须 使用4个空格符而不是「Tab 键」进行缩进。 每行的字符数 应该 软性保持在 80 个之内，理论上 一定不可 多于 120 个，但 一定不可 有硬性限制。 每个 namespace 命名空间声明语句和 use 声明语句块后面，必须 插入一个空白行。 类的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。 方法的开始花括号（{） 必须 写在函数声明后自成一行，结束花括号（}）也 必须 写在函数主体后自成一行。 类的属性和方法 必须 添加访问修饰符（private、protected 以及 public），abstract 以及 final 必须 声明在访问修饰符之前，而 static 必须 声明在访问修饰符之后。 控制结构的关键字后 必须 要有一个空格符，而调用方法或函数时则 一定不可 有。 控制结构的开始花括号（{） 必须 写在声明的同一行，而结束花括号（}） 必须 写在主体后自成一行。 控制结构的开始左括号后和结束右括号前，都 一定不可 有空格符。 PSR-3（日志接口规范） LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency，以及还有第九个方法 log（用于写入或者记录日志）。 参数 可以 携带占位符，并且占位符 必须 与上下文的数组中键名保持一致。 必须 🈶️一个左花括号{和右花括号}组成。占位符的名称 应该 只由 A-Z、a-z、0-9、下划线 _、以及英文的句号 . 组成，其它字符作为将来占位符规范的保留。 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。它 可以 装载任何信息，所以实现者 必须 确保能正确处理其装载的信息，对于其装载的数据， 一定不可 抛出异常，或产生PHP出错、警告或提醒信息（error、warning、notice） Psr\\Log\\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，而另外八个方法就能够把记录信息和上下文信息传给它。 同样地，使用 Psr\\Log\\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，在 traits 可复用代码块还不能实现接口前，还需要 implement LoggerInterface。 在没有可用的日志记录器时，Psr\\Log\\NullLogger 接口 可以 为使用者提供一个备用的日志「黑洞」。不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。 Psr\\Log\\LoggerAwareInterface 接口仅包括一个 setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。 Psr\\Log\\LoggerAwareTrait trait可复用代码块可以在任何的类里面使用，只需通过它提供的 `$this-&gt;logger，就可以轻松地实现等同的接口。 Psr\\Log\\LogLevel 类装载了八个记录等级常量。 LoggerInterface.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?phpnamespace Psr\\Log;/** * Describes a logger instance. * * The message MUST be a string or object implementing __toString(). * * The message MAY contain placeholders in the form: &#123;foo&#125; where foo * will be replaced by the context data in key \"foo\". * * The context array can contain arbitrary data. The only assumption that * can be made by implementors is that if an Exception instance is given * to produce a stack trace, it MUST be in a key named \"exception\". * * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md * for the full interface specification. */interface LoggerInterface&#123; /** * System is unusable. * * @param string $message * @param array $context * * @return void */ public function emergency($message, array $context = array()); /** * Action must be taken immediately. * * Example: Entire website down, database unavailable, etc. This should * trigger the SMS alerts and wake you up. * * @param string $message * @param array $context * * @return void */ public function alert($message, array $context = array()); /** * Critical conditions. * * Example: Application component unavailable, unexpected exception. * * @param string $message * @param array $context * * @return void */ public function critical($message, array $context = array()); /** * Runtime errors that do not require immediate action but should typically * be logged and monitored. * * @param string $message * @param array $context * * @return void */ public function error($message, array $context = array()); /** * Exceptional occurrences that are not errors. * * Example: Use of deprecated APIs, poor use of an API, undesirable things * that are not necessarily wrong. * * @param string $message * @param array $context * * @return void */ public function warning($message, array $context = array()); /** * Normal but significant events. * * @param string $message * @param array $context * * @return void */ public function notice($message, array $context = array()); /** * Interesting events. * * Example: User logs in, SQL logs. * * @param string $message * @param array $context * * @return void */ public function info($message, array $context = array()); /** * Detailed debug information. * * @param string $message * @param array $context * * @return void */ public function debug($message, array $context = array()); /** * Logs with an arbitrary level. * * @param mixed $level * @param string $message * @param array $context * * @return void */ public function log($level, $message, array $context = array());&#125; 再看看AbstractLogger.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phpnamespace Psr\\Log;/** * This is a simple Logger implementation that other Loggers can inherit from. * * It simply delegates all log-level-specific methods to the `log` method to * reduce boilerplate code that a simple Logger that does the same thing with * messages regardless of the error level has to implement. */abstract class AbstractLogger implements LoggerInterface&#123; /** * System is unusable. * * @param string $message * @param array $context * * @return void */ public function emergency($message, array $context = array()) &#123; $this-&gt;log(LogLevel::EMERGENCY, $message, $context); &#125; /** * Action must be taken immediately. * * Example: Entire website down, database unavailable, etc. This should * trigger the SMS alerts and wake you up. * * @param string $message * @param array $context * * @return void */ public function alert($message, array $context = array()) &#123; $this-&gt;log(LogLevel::ALERT, $message, $context); &#125; /** * Critical conditions. * * Example: Application component unavailable, unexpected exception. * * @param string $message * @param array $context * * @return void */ public function critical($message, array $context = array()) &#123; $this-&gt;log(LogLevel::CRITICAL, $message, $context); &#125; /** * Runtime errors that do not require immediate action but should typically * be logged and monitored. * * @param string $message * @param array $context * * @return void */ public function error($message, array $context = array()) &#123; $this-&gt;log(LogLevel::ERROR, $message, $context); &#125; /** * Exceptional occurrences that are not errors. * * Example: Use of deprecated APIs, poor use of an API, undesirable things * that are not necessarily wrong. * * @param string $message * @param array $context * * @return void */ public function warning($message, array $context = array()) &#123; $this-&gt;log(LogLevel::WARNING, $message, $context); &#125; /** * Normal but significant events. * * @param string $message * @param array $context * * @return void */ public function notice($message, array $context = array()) &#123; $this-&gt;log(LogLevel::NOTICE, $message, $context); &#125; /** * Interesting events. * * Example: User logs in, SQL logs. * * @param string $message * @param array $context * * @return void */ public function info($message, array $context = array()) &#123; $this-&gt;log(LogLevel::INFO, $message, $context); &#125; /** * Detailed debug information. * * @param string $message * @param array $context * * @return void */ public function debug($message, array $context = array()) &#123; $this-&gt;log(LogLevel::DEBUG, $message, $context); &#125;&#125; 可以看到，如果我们继承了AbstractLogger，只需要实现我们自己的log方法就可以了 PSR-4（自动加载规范）一个完整的类名需具有以下结构:1\\&lt;命名空间&gt;(\\&lt;子命名空间&gt;)*\\&lt;类名&gt; 完整的类名 必须 要有一个顶级命名空间，被称为 “vendor namespace”； 完整的类名 可以 有一个或多个子命名空间； 完整的类名 必须 有一个最终的类名； 完整的类名中任意一部分中的下滑线都是没有特殊含义的； 完整的类名 **可以 由任意大小写字母组成； 所有类名都 必须 是大小写敏感的。 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应； 紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符。 末尾的类名 必须 与对应的以 .php 为后缀的文件同名。 自动加载器（autoloader）的实现 一定不可 抛出异常、一定不可 触发任一级别的错误信息以及 不应该 有返回值。 Examples 完整类名 命名空间前缀 文件基目录 文件路径 \\Acme\\Log\\Writer\\File_Writer Acme\\Log\\Writer\\ ./acme-log-writer/lib/ ./acme-log-writer/lib/File_Writer.php \\Aura\\Web\\Response\\Status Aura\\Web /path/to/aura-web/src/ /path/to/aura-web/src/Response/Status.php \\Symfony\\Core\\Request Symfony\\Core ./vendor/Symfony/Core/ ./vendor/Symfony/Core/Request.php \\Zend\\Acl Zend /usr/includes/Zend/ /usr/includes/Zend/Acl.php PSR-6（缓存接口规范）定义 调用类库 (Calling Library) - 调用者，使用缓存服务的类库，这个类库调用缓存服务，调用的 是此缓存接口规范的具体「实现类库」，调用者不需要知道任何「缓存服务」的具体实现。 实现类库 (Implementing Library) - 此类库是对「缓存接口规范」的具体实现，封装起来的缓存服务，供「调用类库」使用。实现类库 必须 提供 PHP 类来实现 Cache\\CacheItemPoolInterface 和 Cache\\CacheItemInterface 接口。 实现类库 必须 支持最小的如下描述的 TTL 功能，秒级别的精准度。 生存时间值 (TTL - Time To Live) - 定义了缓存可以存活的时间，以秒为单位的整数值。 过期时间 (Expiration) - 定义准确的过期时间点，一般为缓存存储发生的时间点加上 TTL 时 间值，也可以指定一个 DateTime 对象。 假如一个缓存项的 TTL 设置为 300 秒，保存于 1:30:00 ，那么缓存项的过期时间为 1:35:00。 实现类库 可以 让缓存项提前过期，但是 必须 在到达过期时间时立即把缓存项标示为 过期。如果调用类库在保存一个缓存项的时候未设置「过期时间」、或者设置了 null 作为过期 时间（或者 TTL 设置为 null），实现类库 可以 使用默认自行配置的一个时间。如果没 有默认时间，实现类库 必须把存储时间当做 永久性 存储，或者按照底层驱动能支持的 最长时间作为保持时间。 键 (KEY) - 长度大于 1 的字串，用作缓存项在缓存系统里的唯一标识符。实现类库 必须 支持「键」规则 A-Z, a-z, 0-9, _, 和 . 任何顺序的 UTF-8 编码，长度 小于 64 位。实现类库 可以 支持更多的编码或者更长的长度，不过 必须 支持至少以上指定 的编码和长度。实现类库可自行实现对「键」的转义，但是 必须 保证能够无损的返回「键」字串。以下 的字串作为系统保留: {}()/\\@:，一定不可 作为「键」的命名支持。 命中 (Hit) - 一个缓存的命中，指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存 池里能找到对应的缓存项，并且此缓存项还未过期，并且此数据不会因为任何原因出现错误。调用类 库 应该 确保先验证下 isHit() 有命中后才调用 get() 获取数据。 未命中 (Miss) - 一个缓存未命中，是完全的上面描述的「命中」的相反。指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存池里未能找到对应的缓存项，或者此缓存项已经过期，或者此数据因为任何原因出现错误。一个过期的缓存项，必须 被当做 未命中 来对待。 延迟 (Deferred) - 一个延迟的缓存，指的是这个缓存项可能不会立刻被存储到物理缓存池里。一个 缓存池对象 可以 对一个指定延迟的缓存项进行延迟存储，这样做的好处是可以利用一些缓存服务器提供 的批量插入功能。缓存池 必须 能对所有延迟缓存最终能持久化，并且不会丢失。可以 在调用类库还未发起保存请求之前就做持久化。当调用类库调用 commit() 方法时，所有的延迟缓存都 必须 做持久化。实现类库 可以 自行决定使用什么逻辑来触发数据持久化，如对象的 析构方法 (destructor) 内、调用 save() 时持久化、倒计时保存或者触及最大数量时保存等。当请求一个延迟 缓存项时，必须 返回一个延迟，未持久化的缓存项对象。 数据 实现类库 必须 支持所有的可序列化的 PHP 数据类型 所有存进实现类库的数据，都 必须 能做到原封不动的取出。连类型也 必须 是完全一致，如果 存进缓存的是字符串 5，取出来的却是整数值 5 的话，可以算作严重的错误。实现类库 可以 使用 PHP 的「serialize()/unserialize() 方法」作为底层实现，不过不强迫这样做。对于他们的兼容性，以能支持所有数据类型作为基准线。 实在无法「完整取出」存入的数据的话，实现类库 必须 把「缓存丢失」标示作为返回，而不是损坏了的数据。 错误处理 缓存对应用性能起着至关重要的作用，但是，无论在任何情况下，缓存 一定不可 作为应用程序不 可或缺的核心功能。 缓存系统里的错误 一定不可 导致应用程序故障，所以，实现类库 一定不可 抛出任何除了 此接口规范定义的以外的异常，并且 必须 捕捉包括底层存储驱动抛出的异常，不让其冒泡至超 出缓存系统内。 实现类库 应该 对此类错误进行记录，或者以任何形式通知管理员。 调用类库发起删除缓存项的请求，或者清空整个缓冲池子的请求，「键」不存在的话 必须 不能 当成是有错误发生。后置条件是一样的，如果取数据时，「键」不存在的话 必须 不能当成是有错误发生 参考资料PHP标准规范","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"PSR","slug":"PSR","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PSR/"}]},{"title":"二十种设计模式简要概括以及其UML图示例","date":"2017-02-20T06:24:25.000Z","path":"2017/02/20/二十种设计模式简要概括以及其UML图示例/","text":"工厂模式Factory（创建型）工厂（Factory）负责组装生产产品，客户只需要告知工厂需要生产的产品即可获得产品。 建造者模式（创建型）建造者模式是在工厂模式之上建立更加复杂的对象，在各个工厂生产出产品后再将每个产品进行组合 单例模式Singleton（创建型）单例模式比较简单，保证对象是单例即可，在类中添加一个类似于get_instance()的方法获取对象 原型模式Prototype（创建型）原型模式是通过clone的方式采用原型，减少加工所产生的资源消耗对原型进行clone操作，并在clone之后进一步对其进行加工生产 适配器模式Adapter（结构型）为了不更改adaptee但又想适配各种不同的类而采用的设计模式一个有趣的现实生活中的例子就是：到不同的国家去旅游需要购买不一样的充电适配器才可以对你的设备进行充电 桥连模式Bridge（结构型）不同的一类对象中根据不同的另一类对象实现桥连123$objRAbstraction = new SmallBrushPenRefinedAbstraction(); $objRAbstraction-&gt;setImplementorColor(new oncreteImplementorRed()); $objRAbstraction-&gt;operationDraw(); 组合模式Composite（结构型）组合模式就是将需要进行操作的各个类放到一个操作类中，操作类作为父节点，被操作的作为子节点形成树结构，最后通过循环等方式对子节点进行遍历执行操作 装饰器Decorator模式（结构型）客户操作装饰器，装饰器实例化组件并且对组件进行装饰，产生装饰器模式 外观模式Facade（结构型）由于系统的增长系统变得十分之复杂，多出许多小的类出来，客户需要组合进行使用。而这时可以创建一个facade具体对子类的组合操作在facade中进行，客户只需要认准facade即可 享元模式Flyweight（结构型）由于需要大量重复创建对象，为了节约资源我们使用享元池（即对象池）存放享元，提高对象利用率利用一个享元工厂来创建存放享元，客户端直接通过享元工厂获取享元对象并并且工厂将享元放入工厂的享元池中 代理模式Proxy（结构型）客户直接操作的是代理并非操作实现类，代理类与实现类继承同一个接口，但是代理类通过代理的方式调用实现类的方法 命令模式Command（对象行为型）一个系列操作对应一个命令类，并且设置一个接受者，通过命令类去操作接受者。各个命令类放在遥控器类当中进行存储和操作 迭代器模式Iterator（对象行为型）迭代器模式十分之容易理解，就是专门用于迭代数组或对象的在C++中有专门的Iterator，这里的迭代器模式也是类似的，可以通过循环便利出所有的元素 中介者模式Mediator（对象行为型）用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者保存各个对象之间需要相互联系的关系，而对象只需要调用中介者即可调用其他子对象，从而减少子类的生成。 观察者模式Observer（对象行为型）在一个具体实现类中存放观察者，在具体实现类进行类似于“update”的操作的时候遍历通知所有的观察者，对观察者进行notify操作 状态模式State（对象行为型）把不同状态的操作分散到不同的状态对象里去完成进行每一种操作时找到当前状态类并发起操作，在操作完成后需要转换当前的状态，并且下一次操作的是转换后的状态类在大量需要使用case if等条件判断语句时，状态模式可以大量减少case if等语句的使用 策略模式Strategy（对象行为型）有点类似于状态模式，每一个策略对应一个类，并通过Context类进行调用。但不同的是使用者需要知道所有的策略，并根据需要使用相应的策略 模版方法模式Template method（类行为型）一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。控制子类扩展。模板方法只在特定点调用“ hook”操作 ，这样就只允许在这些点进行扩展。重用父类作为模板，遵从父类实现逻辑，通过重写方法实现细节控制 访问者模式Visitor（对象行为型）一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。 Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。 参考Gof《设计模式》（作者：guisu）","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/kong36088/kong36088.github.io/tags/设计模式/"}]},{"title":"Ubuntu14.04 Docker升级以及设置加速器（业界良心）","date":"2017-02-15T06:33:25.000Z","path":"2017/02/15/Ubuntu Docker升级以及设置加速器（业界良心）/","text":"由于Ubuntu14.04源自带的Docker版本很旧，并且由于国内环境特殊原因在DockerHub上Pull镜像十分之慢，故作此文 下面看看实现的方法，先说升级： 升级apt-get的安装方式比较方便的方法就是通过包管理的方式安装了 首先添加docker仓库秘钥到本地：1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9 再将docker仓库添加到本地的软件源中：1sudo sh -c \"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\" 最后执行更新一下软件源1sudo apt-get update 最后安装docker即可：1sudo apt-get install lxc-docker 设置加速器由于国内网络原因，连接docker hub速度特别慢，特别是在不稳定的网络环境下在使用加速器后下载镜像时长由原来的几个小时到现在的几十分钟，大大的提升了下载速度！这里我们使用的是国内良心厂家DaoCloud免费提供的加速器 注册首先要到DaoCloud先注册一个帐号，这个是官网传送门 设置加速器12curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://xxxxxx.m.daocloud.ioservice docker restart 这里个人的加速器连接需要到官网去获取，这个是官网传送门设置完毕，搞定~! 使用这里让我们来测试一下加速的效果吧1docker pull mysql 淋漓尽致！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/docker/"}]},{"title":"PHP builtin function strlen()和count()时间复杂度阅读分析","date":"2017-01-23T06:00:25.000Z","path":"2017/01/23/PHP builtin function strlen()和count()时间复杂度阅读分析/","text":"翻了下PHP内核的定义，大概心中也有了答案了 count()和strlen()都是O(1)的时间复杂度 试想一下如果strlen()需要O(N)的复杂度那未免也太慢了，字符串长度起来的话服务器不是要直接挂掉吗 这两个函数都是典型的空间换时间的做法 我们可以先看看zvalue的结构： 1234567891011typedef union _zvalue_value &#123; long lval; /* long value */ double dval; /* double value */ struct &#123; char *val; int len; &#125; str; HashTable *ht; /* hash table value */ zend_object_value obj; zend_ast *ast;&#125; zvalue_value; 这里用的是一个联合体，当变量类型是string类型的时候附加存储多了一个len的整型变量，显而易见需要取长度直接利用记录值就可以了，自然就是O(1) 对于count()常用的参数类型应该为数组，对于继承Countable的类暂不作讨论 数组实现方式为Hashtable，直接看看他的结构吧 1234567891011121314151617typedef struct _hashtable &#123; uint nTableSize; // hash Bucket的大小，最小为8，以2x增长。 uint nTableMask; // nTableSize-1 ， 索引取值的优化 uint nNumOfElements; // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 ulong nNextFreeElement; // 下一个数字索引的位置 Bucket *pInternalPointer; // 当前遍历的指针（foreach比for快的原因之一） Bucket *pListHead; // 存储数组头元素指针 Bucket *pListTail; // 存储数组尾元素指针 Bucket **arBuckets; // 存储hash数组 dtor_func_t pDestructor; // 在删除元素时执行的回调函数，用于资源的释放 zend_bool persistent; //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。 unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归） zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; count直接获取nNumOfElements大小，所以也是O(1) 后记补充———————————————— count() 函数的定义在这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* &#123;&#123;&#123; proto int count(mixed var [, int mode]) Count the number of elements in a variable (usually an array) */PHP_FUNCTION(count)&#123; zval *array; zend_long mode = COUNT_NORMAL; zend_long cnt; zval *element; ZEND_PARSE_PARAMETERS_START(1, 2) Z_PARAM_ZVAL(array) Z_PARAM_OPTIONAL Z_PARAM_LONG(mode) ZEND_PARSE_PARAMETERS_END(); switch (Z_TYPE_P(array)) &#123; case IS_NULL: php_error_docref(NULL, E_WARNING, \"Parameter must be an array or an object that implements Countable\"); RETURN_LONG(0); break; case IS_ARRAY: if (mode != COUNT_RECURSIVE) &#123; //类型为数组时调用zend内核函数 zend_array_count() cnt = zend_array_count(Z_ARRVAL_P(array)); &#125; else &#123; cnt = php_count_recursive(Z_ARRVAL_P(array)); &#125; RETURN_LONG(cnt); break; case IS_OBJECT: &#123; zval retval; /* first, we check if the handler is defined */ if (Z_OBJ_HT_P(array)-&gt;count_elements) &#123; RETVAL_LONG(1); if (SUCCESS == Z_OBJ_HT(*array)-&gt;count_elements(array, &amp;Z_LVAL_P(return_value))) &#123; return; &#125; &#125; /* if not and the object implements Countable we call its count() method */ if (instanceof_function(Z_OBJCE_P(array), zend_ce_countable)) &#123; zend_call_method_with_0_params(array, NULL, NULL, \"count\", &amp;retval); if (Z_TYPE(retval) != IS_UNDEF) &#123; RETVAL_LONG(zval_get_long(&amp;retval)); zval_ptr_dtor(&amp;retval); &#125; return; &#125; /* If There's no handler and it doesn't implement Countable then add a warning */ php_error_docref(NULL, E_WARNING, \"Parameter must be an array or an object that implements Countable\"); RETURN_LONG(1); break; &#125; default: php_error_docref(NULL, E_WARNING, \"Parameter must be an array or an object that implements Countable\"); RETURN_LONG(1); break; &#125;&#125; 如果没有特别指定mode参数为 COUNT_RECURSIVE 的话（即作遍历），跳转到 zend 的数组计数函数 zend_array_count() 123456789101112131415161718192021222324252627282930313233343536#define zend_hash_num_elements(ht) \\ (ht)-&gt;nNumOfElements......static uint32_t zend_array_recalc_elements(HashTable *ht)&#123; zval *val; uint32_t num = ht-&gt;nNumOfElements; ZEND_HASH_FOREACH_VAL(ht, val) &#123; if (Z_TYPE_P(val) == IS_INDIRECT) &#123; if (UNEXPECTED(Z_TYPE_P(Z_INDIRECT_P(val)) == IS_UNDEF)) &#123; num--; &#125; &#125; &#125; ZEND_HASH_FOREACH_END(); return num;&#125;ZEND_API uint32_t zend_array_count(HashTable *ht)&#123; uint32_t num; if (UNEXPECTED(ht-&gt;u.v.flags &amp; HASH_FLAG_HAS_EMPTY_IND)) &#123; num = zend_array_recalc_elements(ht); if (UNEXPECTED(ht-&gt;nNumOfElements == num)) &#123; ht-&gt;u.v.flags &amp;= ~HASH_FLAG_HAS_EMPTY_IND; &#125; &#125; else if (UNEXPECTED(ht == &amp;EG(symbol_table))) &#123; num = zend_array_recalc_elements(ht); &#125; else &#123; num = zend_hash_num_elements(ht); &#125; return num;&#125; IS_REFERENCE：间接 zval 指的就是其真正的值是存储在其他地方的。注意这个 IS_REFERENCE 类型是不同的，间接 zval 是直接指向另外一个 zval 而不是像 zend_reference 结构体一样嵌入 zval。 只有当数组中有 HASH_FLAG_HAS_EMPTY_IND 这个 flag 时（间接zval）才会对数组进行遍历校验，其他情况下都是直接取 数组（hash table） 里面的 nNumOfElements 的值，答案显而易见了， count() 的时间复杂度就是O(1)","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"},{"name":"内核","slug":"内核","permalink":"https://github.com/kong36088/kong36088.github.io/tags/内核/"}]},{"title":"PHP内核源码阅读笔记","date":"2017-01-12T11:15:25.000Z","path":"2017/01/12/PHP内核源码阅读笔记/","text":"这个工作一直拖延了很久，终于有时间拿出来写写。本文主要是根据“TIPI深入理解PHP内核”一书进行阅读和分析 一、概述可以利用辅助的工具进行php代码阅读例如vim或者sublimetext，重量级的可以用eclipse或者phpstorm这样的工具本人用的是phpstorm进行代码阅读，CTRL+鼠标点击可以找到变量的定义位置，十分之方便 PG1234567#ifdef ZTS# define PG(v) TSRMG(core_globals_id, php_core_globals *, v)extern PHPAPI int core_globals_id;#else# define PG(v) (core_globals.v)extern ZEND_API struct _php_core_globals core_globals;#endif PG用于定义或获取全局变量ZTS是线程安全的标记 在main/php_globalsh中定义了宏PG和结构体_php_core_globals，用于存放一些常用到的全局参数举例如下：123456789101112131415struct _php_core_globals &#123; ······省略 char *user_ini_filename; // 用户的ini文件名 long user_ini_cache_ttl; // ini缓存过期限制 char *request_order; // 优先级比variables_order高，在request变量生成时用到，个人觉得是历史遗留问题 zend_bool mail_x_header; // 仅在ext/standard/mail.c文件中使用， char *mail_log; zend_bool in_error_log; ········省略&#125;; SG我们来看一下SG的定义1234567#ifdef ZTS# define SG(v) TSRMG(sapi_globals_id, sapi_globals_struct *, v)SAPI_API extern int sapi_globals_id;#else# define SG(v) (sapi_globals.v)extern SAPI_API sapi_globals_struct sapi_globals;#endif 如同PG一样，ZTS是线程安全的标志SG主要是用来获取SAPI的所需要用到的全局变量的 CGCG定义在Zend/zend_globals_macros.h文件中 我们一起来看看CG的定义相关代码：123456789/* Compiler */#ifdef ZTS# define CG(v) TSRMG(compiler_globals_id, zend_compiler_globals *, v)int zendparse(void *compiler_globals);#else# define CG(v) (compiler_globals.v)extern ZEND_API struct _zend_compiler_globals compiler_globals;int zendparse(void);#endif 可见CG是用于存取compiler需要用到的一些全局变量的 EG123456#ifdef ZTS# define EG(v) TSRMG(executor_globals_id, zend_executor_globals *, v)#else# define EG(v) (executor_globals.v)extern ZEND_API zend_executor_globals executor_globals;#endif EG用于存取执行器需要用到的全局变量(executor_globals) EX1#define EX(element) execute_data.element 关于PHPAPI在源码中我们经常能见到PHPAPI这样的前缀,__attribute__ ((packed)) 的作用就是告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。这个功能是跟操作系统没关系，跟编译器有关，gcc编译器不是紧凑模式的，我在windows下，用vc的编译器也不是紧凑的，用tc的编译器就是紧凑的 他的定义如下：12345# if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4# define PHPAPI __attribute__ ((visibility(\"default\")))# else# define PHPAPI# endif TSRM在PHP源码中随处到可以看到TSRM这个标记 TSRM线程安全资源管理器(Thread Safe Resource Manager)，这是个尝尝被忽视，并很少被人说起的“层”(layer), 它在PHP源码的TSRM目录下。一般的情况下，这个层只会在被指明需要的时候才会被启用(比如,Apache2+worker MPM,一个基于线程的MPM)，对于Win32下的Apache来说，是基于多线程的，所以这个层在Win32下总是被启用的。 ZTSZend线程安全(Zend Thread Safety)，当TSRM被启用的时候，就会定义这个名为ZTS的宏。 tsrm_lsTSRM存储器(TSRM Local Storage)，这个是在扩展和Zend中真正被实际使用的指代TSRM存储的变量名。 相关的定义如下123456789101112131415#ifdef ZTS#define TSRMLS_D void ***tsrm_ls#define TSRMLS_DC , TSRMLS_D#define TSRMLS_C tsrm_ls#define TSRMLS_CC , TSRMLS_C#else /* non ZTS */#define TSRMLS_D void#define TSRMLS_DC#define TSRMLS_C#define TSRMLS_CC#endif /* ZTS */ 注意上面的逗号 相关原理介绍可以看一看PHP大牛鸟哥的这篇文章：TSRM到底是什么? 简单来说TSRM就是用来保证线程安全的，在编写代码的时候要记得加上 二、代码生成以及执行 PHP执行的生命周期和ZEND引擎PHP的单进程生命周期 步骤如下： 启动 初始化若干全局变量 初始化若干常量 初始化Zend引擎和核心组件 解析php.ini 全局操作函数的初始化 初始化静态构建的模块和共享模块(MINIT) 禁用函数和类 ACTIVATION 激活Zend引擎 激活SAPI 环境初始化 模块请求初始化 运行 DEACTIVATION 结束 flush 关闭Zend引擎 多进程的生命周期 多线程的生命周期 关于Zend引擎Zend引擎是PHP实现的核心，提供了语言实现上的基础设施。例如：PHP的语法实现，脚本的编译运行环境， 扩展机制以及内存管理等，当然这里的PHP指的是官方的PHP实现(除了官方的实现， 目前比较知名的有facebook的hiphop实现，不过到目前为止，PHP还没有一个标准的语言规范)， 而PHP则提供了请求处理和其他Web服务器的接口(SAPI)。 PHP的SAPISAPI提供了请求处理和其他Web Server的接口 PHP SAPI简单示意图 对应源码文件在/main/SAPI.h 整个SAPI类似于一个面向对象中的模板方法模式的应用。 SAPI.c和SAPI.h文件所包含的一些函数就是模板方法模式中的抽象模板， 各个服务器对于sapi_module的定义及相关实现则是一个个具体的模板。 _sapi_module_struct结构体的定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct _sapi_module_struct &#123; char *name; // 名字（标识用） char *pretty_name; // 更好理解的名字（自己翻译的） int (*startup)(struct _sapi_module_struct *sapi_module); // 启动函数 int (*shutdown)(struct _sapi_module_struct *sapi_module); // 关闭方法 int (*activate)(TSRMLS_D); // 激活 int (*deactivate)(TSRMLS_D); // 停用 int (*ub_write)(const char *str, unsigned int str_length TSRMLS_DC); // 不缓存的写操作(unbuffered write) void (*flush)(void *server_context); // flush struct stat *(*get_stat)(TSRMLS_D); // get uid char *(*getenv)(char *name, size_t name_len TSRMLS_DC); // getenv void (*sapi_error)(int type, const char *error_msg, ...); /* error handler */ int (*header_handler)(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers TSRMLS_DC); /* header handler */ /* send headers handler */ int (*send_headers)(sapi_headers_struct *sapi_headers TSRMLS_DC); void (*send_header)(sapi_header_struct *sapi_header, void *server_context TSRMLS_DC); /* send header handler */ int (*read_post)(char *buffer, uint count_bytes TSRMLS_DC); /* read POST data */ char *(*read_cookies)(TSRMLS_D); /* read Cookies */ /* register server variables */ void (*register_server_variables)(zval *track_vars_array TSRMLS_DC); void (*log_message)(char *message); /* Log message */ time_t (*get_request_time)(TSRMLS_D); /* Request Time */ void (*terminate_process)(TSRMLS_D); /* Child Terminate */ char *php_ini_path_override; // 覆盖的ini路径 void (*block_interruptions)(void); void (*unblock_interruptions)(void); void (*default_post_reader)(TSRMLS_D); void (*treat_data)(int arg, char *str, zval *destArray TSRMLS_DC); char *executable_location; int php_ini_ignore; int php_ini_ignore_cwd; /* don't look for php.ini in the current directory */ int (*get_fd)(int *fd TSRMLS_DC); int (*force_http_10)(TSRMLS_D); int (*get_target_uid)(uid_t * TSRMLS_DC); int (*get_target_gid)(gid_t * TSRMLS_DC); unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC); void (*ini_defaults)(HashTable *configuration_hash); int phpinfo_as_text; char *ini_entries; const zend_function_entry *additional_functions; unsigned int (*input_filter_init)(TSRMLS_D);&#125;; 还有存放全局变量的结构体：1234567891011121314151617181920typedef struct _sapi_globals_struct &#123; void *server_context; sapi_request_info request_info; sapi_headers_struct sapi_headers; int64_t read_post_bytes; unsigned char post_read; unsigned char headers_sent; struct stat global_stat; char *default_mimetype; char *default_charset; HashTable *rfc1867_uploaded_files; long post_max_size; int options; zend_bool sapi_started; double global_request_time; HashTable known_post_content_types; zval *callback_func; zend_fcall_info_cache fci_cache; zend_bool callback_run;&#125; sapi_globals_struct; 在apache中SAPI的定义123456789static sapi_module_struct apache2_sapi_module = &#123; \"apache2handler\", \"Apache 2.0 Handler\", php_apache2_startup, /* startup */ php_module_shutdown_wrapper, /* shutdown */ ...&#125; PHP脚本的执行PHP是一边运行一边解析的脚本型语言，在解析的过程中生成了OP码，减少性能的损耗 在PHP的执行过程中，通过cli方式或者CGI方式传递给php程序需要执行的文件， php程序完成基本的准备工作后启动PHP及Zend引擎， 加载注册的扩展模块。初始化完成后读取脚本文件，Zend引擎对脚本文件进行词法分析，语法分析。然后编译成opcode执行。 如果安装了apc之类的opcode缓存， 编译环节可能会被跳过而直接从缓存中读取opcode执行。 PHP在读取到脚本文件后首先对代码进行词法分析，PHP的词法分析器是通过lex生成的， 词法规则文件在$PHP_SRC/Zend/zend_language_scanner.l， 这一阶段lex会会将源代码按照词法规则切分一个一个的标记(token)。PHP中提供了一个函数token_get_all()， 该函数接收一个字符串参数， 返回一个按照词法规则切分好的数组。 例如将上面的php代码作为参数传递给这个函数： 举个例子：12345678&lt;?php$code =&lt;&lt;&lt;PHP_CODE&lt;?php$str = \"Hello, Tipi\\n\";echo $str;PHP_CODE; var_dump(token_get_all($code)); 运行上述代码，即代码被按照标准分词12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849array ( 0 =&gt; array ( 0 =&gt; 368, // 脚本开始标记 1 =&gt; '&lt;?php // 匹配到的字符串', 2 =&gt; 1, ), 1 =&gt; array ( 0 =&gt; 371, 1 =&gt; ' ', 2 =&gt; 2, ), 2 =&gt; '=', 3 =&gt; array ( 0 =&gt; 371, 1 =&gt; ' ', 2 =&gt; 2, ), 4 =&gt; array ( 0 =&gt; 315, 1 =&gt; '\"Hello, Tipi\"', 2 =&gt; 2, ), 5 =&gt; ';', 6 =&gt; array ( 0 =&gt; 371, 1 =&gt; '', 2 =&gt; 3, ), 7 =&gt; array ( 0 =&gt; 316, 1 =&gt; 'echo', 2 =&gt; 4, ), 8 =&gt; array ( 0 =&gt; 371, 1 =&gt; ' ', 2 =&gt; 4, ), 9 =&gt; ';', PHP脚本编译为opcode保存在op_array中，其内部存储的结构如下：123456789101112131415161718192021222324252627struct _zend_op_array &#123; /* Common elements */ zend_uchar type; char *function_name; // 如果是用户定义的函数则，这里将保存函数的名字 zend_class_entry *scope; zend_uint fn_flags; union _zend_function *prototype; zend_uint num_args; zend_uint required_num_args; zend_arg_info *arg_info; zend_bool pass_rest_by_reference; unsigned char return_reference; /* END of common elements */ zend_bool done_pass_two; zend_uint *refcount; zend_op *opcodes; // opcode数组 zend_uint last，size; zend_compiled_variable *vars; int last_var，size_var; // ...&#125; 如上面的注释，opcodes保存在这里，在执行的时候由下面的execute函数执行：1234ZEND_API void execute(zend_op_array *op_array TSRMLS_DC)&#123; // ... 循环执行op_array中的opcode或者执行其他op_array中的opcode&#125; 三、变量以及数据类型从类型的维度来看，编程语言可以分为三大类： 静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在编译期(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。 动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在运行时确定的， 那么也就是说类型通常可以在运行时发生变化 无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感知。 变量相关结构都在Zend/zend.h中定义 变量结构zval的结构如下：1234567struct _zval_struct &#123; /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc;&#125;; 其中refcount__gc是用来计算变量被引用的数量，is_ref__gc记录变量是否被引用这两个值都是用来辅助gc即内存回收机制的，当refcount为0的时候则回收内存 其中zvalue_value value用于存放变量的值，结构如下：1234567891011typedef union _zvalue_value &#123; long lval; /* long value */ double dval; /* double value */ struct &#123; char *val; int len; &#125; str; HashTable *ht; /* hash table value */ zend_object_value obj; zend_ast *ast;&#125; zvalue_value; union是共用体声明，即共享一块内存，取最大长度的值作为整个结构的大小。详细介绍可以看这里：共用声明和共用一变量定义 上述HashTable就是PHP的array的实现 object的结构如下：123456typedef struct _zend_object &#123; zend_class_entry *ce; HashTable *properties; zval **properties_table; HashTable *guards; /* protects from __get/__set ... recursion */&#125; zend_object; 存在的问题 PHP5的zval定义是随着Zend Engine 2诞生的, 随着时间的推移, 当时设计的局限性也越来越明显: 首先这个结构体的大小是(在64位系统)24个字节, 我们仔细看这个zval.value联合体, 其中zend_object_value是最大的长板, 它导致整个value需要16个字节, 这个应该是很容易可以优化掉的, 比如把它挪出来, 用个指针代替,因为毕竟IS_OBJECT也不是最最常用的类型. 第二, 这个结构体的每一个字段都有明确的含义定义, 没有预留任何的自定义字段, 导致在PHP5时代做很多的优化的时候, 需要存储一些和zval相关的信息的时候, 不得不采用其他结构体映射, 或者外部包装后打补丁的方式来扩充zval 第三, PHP的zval大部分都是按值传递, 写时拷贝的值, 但是有俩个例外, 就是对象和资源, 他们永远都是按引用传递, 这样就造成一个问题, 对象和资源在除了zval中的引用计数以外, 还需要一个全局的引用计数, 这样才能保证内存可以回收. 所以在PHP5的时代, 以对象为例, 它有俩套引用计数, 一个是zval中的, 另外一个是obj自身的计数 第四, 我们知道PHP中, 大量的计算都是面向字符串的, 然而因为引用计数是作用在zval的, 那么就会导致如果要拷贝一个字符串类型的zval, 我们别无他法只能复制这个字符串. 当我们把一个zval的字符串作为key添加到一个数组里的时候, 我们别无他法只能复制这个字符串. 虽然在PHP5.4的时候, 我们引入了INTERNED STRING, 但是还是不能根本解决这个问题. 以上zval的结构是在php5中的定义，php7中发生了变化并且进行了优化以下是php7中的zval结构12345678910111213141516171819202122232425262728293031323334353637383940struct _zval_struct &#123; union &#123; zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr;. zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct &#123; uint32_t w1; uint32_t w2; &#125; ww; &#125; value; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar type, /* active type */ zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /* call info for EX(This) */ &#125; v; uint32_t type_info; &#125; u1; union &#123; uint32_t var_flags; uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* literal cache slot */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ &#125; u2;&#125;; 虽然看起来变得好大, 但其实仔细看, 全部都是联合体, 这个新的zval在64位环境下,现在只需要16个字节(2个指针size), 它主要分为俩个部分, value和扩充字段, 而扩充字段又分为u1和u2俩个部分, 其中u1是type info, u2是各种辅助字段. 所有的复杂类型的定义, 开始的时候都是zend_refcounted_h结构, 这个结构里除了引用计数以外, 还有GC相关的结构. 从而在做GC回收的时候, GC不需要关心具体类型是什么, 所有的它都可以当做zend_refcounted*结构来处理. HashTablePHP强大的数组就是利用HashTable实现的 关于HashTable的内容在我的博客之前也有提及，可以去瞧一瞧 PHP内核中的HashTable 常量常量的定义放在Zend/zend_constants.h中1234567typedef struct _zend_constant &#123; zval value; int flags; char *name; uint name_len; int module_number;&#125; zend_constant; 定义结构十分之简单define()内置函数的实现过程如下：1234567891011121314151617181920212223242526272829/* &#123;&#123;&#123; proto bool define(string constant_name, mixed value, boolean case_insensitive=false) Define a new constant */ZEND_FUNCTION(define)&#123; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sz|b\", &amp;name, &amp;name_len, &amp;val, &amp;non_cs) == FAILURE) &#123; return; &#125; ... // 类常量定义 此处不做介绍 ... // 值类型判断和处理 c.value = *val; zval_copy_ctor(&amp;c.value); if (val_free) &#123; zval_ptr_dtor(&amp;val_free); &#125; c.flags = case_sensitive; /* non persistent */ c.name = zend_strndup(name, name_len); c.name_len = name_len+1; c.module_number = PHP_USER_CONSTANT; if (zend_register_constant(&amp;c TSRMLS_CC) == SUCCESS) &#123; RETURN_TRUE; &#125; else &#123; RETURN_FALSE; &#125;&#125;/* &#125;&#125;&#125; */ 上面的代码已经对对象和类常量做了简化处理， 其实现上是一个将传递的参数传递给新建的zend_constant结构，并将这个结构体注册到常量列表中的过程。 关于大小写敏感，函数的第三个参数表示是否大小不敏感，默认为false（大小写敏感）。 这个参数最后会赋值给zend_constant结构体的flags字段。 预定义变量在某个局部函数中使用类似于$GLOBALS变量这样的预定义变量， 如果在此函数中有改变的它们的值的话，这些变量在其它局部函数调用时会发现也会同步变化。 为什么呢？是否是这些变量存放在一个集中存储的地方？ 从PHP中间代码的执行来看，这些变量是存储在一个集中的地方：EG(symbol_table)。 在模块初始化时，$GLOBALS在zend_startup函数中通过调用zend_register_auto_global将GLOBALS注册为预定义变量。 $_GET、$_POST等在php_startup_auto_globals函数中通过zend_register_auto_global将_GET、_POST等注册为预定义变量。 在通过$获取变量时，PHP内核都会通过这些变量名区分是否为全局变量（ZEND_FETCH_GLOBAL）， 其调用的判断函数为zend_is_auto_global，这个过程是在生成中间代码过程中实现的。 如果是ZEND_FETCH_GLOBAL或ZEND_FETCH_GLOBAL_LOCK(global语句后的效果)， 则在获取获取变量表时(zend_get_target_symbol_table)， 直接返回EG(symbol_table)。则这些变量的所有操作都会在全局变量表进行。 类型提示实现 变量作用域对于全局变量，Zend引擎有一个_zend_executor_globals结构（EG），该结构中的symbol_table就是全局符号表， 其中保存了在顶层作用域中的变量。同样，函数或者对象的方法在被调用时会创建active_symbol_table来保存局部变量。 当程序在顶层中使用某个变量时，Zend Engine就会在symbol_table中进行遍历， 同理，如果程序运行于某个函数中，Zend引擎会遍历查询与其对应的active_symbol_table， 而每个函数的active_symbol_table是相对独立的，由此而实现的作用域的独立。 1234567891011121314151617181920struct _zend_execute_data &#123; struct _zend_op *opline; zend_function_state function_state; zend_function *fbc; /* Function Being Called */ zend_class_entry *called_scope; zend_op_array *op_array; zval *object; union _temp_variable *Ts; zval ***CVs; HashTable *symbol_table; struct _zend_execute_data *prev_execute_data; zval *old_error_reporting; zend_bool nested; zval **original_return_value; zend_class_entry *current_scope; zend_class_entry *current_called_scope; zval *current_this; zval *current_object; struct _zend_op *call_opline;&#125;; 函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的*active_symbol_table会指向当前_zend_execute_data中的*symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 类型转换可以参照文件ext/standard/type.c，里面包含了类型转换需要用到的函数 PHP的标准扩展中提供了两个有用的方法settype()以及gettype()方法，前者可以动态的改变变量的数据类型， gettype()方法则是返回变量的数据类型 四、函数的实现PHP函数分为以下几种： 用户定义的函数 内部函数：如我们常见的count、strpos、implode等函数，这些都是标准函数，它们都是由标准扩展提供的； 如我们经常用到的isset、empty、eval等函数，这些结构被称之为语言结构。 还有一些函数需要和特定的PHP扩展模块一起编译并开启，否则无法使用。也就是有些扩展是可选的。 匿名函数：Closure 变量函数： 12$func = 'print_r';$func('i am print_r function.'); zend_function可以与zend_op_array互换 zend_function可以与zend_internal_function互换 但是一个zend_op_array结构转换成zend_function是不能再次转变成zend_internal_function结构的，反之亦然。其实zend_function就是一个混合的数据结构，这种结构在一定程序上节省了内存空间。 函数的结构体包含一些公共的元素，即Common elements，所以它们之间可以比较方便地实现转换 函数定义词法分析-&gt;语法分析-&gt;生成中间代码(zend_op)-&gt;执行中间代码执行代码的过程在文件Zend/zend_vm_execute.h 其中zend_op的定义如下：123456789101112struct _zend_op &#123; opcode_handler_t handler; znode_op op1; znode_op op2; znode_op result; ulong extended_value; uint lineno; zend_uchar opcode; zend_uchar op1_type; zend_uchar op2_type; zend_uchar result_type;&#125;; 函数的参数函数的参数存放在zend_arg_info中，其定义放在文件Zend/zend.compile.h中 1234567891011typedef struct _zend_arg_info &#123; const char *name; /* 参数的名称*/ zend_uint name_len; /* 参数名称的长度*/ const char *class_name; /* 类名 */ zend_uint class_name_len; /* 类名长度*/ zend_bool array_type_hint; /* 数组类型提示 */ zend_bool allow_null; /* 是否允许为NULL */ zend_bool pass_by_reference; /* 是否引用传递 */ zend_bool return_reference; int required_num_args; &#125; zend_arg_info; 函数的返回值在PHP中，函数都有返回值，分两种情况，使用return语句明确的返回和没有return语句返回NULL。 函数结束时需要调用zend_do_return：12345678910111213141516171819202122232425262728293031void zend_do_return(znode *expr, int do_end_vparse TSRMLS_DC) /* &#123;&#123;&#123; */&#123; zend_op *opline; int start_op_number, end_op_number; if (do_end_vparse) &#123; if (CG(active_op_array)-&gt;return_reference &amp;&amp; !zend_is_function_or_method_call(expr)) &#123; zend_do_end_variable_parse(expr, BP_VAR_W, 0 TSRMLS_CC);/* 处理返回引用 */ &#125; else &#123; zend_do_end_variable_parse(expr, BP_VAR_R, 0 TSRMLS_CC);/* 处理常规变量返回 */ &#125; &#125; ...// 省略 取其它中间代码操作 opline-&gt;opcode = ZEND_RETURN; if (expr) &#123; opline-&gt;op1 = *expr; if (do_end_vparse &amp;&amp; zend_is_function_or_method_call(expr)) &#123; opline-&gt;extended_value = ZEND_RETURNS_FUNCTION; &#125; &#125; else &#123; opline-&gt;op1.op_type = IS_CONST; INIT_ZVAL(opline-&gt;op1.u.constant); &#125; SET_UNUSED(opline-&gt;op2);&#125; 可见生成的中间代码为ZEND_RETURN ZEND_RETURN中间代码会执行 ZEND_RETURN_SPEC_CONST_HANDLER， ZEND_RETURN_SPEC_TMP_HANDLER或ZEND_RETURN_SPEC_TMP_HANDLER。 这三个函数的执行流程基本类似，包括对一些错误的处理。 这里我们看看ZEND_RETURN_SPEC_CONST_HANDLER是如何执行的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static int ZEND_FASTCALL ZEND_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; zend_op *opline = EX(opline); zval *retval_ptr; zval **retval_ptr_ptr; if (EG(active_op_array)-&gt;return_reference == ZEND_RETURN_REF) &#123; // 返回引用时不允许常量和临时变量 if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) &#123; /* Not supposed to happen, but we'll allow it */ zend_error(E_NOTICE, \"Only variable references \\ should be returned by reference\"); goto return_by_value; &#125; retval_ptr_ptr = NULL; // 返回值 if (IS_CONST == IS_VAR &amp;&amp; !retval_ptr_ptr) &#123; zend_error_noreturn(E_ERROR, \"Cannot return string offsets by reference\"); &#125; if (IS_CONST == IS_VAR &amp;&amp; !Z_ISREF_PP(retval_ptr_ptr)) &#123; if (opline-&gt;extended_value == ZEND_RETURNS_FUNCTION &amp;&amp; EX_T(opline-&gt;op1.u.var).var.fcall_returned_reference) &#123; &#125; else if (EX_T(opline-&gt;op1.u.var).var.ptr_ptr == &amp;EX_T(opline-&gt;op1.u.var).var.ptr) &#123; if (IS_CONST == IS_VAR &amp;&amp; !0) &#123; /* undo the effect of get_zval_ptr_ptr() */ PZVAL_LOCK(*retval_ptr_ptr); &#125; zend_error(E_NOTICE, \"Only variable references \\ should be returned by reference\"); goto return_by_value; &#125; &#125; if (EG(return_value_ptr_ptr)) &#123; // 返回引用 SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr_ptr); // is_ref__gc设置为1 Z_ADDREF_PP(retval_ptr_ptr); // refcount__gc计数加1 (*EG(return_value_ptr_ptr)) = (*retval_ptr_ptr); &#125; &#125; else &#123;return_by_value: retval_ptr = &amp;opline-&gt;op1.u.constant; if (!EG(return_value_ptr_ptr)) &#123; if (IS_CONST == IS_TMP_VAR) &#123; &#125; &#125; else if (!0) &#123; /* Not a temp var */ if (IS_CONST == IS_CONST || EG(active_op_array)-&gt;return_reference == ZEND_RETURN_REF || (PZVAL_IS_REF(retval_ptr) &amp;&amp; Z_REFCOUNT_P(retval_ptr) &gt; 0)) &#123; zval *ret; ALLOC_ZVAL(ret); INIT_PZVAL_COPY(ret, retval_ptr); // 复制一份给返回值 zval_copy_ctor(ret); *EG(return_value_ptr_ptr) = ret; &#125; else &#123; *EG(return_value_ptr_ptr) = retval_ptr; // 直接赋值 Z_ADDREF_P(retval_ptr); &#125; &#125; else &#123; zval *ret; ALLOC_ZVAL(ret); INIT_PZVAL_COPY(ret, retval_ptr); // 复制一份给返回值 *EG(return_value_ptr_ptr) = ret; &#125; &#125; return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU); // 返回前执行收尾工作&#125; 在没有声明返回值时：1zend_do_return(NULL, 0 TSRMLS_CC); zend引擎“自动”返回一个NULL 函数的调用与执行函数的调用Zend在调用执行PHP代码之前先要把代码转换为opcode，然后再进行执行。我们先来看看一个PHP实例以及其生成的opcode123456&lt;?php function foo()&#123; echo \"I'm foo!\"; &#125; foo();?&gt; 123456789101112function name: (null)line # * op fetch ext return operands--------------------------------------------------------------------------------- DO_FCALL 0 'foo' NOP &gt; RETURN 1 function name: fooline # * op fetch ext return operands--------------------------------------------------------------------------------- 4 0 &gt; ECHO 'I%27m+foo%21' 5 1 &gt; RETURN 可以看到，上部主要集中在调用函数foo上面，PHP对函数名统一采用strtolower操作，所以对大小写是不敏感的Zend Engine会在function_table中根据函数名，若找不到，则抛出错误提示；若找到该名，则返回函数zend_function的结构指针，然后通过function.type的值来判断函数是内部函数还是用户定义的函数，调用zend_execute_internal（zend_internal_function.handler）或者直接 调用zend_execute来执行这个函数包含的zend_op_array 函数的执行内部函数的执行与用户函数不同。用户函数是php语句一条条“翻译”成op_line组成的一个op_array，而内部函数则是用C来实现的，因为执行环境也是C环境， 所以可以直接调用 看看这个例子：1234&lt;?php $foo = 'test'; print_r($foo);?&gt; 其对应的opcode123456line # * op fetch ext return operands--------------------------------------------------------------------------------- 2 0 &gt; ASSIGN !0, 'test' 3 1 SEND_VAR !0 2 DO_FCALL 1 'print_r' 4 3 &gt; RETURN 1 先将EG下的This，scope等暂时缓存起来（这些在后面会都恢复到此时缓存的数据）。在此之后，对于用户自定义的函数， 程序会依据zend_execute是否等于execute并且是否为异常来判断是返回，还是直接执行函数定义的op_array： 123456if (zend_execute == execute &amp;&amp; !EG(exception)) &#123; EX(call_opline) = opline; ZEND_VM_ENTER();&#125; else &#123; zend_execute(EG(active_op_array) TSRMLS_CC);&#125; 而在Zend/zend.c文件的zend_startup函数中，已将zend_execute赋值为：1ret = EX(opline)-&gt;handler(execute_data TSRMLS_CC) 调用每个opcode的处理函数。而execute_data在execute函数开始时就已经给其分配了空间，这就是这个函数的执行环境。 匿名函数PHP匿名函数的实现主要有：create_function()函数的使用、__invoke、闭包 create_function先介绍一下create_function() create_function()可以创建一个匿名函数 看看官方手册上关于create_function的介绍： string create_function ( string $args , string $code )create_function — Create an anonymous (lambda-style) function该函数主要就是用于创建匿名函数用的 我们来一起看看一个例子123456789&lt;?php$func = create_function('', 'echo \"Function created dynamic\";');echo $func; // lambda_1 $func(); // Function created dynamic $my_func = 'lambda_1';$my_func(); // 不存在这个函数lambda_1(); // 不存在这个函数 从上面例子中可以看到，创建一个匿名函数其实他是“有名”的，但是为什么这里会提示找不到函数呢我们一起来看看debug_zval_dump的结果123456&lt;?php$func = create_function('', 'echo \"Hello\";'); $my_func_name = 'lambda_1';debug_zval_dump($func); // string(9) \"lambda_1\" refcount(2)debug_zval_dump($my_func_name); // string(8) \"lambda_1\" refcount(2) 可见匿名函数的长度是9而实际上lambda_1的长度只有8 12345678910111213#define LAMBDA_TEMP_FUNCNAME \"__lambda_func\" ZEND_FUNCTION(create_function)&#123; // ... 省去无关代码 function_name = (char *) emalloc(sizeof(\"0lambda_\")+MAX_LENGTH_OF_LONG); function_name[0] = '\\0'; // &lt;--- 这里 do &#123; function_name_length = 1 + sprintf(function_name + 1, \"lambda_%d\", ++EG(lambda_count)); &#125; while (zend_hash_add(EG(function_table), function_name, function_name_length+1, &amp;new_function, sizeof(zend_function), NULL)==FAILURE); zend_hash_del(EG(function_table), LAMBDA_TEMP_FUNCNAME, sizeof(LAMBDA_TEMP_FUNCNAME)); RETURN_STRINGL(function_name, function_name_length, 0);&#125; 可以见到函数在名字的前面多加了一个&#39;\\0&#39;的空字符，并且利用count来进行函数名的编号所以我们可以通过在函数名前加一个“空字符”来调用匿名函数：1234&lt;?php $my_func = chr(0) . \"lambda_1\"; //chr()可以转换生成ascii字符$my_func(); // Hello 这种创建”匿名函数”的方式有一些缺点: 函数的定义是通过字符串动态eval的， 这就无法进行基本的语法检查; 这类函数和普通函数没有本质区别， 无法实现闭包的效果. 真正的匿名函数__invoke如果定义了__invoke()魔术方法的话那么在对象被当作函数调用时则会被调用这个和C++中的重载有点类似123456789&lt;?phpclass Callme &#123; public function __invoke($phone_num) &#123; echo \"Hello: $phone_num\"; &#125;&#125; $call = new Callme();$call(13810688888); // \"Hello: 13810688888 匿名函数的实现其实匿名函数也只是一个普通的类而已1234567&lt;?php$func = function() &#123; echo \"Hello, anonymous function\";&#125; echo gettype($func); // objectecho get_class($func); // Closure 闭包的实现看看一段PHP闭包代码的执行过程吧：1234567&lt;?php$i=100;$counter = function() use($i) &#123; debug_zval_dump($i);&#125;; $counter(); 再看看VLD生成的结果12345678910111213141516171819202122$ php -dvld.active=1 closure.php vars: !0 = $i, !1 = $counter# * op fetch ext return operands------------------------------------------------------------------------0 &gt; ASSIGN !0, 1001 ZEND_DECLARE_LAMBDA_FUNCTION '%00%7Bclosure2 ASSIGN !1, ~13 INIT_FCALL_BY_NAME !14 DO_FCALL_BY_NAME 0 5 &gt; RETURN 1 function name: &#123;closure&#125;number of ops: 5compiled vars: !0 = $iline # * op fetch ext return operands-------------------------------------------------------------------------------- 3 0 &gt; FETCH_R static $0 'i' 1 ASSIGN !0, $0 4 2 SEND_VAR !0 3 DO_FCALL 1 'debug_zval_dump' 5 4 &gt; RETURN null 上面根据情况去掉了一些无关的输出， 从上到下， 第1开始将100赋值给!0也就是变量$i， 随后执行ZEND_DECLARE_LAMBDA_FUNCTION， 那我们去相关的opcode执行函数中看看这里是怎么执行的， 这个opcode的处理函数位于Zend/zend_vm_execute.h中:123456789101112131415static int ZEND_FASTCALL ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; zend_op *opline = EX(opline); zend_function *op_array; if (zend_hash_quick_find(EG(function_table), Z_STRVAL(opline-&gt;op1.u.constant), Z_STRLEN(opline-&gt;op1.u.constant), Z_LVAL(opline-&gt;op2.u.constant), (void *) &amp;op_array) == FAILURE || op_array-&gt;type != ZEND_USER_FUNCTION) &#123; zend_error_noreturn(E_ERROR, \"Base lambda function for closure not found\"); &#125; zend_create_closure(&amp;EX_T(opline-&gt;result.u.var).tmp_var, op_array TSRMLS_CC); ZEND_VM_NEXT_OPCODE();&#125; 看看创建闭包的函数，在Zend/zend_closures.c中：1234567891011121314151617181920212223242526ZEND_API void zend_create_closure(zval *res, zend_function *func TSRMLS_DC)&#123; zend_closure *closure; object_init_ex(res, zend_ce_closure); closure = (zend_closure *)zend_object_store_get_object(res TSRMLS_CC); closure-&gt;func = *func; if (closure-&gt;func.type == ZEND_USER_FUNCTION) &#123; // 如果是用户定义的匿名函数 if (closure-&gt;func.op_array.static_variables) &#123; HashTable *static_variables = closure-&gt;func.op_array.static_variables; // 为函数申请存储静态变量的哈希表空间 ALLOC_HASHTABLE(closure-&gt;func.op_array.static_variables); zend_hash_init(closure-&gt;func.op_array.static_variables, zend_hash_num_elements(static_variables), NULL, ZVAL_PTR_DTOR, 0); // 循环当前静态变量列表， 使用zval_copy_static_var方法处理 zend_hash_apply_with_arguments(static_variables TSRMLS_CC, (apply_func_args_t)zval_copy_static_var, 1, closure-&gt;func.op_array.static_variables); &#125; (*closure-&gt;func.op_array.refcount)++; &#125; closure-&gt;func.common.scope = NULL;&#125; 类和面向对象类的结构和实现类的结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct _zend_class_entry &#123; char type; // 类型：ZEND_INTERNAL_CLASS / ZEND_USER_CLASS char *name;// 类名称 zend_uint name_length; // 即sizeof(name) - 1 struct _zend_class_entry *parent; // 继承的父类 int refcount; // 引用数 zend_bool constants_updated; zend_uint ce_flags; // ZEND_ACC_IMPLICIT_ABSTRACT_CLASS: 类存在abstract方法 // ZEND_ACC_EXPLICIT_ABSTRACT_CLASS: 在类名称前加了abstract关键字 // ZEND_ACC_FINAL_CLASS // ZEND_ACC_INTERFACE HashTable function_table; // 方法 HashTable default_properties; // 默认属性 HashTable properties_info; // 属性信息 HashTable default_static_members;// 类本身所具有的静态变量 HashTable *static_members; // type == ZEND_USER_CLASS时，取&amp;default_static_members; // type == ZEND_INTERAL_CLASS时，设为NULL HashTable constants_table; // 常量 struct _zend_function_entry *builtin_functions;// 方法定义入口 union _zend_function *constructor; union _zend_function *destructor; union _zend_function *clone; /* 魔术方法 */ union _zend_function *__get; union _zend_function *__set; union _zend_function *__unset; union _zend_function *__isset; union _zend_function *__call; union _zend_function *__tostring; union _zend_function *serialize_func; union _zend_function *unserialize_func; zend_class_iterator_funcs iterator_funcs;// 迭代 /* 类句柄 */ zend_object_value (*create_object)(zend_class_entry *class_type TSRMLS_DC); zend_object_iterator *(*get_iterator)(zend_class_entry *ce, zval *object, intby_ref TSRMLS_DC); /* 类声明的接口 */ int(*interface_gets_implemented)(zend_class_entry *iface, zend_class_entry *class_type TSRMLS_DC); /* 序列化回调函数指针 */ int(*serialize)(zval *object， unsignedchar**buffer, zend_uint *buf_len, zend_serialize_data *data TSRMLS_DC); int(*unserialize)(zval **object, zend_class_entry *ce, constunsignedchar*buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC); zend_class_entry **interfaces; // 类实现的接口 zend_uint num_interfaces; // 类实现的接口数 zend_class_entry **traits; zend_uint num_traits; zend_trait_alias **trait_aliases; zend_trait_precedence **trait_precedences; union &#123; struct &#123; const char *filename; zend_uint line_start; zend_uint line_end; const char *doc_comment; zend_uint doc_comment_len; &#125; user; struct &#123; const struct _zend_function_entry *builtin_functions; struct _zend_module_entry *module; &#125; internal; &#125; info;&#125;; 类的实现参考TIPI深入理解PHP内核深入理解PHP7之zvalTSRM到底是什么?","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"},{"name":"内核","slug":"内核","permalink":"https://github.com/kong36088/kong36088.github.io/tags/内核/"}]},{"title":"CodeIgniter源码阅读笔记","date":"2016-12-12T13:00:25.000Z","path":"2016/12/12/CodeIgniter源码阅读笔记/","text":"入口文件index.php入口文件index.php中主要定义了一些全局路径变量如BASEPATH和APPPATH这种常用的变量并且可以配置代码的部署环境，最后require真正的核心文件CodeIgniter.php CodeIgniter.php位于system/core/目录下，该文件是最主要的核心文件，他负责引入全局需要用到的一些关键的类，比如Common.php和Controller.php，这些类处于system/core目录下CodeIgniter.php有点策略模式和工厂模式的意味了，很好的解决了代码耦合的问题，代码可拓展性很高，这也是我喜欢CI的一个地方CI的异常处理机制是利用PHP的error_handler和exception_handler进行处理，实现代码如下： 1234//全局的异常处理都在这里进行set_error_handler('_error_handler');set_exception_handler('_exception_handler');register_shutdown_function('_shutdown_handler'); 这里的error_handler和exception_handler都是利用CI的Loader进行Exception类的实例化并且进行异常处理，同时Loader加载Log类进行日志记录 核心类库Common.php该文件定义了一些全局当中需要用到的函数，辅助框架运行，如is_cli()判断来判断是否cli运行环境 DB_query_builder.php分析ORM的语法，主要利用explode函数进行词语分割这里我们看看select方法的实现12345678910111213141516171819202122232425262728293031//解析select中的数据，放入数组，便于driver使用public function select($select = '*', $escape = NULL)&#123; if (is_string($select)) &#123; $select = explode(',', $select); &#125; // If the escape value was not set, we will base it on the global setting is_bool($escape) OR $escape = $this-&gt;_protect_identifiers; foreach ($select as $val) &#123; $val = trim($val); if ($val !== '') &#123; $this-&gt;qb_select[] = $val; $this-&gt;qb_no_escape[] = $escape; if ($this-&gt;qb_caching === TRUE) &#123; $this-&gt;qb_cache_select[] = $val; $this-&gt;qb_cache_exists[] = 'select'; $this-&gt;qb_cache_no_escape[] = $escape; &#125; &#125; &#125; return $this;&#125; 通过explode分割select里面的参数，并放入数组当中，利用qb_cache_exists记录已有的操作类型，qb_cache_select记录需要select的数据，最后可以通过这些数据当中的数据进行不同数据库dialect下SQL语句的生成另外query_builder中每个方法都返回一个$this指针，实现了CI中ORM”object-&gt;method()-&gt;method()”这样的链式操作。 在database目录下的都是主要的db driver，是一个一个的abstract类，用于被不同的数据库类型db drvier继承。 Loader.phpLoader就有点单例模式和策略模式的意味在里面了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Nesting level of the output buffering mechanism * * @var int */protected $_ci_ob_level;/** * List of paths to load views from * * @var array */protected $_ci_view_paths = array(VIEWPATH =&gt; TRUE);/** * List of paths to load libraries from * * @var array */protected $_ci_library_paths = array(APPPATH, BASEPATH);/** * List of paths to load models from * * @var array */protected $_ci_model_paths = array(APPPATH);/** * List of paths to load helpers from * * @var array */protected $_ci_helper_paths = array(APPPATH, BASEPATH);/** * List of cached variables * * @var array */protected $_ci_cached_vars = array();/** * List of loaded classes * * @var array */protected $_ci_classes = array();/** * List of loaded models * * @var array */protected $_ci_models = array();/** * List of loaded helpers * * @var array */protected $_ci_helpers = array();/** * List of class name mappings * * @var array */protected $_ci_varmap = array( 'unit_test' =&gt; 'unit', 'user_agent' =&gt; 'agent'); 上面是Loader的属性，用来保存已经加载过的工具，使实例化出来的工具类或者方法保持单一性，不会重复生成造成浪费。例如$_ci_models，在控制器中利用代码$this-&gt;load-&gt;model(&#39;Model_name&#39;)就是首先判断$_ci_models中是否存在Model_name这一model，如不存在则进行加载并保存到已加载model的数组当中，大大提高了性能和内存的利用率。$this-&gt;load便是Loader类被保存在全局唯一的实例Controller当中的load属性。 我们可以看一下Loader中model方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * Model Loader * * Loads and instantiates models. * * @param string $model Model name * @param string $name An optional object name to assign to * @param bool $db_conn An optional database connection configuration to initialize * @return object */public function model($model, $name = '', $db_conn = FALSE)&#123; if (empty($model)) &#123; return $this; &#125; elseif (is_array($model)) &#123; foreach ($model as $key =&gt; $value) &#123; is_int($key) ? $this-&gt;model($value, '', $db_conn) : $this-&gt;model($key, $value, $db_conn); &#125; return $this; &#125; $path = ''; // Is the model in a sub-folder? If so, parse out the filename and path. //获取判断model是否存在子路径中 if (($last_slash = strrpos($model, '/')) !== FALSE) &#123; // The path is in front of the last slash $path = substr($model, 0, ++$last_slash); // And the model name behind it $model = substr($model, $last_slash); &#125; if (empty($name)) &#123; $name = $model; &#125; if (in_array($name, $this-&gt;_ci_models, TRUE)) &#123; return $this; &#125; //单例模式 $CI =&amp; get_instance(); if (isset($CI-&gt;$name)) &#123; throw new RuntimeException('The model name you are loading is the name of a resource that is already being used: '.$name); &#125; //验证数据库连接 if ($db_conn !== FALSE &amp;&amp; ! class_exists('CI_DB', FALSE)) &#123; if ($db_conn === TRUE) &#123; $db_conn = ''; &#125; $this-&gt;database($db_conn, FALSE, TRUE); &#125; // Note: All of the code under this condition used to be just: // // load_class('Model', 'core'); // // However, load_class() instantiates classes // to cache them for later use and that prevents // MY_Model from being an abstract class and is // sub-optimal otherwise anyway. if ( ! class_exists('CI_Model', FALSE)) &#123; $app_path = APPPATH.'core'.DIRECTORY_SEPARATOR; if (file_exists($app_path.'Model.php')) &#123; require_once($app_path.'Model.php'); if ( ! class_exists('CI_Model', FALSE)) &#123; throw new RuntimeException($app_path.\"Model.php exists, but doesn't declare class CI_Model\"); &#125; &#125; elseif ( ! class_exists('CI_Model', FALSE)) &#123; require_once(BASEPATH.'core'.DIRECTORY_SEPARATOR.'Model.php'); &#125; $class = config_item('subclass_prefix').'Model'; if (file_exists($app_path.$class.'.php')) &#123; require_once($app_path.$class.'.php'); if ( ! class_exists($class, FALSE)) &#123; throw new RuntimeException($app_path.$class.\".php exists, but doesn't declare class \".$class); &#125; &#125; &#125; $model = ucfirst($model); if ( ! class_exists($model, FALSE)) &#123; foreach ($this-&gt;_ci_model_paths as $mod_path) &#123; if ( ! file_exists($mod_path.'models/'.$path.$model.'.php')) &#123; continue; &#125; require_once($mod_path.'models/'.$path.$model.'.php'); if ( ! class_exists($model, FALSE)) &#123; throw new RuntimeException($mod_path.\"models/\".$path.$model.\".php exists, but doesn't declare class \".$model); &#125; break; &#125; if ( ! class_exists($model, FALSE)) &#123; throw new RuntimeException('Unable to locate the model you have specified: '.$model); &#125; &#125; elseif ( ! is_subclass_of($model, 'CI_Model')) &#123; throw new RuntimeException(\"Class \".$model.\" already exists and doesn't extend CI_Model\"); &#125; $this-&gt;_ci_models[] = $name; $CI-&gt;$name = new $model(); return $this;&#125; Config.php在Config类当中，最核心的部分就是Config类的两个属性，用于保存已加载过的配置文件，在CI中这种保存变量的方法随处可见，这种设计方式的好处是显而易见的，大大提高了内存的利用率，降低重复加载带来的性能开销。我们来看一下这两个属性的定义以及他的注释123456789101112131415/** * List of all loaded config values * * @var array *///保存加载过的配置public $config = array();/** * List of all loaded config files * * @var array *///已加载的配置文件public $is_loaded = array(); 每一次加载新的配置的时候，Config类先对配置是否已加载然后再作出相应的操作，如果已加载则利用array_merge()函数来进行已加载配置数组的合并 Controller.php乍一看Controller类下没有写什么，就只有几十行代码，甚至大部分都是注释，但是Controller是整个CI的心脏，利用单例模式承担起整个应用的正常运行。所有实例化出来的类都统一放到Controller当中，是系统架构中的核心部分。全局通过get_instance()这一个方法来获取Controller单例实体，保证各个工具类的单例性。整个系统就是靠着Controller这一个枢纽运行起来的。 路由分发整个应用的路由分发是由Router类来进行分发的，联合URI类，进行url的分析，在此就不在赘述了。可以仔细阅读system/core下的Router.php和URI.php","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"CodeIgniter","slug":"CodeIgniter","permalink":"https://github.com/kong36088/kong36088.github.io/tags/CodeIgniter/"},{"name":"源码","slug":"源码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/源码/"}]},{"title":"我的百万知乎用户数据分析","date":"2016-12-01T13:19:25.000Z","path":"2016/12/01/我的百万知乎用户数据分析/","text":"这里是实时更新的知乎数据用户分析地址：百万知乎用户数据分析 用户数据分析源码在这里：ZhihuAnalyse 爬虫项目源码放在我的github上：ZhihuSpider爬虫代码分析可以看我的上一篇文章 喜欢的话帮忙点个star呗:-D 说个题外话：今天下午的时候爬虫还在继续跑，知乎用户个人首页还用的是旧版到了晚上7点发现爬虫居然爬不动了，十分疑惑，知乎个人中心竟然改版了，个人首页的url也改了，原来的爬虫用不了，（不知道是不是知乎为了防止我爬数据做的措施，哈哈哈）十分悲催，新版爬虫只能之后抽空出来再改一下了 效果图 简介主要利用SQL进行统计，并且利用redis进行数据缓存，ttl是6个小时，提高加载速度","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/kong36088/kong36088.github.io/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Python/"}]},{"title":"我用python爬了知乎一百万用户的数据","date":"2016-11-04T13:24:25.000Z","path":"2016/11/04/我用python爬了知乎一百万用户的数据/","text":"项目源码放在我的github上：ZhihuSpider喜欢的话帮忙点个star呗:-D 总体思路1.首先是模拟登陆知乎，利用保存登陆的cookie信息2.抓取知乎页面的html代码，留待下一步继续进行分析提取信息3.分析提取页面中用户的个性化url，放入redis（这里特别说明一下redis的思路用法，将提取到的用户的个性化url放入redis的一个名为already_get_user的hash table，表示已抓取的用户，对于已抓取过的用户判断是否存在于already_get_user以去除重复抓取，同时将个性化url放入user_queue的队列中，需要抓取新用户时pop队列获取新的用户）4.获取用户的关注列表和粉丝列表，继续插入到redis5.从redis的user_queue队列中获取新用户继续重复步骤3 效果图服务器带宽有限，并且知乎进行了ip封杀，所以这些数据也花了好几天的时间才爬下来喜欢的朋友帮忙点个star呗♪(＾∀＾●)ﾉ ZhihuSpider 模拟登陆知乎首先是登陆，登陆功能作为一个包封装了在login里面，方便整合调用 header部分，这里Connection最好设为close，不然可能会碰到max retireve exceed的错误原因在于普通的连接是keep-alive的但是却又没有关闭 12345678910111213# http请求的headerheaders = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\", \"Host\": \"www.zhihu.com\", \"Referer\": \"https://www.zhihu.com/\", \"Origin\": \"https://www.zhihu.com/\", \"Upgrade-Insecure-Requests\": \"1\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"Pragma\": \"no-cache\", \"Accept-Encoding\": \"gzip, deflate, br\", 'Connection': 'close'&#125; 123456789101112131415# 验证是否登陆def check_login(self): check_url = 'https://www.zhihu.com/settings/profile' try: login_check = self.__session.get(check_url, headers=self.headers, timeout=35) except Exception as err: print(traceback.print_exc()) print(err) print(\"验证登陆失败，请检查网络\") sys.exit() print(\"验证登陆的http status code为：\" + str(login_check.status_code)) if int(login_check.status_code) == 200: return True else: return False 进入首页查看http状态码来验证是否登陆，200为已经登陆，一般304就是被重定向所以就是没有登陆 123456789101112131415161718# 获取验证码def get_captcha(self): t = str(time.time() * 1000) captcha_url = 'http://www.zhihu.com/captcha.gif?r=' + t + \"&amp;type=login\" r = self.__session.get(captcha_url, headers=self.headers, timeout=35) with open('captcha.jpg', 'wb') as f: f.write(r.content) f.close() # 用pillow 的 Image 显示验证码 # 如果没有安装 pillow 到源代码所在的目录去找到验证码然后手动输入 '''try: im = Image.open('captcha.jpg') im.show() im.close() except:''' print(u'请到 %s 目录找到captcha.jpg 手动输入' % os.path.abspath('captcha.jpg')) captcha = input(\"请输入验证码\\n&gt;\") return captcha 获取验证码的方法。当登录次数太多有可能会要求输入验证码，这里实现这个功能 1234567891011121314151617# 获取xsrfdef get_xsrf(self): index_url = 'http://www.zhihu.com' # 获取登录时需要用到的_xsrf try: index_page = self.__session.get(index_url, headers=self.headers, timeout=35) except: print('获取知乎页面失败，请检查网络连接') sys.exit() html = index_page.text # 这里的_xsrf 返回的是一个list BS = BeautifulSoup(html, 'html.parser') xsrf_input = BS.find(attrs=&#123;'name': '_xsrf'&#125;) pattern = r'value=\\\"(.*?)\\\"' print(xsrf_input) self.__xsrf = re.findall(pattern, str(xsrf_input)) return self.__xsrf[0] 获取xsrf，为什么要获取xsrf呢，因为xsrf是一种防止跨站攻击的手段，具体介绍可以看这里csrf在获取到xsrf之后把xsrf存入cookie当中，并且在调用api的时候带上xsrf作为头部，不然的话知乎会返回403 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 进行模拟登陆def do_login(self): try: # 模拟登陆 if self.check_login(): print('您已经登录') return else: if self.config.get(\"zhihu_account\", \"username\") and self.config.get(\"zhihu_account\", \"password\"): self.username = self.config.get(\"zhihu_account\", \"username\") self.password = self.config.get(\"zhihu_account\", \"password\") else: self.username = input('请输入你的用户名\\n&gt; ') self.password = input(\"请输入你的密码\\n&gt; \") except Exception as err: print(traceback.print_exc()) print(err) sys.exit() if re.match(r\"^1\\d&#123;10&#125;$\", self.username): print(\"手机登陆\\n\") post_url = 'http://www.zhihu.com/login/phone_num' postdata = &#123; '_xsrf': self.get_xsrf(), 'password': self.password, 'remember_me': 'true', 'phone_num': self.username, &#125; else: print(\"邮箱登陆\\n\") post_url = 'http://www.zhihu.com/login/email' postdata = &#123; '_xsrf': self.get_xsrf(), 'password': self.password, 'remember_me': 'true', 'email': self.username, &#125; try: login_page = self.__session.post(post_url, postdata, headers=self.headers, timeout=35) login_text = json.loads(login_page.text.encode('latin-1').decode('unicode-escape')) print(postdata) print(login_text) # 需要输入验证码 r = 0为登陆成功代码 if login_text['r'] == 1: sys.exit() except: postdata['captcha'] = self.get_captcha() login_page = self.__session.post(post_url, postdata, headers=self.headers, timeout=35) print(json.loads(login_page.text.encode('latin-1').decode('unicode-escape'))) # 保存登陆cookie self.__session.cookies.save() 这个就是核心的登陆功能啦，非常关键的就是用到了requests库，非常方便的保存到session我们这里全局都是用单例模式，统一使用同一个requests.session对象进行访问功能，保持登录状态的一致性 最后主要调用登陆的代码为123456789101112131415# 创建login对象lo = login.login.Login(self.session)# 模拟登陆if lo.check_login(): print('您已经登录')else: if self.config.get(\"zhihu_account\", \"username\") and self.config.get(\"zhihu_account\", \"username\"): username = self.config.get(\"zhihu_account\", \"username\") password = self.config.get(\"zhihu_account\", \"password\") else: username = input('请输入你的用户名\\n&gt; ') password = input(\"请输入你的密码\\n&gt; \") lo.do_login(username, password) 知乎模拟登陆到此就完成啦 知乎用户抓取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def __init__(self, threadID=1, name=''): # 多线程 print(\"线程\" + str(threadID) + \"初始化\") threading.Thread.__init__(self) self.threadID = threadID self.name = name try: print(\"线程\" + str(threadID) + \"初始化成功\") except Exception as err: print(err) print(\"线程\" + str(threadID) + \"开启失败\") self.threadLock = threading.Lock() # 获取配置 self.config = configparser.ConfigParser() self.config.read(\"config.ini\") # 初始化session requests.adapters.DEFAULT_RETRIES = 5 self.session = requests.Session() self.session.cookies = cookielib.LWPCookieJar(filename='cookie') self.session.keep_alive = False try: self.session.cookies.load(ignore_discard=True) except: print('Cookie 未能加载') finally: pass # 创建login对象 lo = Login(self.session) lo.do_login() # 初始化redis连接 try: redis_host = self.config.get(\"redis\", \"host\") redis_port = self.config.get(\"redis\", \"port\") self.redis_con = redis.Redis(host=redis_host, port=redis_port, db=0) # 刷新redis库 # self.redis_con.flushdb() except: print(\"请安装redis或检查redis连接配置\") sys.exit() # 初始化数据库连接 try: db_host = self.config.get(\"db\", \"host\") db_port = int(self.config.get(\"db\", \"port\")) db_user = self.config.get(\"db\", \"user\") db_pass = self.config.get(\"db\", \"password\") db_db = self.config.get(\"db\", \"db\") db_charset = self.config.get(\"db\", \"charset\") self.db = pymysql.connect(host=db_host, port=db_port, user=db_user, passwd=db_pass, db=db_db, charset=db_charset) self.db_cursor = self.db.cursor() except: print(\"请检查数据库配置\") sys.exit() # 初始化系统设置 self.max_queue_len = int(self.config.get(\"sys\", \"max_queue_len\")) 这个是get_user.py的构造函数，主要功能就是初始化mysql连接、redis连接、验证登陆、生成全局的session对象、导入系统配置、开启多线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 获取首页htmldef get_index_page(self): index_url = 'https://www.zhihu.com/' try: index_html = self.session.get(index_url, headers=self.headers, timeout=35) except Exception as err: # 出现异常重试 print(\"获取页面失败，正在重试......\") print(err) traceback.print_exc() return None finally: pass return index_html.text# 获取单个用户详情页面def get_user_page(self, name_url): user_page_url = 'https://www.zhihu.com' + str(name_url) + '/about' try: index_html = self.session.get(user_page_url, headers=self.headers, timeout=35) except Exception as err: # 出现异常重试 print(\"失败name_url：\" + str(name_url) + \"获取页面失败，放弃该用户\") print(err) traceback.print_exc() return None finally: pass return index_html.text# 获取粉丝页面def get_follower_page(self, name_url): user_page_url = 'https://www.zhihu.com' + str(name_url) + '/followers' try: index_html = self.session.get(user_page_url, headers=self.headers, timeout=35) except Exception as err: # 出现异常重试 print(\"失败name_url：\" + str(name_url) + \"获取页面失败，放弃该用户\") print(err) traceback.print_exc() return None finally: pass return index_html.textdef get_following_page(self, name_url): user_page_url = 'https://www.zhihu.com' + str(name_url) + '/followers' try: index_html = self.session.get(user_page_url, headers=self.headers, timeout=35) except Exception as err: # 出现异常重试 print(\"失败name_url：\" + str(name_url) + \"获取页面失败，放弃该用户\") print(err) traceback.print_exc() return None finally: pass return index_html.text# 获取首页上的用户列表，存入redisdef get_index_page_user(self): index_html = self.get_index_page() if not index_html: return BS = BeautifulSoup(index_html, \"html.parser\") self.get_xsrf(index_html) user_a = BS.find_all(\"a\", class_=\"author-link\") # 获取用户的a标签 for a in user_a: if a: self.add_wait_user(a.get('href')) else: continue 这一部分的代码就是用于抓取各个页面的html代码 12345678910111213141516171819# 加入带抓取用户队列，先用redis判断是否已被抓取过def add_wait_user(self, name_url): # 判断是否已抓取 self.threadLock.acquire() if not self.redis_con.hexists('already_get_user', name_url): self.counter += 1 print(name_url + \" 加入队列\") self.redis_con.hset('already_get_user', name_url, 1) self.redis_con.lpush('user_queue', name_url) print(\"添加用户 \" + name_url + \"到队列\") self.threadLock.release()# 获取页面出错移出redisdef del_already_user(self, name_url): self.threadLock.acquire() if not self.redis_con.hexists('already_get_user', name_url): self.counter -= 1 self.redis_con.hdel('already_get_user', name_url) self.threadLock.release() 用户加入redis的操作，在数据库插入出错时我们调用del_already_user删除插入出错的用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# 分析粉丝页面获取用户的所有粉丝用户# @param follower_page get_follower_page()中获取到的页面，这里获取用户hash_id请求粉丝接口获取粉丝信息def get_all_follower(self, name_url): follower_page = self.get_follower_page(name_url) # 判断是否获取到页面 if not follower_page: return BS = BeautifulSoup(follower_page, 'html.parser') # 获取关注者数量 follower_num = int(BS.find('span', text='关注者').find_parent().find('strong').get_text()) # 获取用户的hash_id hash_id = \\ json.loads(BS.select(\"#zh-profile-follows-list\")[0].select(\".zh-general-list\")[0].get('data-init'))[ 'params'][ 'hash_id'] # 获取关注者列表 self.get_xsrf(follower_page) # 获取xsrf post_url = 'https://www.zhihu.com/node/ProfileFollowersListV2' # 开始获取所有的关注者 math.ceil(follower_num/20)*20 for i in range(0, math.ceil(follower_num / 20) * 20, 20): post_data = &#123; 'method': 'next', 'params': json.dumps(&#123;\"offset\": i, \"order_by\": \"created\", \"hash_id\": hash_id&#125;) &#125; try: j = self.session.post(post_url, params=post_data, headers=self.headers, timeout=35).text.encode( 'latin-1').decode( 'unicode-escape') pattern = re.compile(r\"class=\\\"zm-item-link-avatar\\\"[^\\\"]*\\\"([^\\\"]*)\", re.DOTALL) j = pattern.findall(j) for user in j: user = user.replace('\\\\', '') self.add_wait_user(user) # 保存到redis except Exception as err: print(\"获取正在关注失败\") print(err) traceback.print_exc() pass# 获取正在关注列表def get_all_following(self, name_url): following_page = self.get_following_page(name_url) # 判断是否获取到页面 if not following_page: return BS = BeautifulSoup(following_page, 'html.parser') # 获取关注者数量 following_num = int(BS.find('span', text='关注了').find_parent().find('strong').get_text()) # 获取用户的hash_id hash_id = \\ json.loads(BS.select(\"#zh-profile-follows-list\")[0].select(\".zh-general-list\")[0].get('data-init'))[ 'params'][ 'hash_id'] # 获取关注者列表 self.get_xsrf(following_page) # 获取xsrf post_url = 'https://www.zhihu.com/node/ProfileFolloweesListV2' # 开始获取所有的关注者 math.ceil(follower_num/20)*20 for i in range(0, math.ceil(following_num / 20) * 20, 20): post_data = &#123; 'method': 'next', 'params': json.dumps(&#123;\"offset\": i, \"order_by\": \"created\", \"hash_id\": hash_id&#125;) &#125; try: j = self.session.post(post_url, params=post_data, headers=self.headers, timeout=35).text.encode( 'latin-1').decode( 'unicode-escape') pattern = re.compile(r\"class=\\\"zm-item-link-avatar\\\"[^\\\"]*\\\"([^\\\"]*)\", re.DOTALL) j = pattern.findall(j) for user in j: user = user.replace('\\\\', '') self.add_wait_user(user) # 保存到redis except Exception as err: print(\"获取正在关注失败\") print(err) traceback.print_exc() pass 调用知乎的API，获取所有的关注用户列表和粉丝用户列表，递归获取用户这里需要注意的是头部要记得带上xsrf不然会抛出403 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# 分析about页面，获取用户详细资料def get_user_info(self, name_url): about_page = self.get_user_page(name_url) # 判断是否获取到页面 if not about_page: print(\"获取用户详情页面失败，跳过，name_url：\" + name_url) return self.get_xsrf(about_page) BS = BeautifulSoup(about_page, 'html.parser') # 获取页面的具体数据 try: nickname = BS.find(\"a\", class_=\"name\").get_text() if BS.find(\"a\", class_=\"name\") else '' user_type = name_url[1:name_url.index('/', 1)] self_domain = name_url[name_url.index('/', 1) + 1:] gender = 2 if BS.find(\"i\", class_=\"icon icon-profile-female\") else (1 if BS.find(\"i\", class_=\"icon icon-profile-male\") else 3) follower_num = int(BS.find('span', text='关注者').find_parent().find('strong').get_text()) following_num = int(BS.find('span', text='关注了').find_parent().find('strong').get_text()) agree_num = int(re.findall(r'&lt;strong&gt;(.*)&lt;/strong&gt;.*赞同', about_page)[0]) appreciate_num = int(re.findall(r'&lt;strong&gt;(.*)&lt;/strong&gt;.*感谢', about_page)[0]) star_num = int(re.findall(r'&lt;strong&gt;(.*)&lt;/strong&gt;.*收藏', about_page)[0]) share_num = int(re.findall(r'&lt;strong&gt;(.*)&lt;/strong&gt;.*分享', about_page)[0]) browse_num = int(BS.find_all(\"span\", class_=\"zg-gray-normal\")[2].find(\"strong\").get_text()) trade = BS.find(\"span\", class_=\"business item\").get('title') if BS.find(\"span\", class_=\"business item\") else '' company = BS.find(\"span\", class_=\"employment item\").get('title') if BS.find(\"span\", class_=\"employment item\") else '' school = BS.find(\"span\", class_=\"education item\").get('title') if BS.find(\"span\", class_=\"education item\") else '' major = BS.find(\"span\", class_=\"education-extra item\").get('title') if BS.find(\"span\", class_=\"education-extra item\") else '' job = BS.find(\"span\", class_=\"position item\").get_text() if BS.find(\"span\", class_=\"position item\") else '' location = BS.find(\"span\", class_=\"location item\").get('title') if BS.find(\"span\", class_=\"location item\") else '' description = BS.find(\"div\", class_=\"bio ellipsis\").get('title') if BS.find(\"div\", class_=\"bio ellipsis\") else '' ask_num = int(BS.find_all(\"a\", class_='item')[1].find(\"span\").get_text()) if \\ BS.find_all(\"a\", class_='item')[ 1] else int(0) answer_num = int(BS.find_all(\"a\", class_='item')[2].find(\"span\").get_text()) if \\ BS.find_all(\"a\", class_='item')[ 2] else int(0) article_num = int(BS.find_all(\"a\", class_='item')[3].find(\"span\").get_text()) if \\ BS.find_all(\"a\", class_='item')[3] else int(0) collect_num = int(BS.find_all(\"a\", class_='item')[4].find(\"span\").get_text()) if \\ BS.find_all(\"a\", class_='item')[4] else int(0) public_edit_num = int(BS.find_all(\"a\", class_='item')[5].find(\"span\").get_text()) if \\ BS.find_all(\"a\", class_='item')[5] else int(0) replace_data = \\ (pymysql.escape_string(name_url), nickname, self_domain, user_type, gender, follower_num, following_num, agree_num, appreciate_num, star_num, share_num, browse_num, trade, company, school, major, job, location, pymysql.escape_string(description), ask_num, answer_num, article_num, collect_num, public_edit_num) replace_sql = '''REPLACE INTO user(url,nickname,self_domain,user_type, gender, follower,following,agree_num,appreciate_num,star_num,share_num,browse_num, trade,company,school,major,job,location,description, ask_num,answer_num,article_num,collect_num,public_edit_num) VALUES(%s,%s,%s,%s, %s,%s,%s,%s,%s,%s,%s,%s, %s,%s,%s,%s,%s,%s,%s, %s,%s,%s,%s,%s)''' try: print(\"获取到数据：\") print(replace_data) self.db_cursor.execute(replace_sql, replace_data) self.db.commit() except Exception as err: print(\"插入数据库出错\") print(\"获取到数据：\") print(replace_data) print(\"插入语句：\" + self.db_cursor._last_executed) self.db.rollback() print(err) traceback.print_exc() except Exception as err: print(\"获取数据出错，跳过用户\") self.redis_con.hdel(\"already_get_user\", name_url) self.del_already_user(name_url) print(err) traceback.print_exc() pass 最后，到用户的about页面，分析页面元素，利用正则或者beatifulsoup分析抓取页面的数据这里我们SQL语句用REPLACE INTO而不用INSERT INTO，这样可以很好的防止数据重复问题 123456789101112131415161718# 开始抓取用户，程序总入口def entrance(self): while 1: if int(self.redis_con.llen(\"user_queue\")) &lt; 1: self.get_index_page_user() else: # 出队列获取用户name_url redis取出的是byte，要decode成utf-8 name_url = str(self.redis_con.rpop(\"user_queue\").decode('utf-8')) print(\"正在处理name_url：\" + name_url) self.get_user_info(name_url) if int(self.redis_con.llen(\"user_queue\")) &lt;= int(self.max_queue_len): self.get_all_follower(name_url) self.get_all_following(name_url) self.session.cookies.save()def run(self): print(self.name + \" is running\") self.entrance() 最后，入口 12345678910111213if __name__ == '__main__': login = GetUser(999, \"登陆线程\") threads = [] for i in range(0, 4): m = GetUser(i, \"thread\" + str(i)) threads.append(m) for i in range(0, 4): threads[i].start() for i in range(0, 4): threads[i].join() 这里就是多线程的开启，需要开启多少个线程就把4换成多少就可以了 感谢阅读^_^!","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/kong36088/kong36088.github.io/tags/爬虫/"},{"name":"python","slug":"python","permalink":"https://github.com/kong36088/kong36088.github.io/tags/python/"}]},{"title":"PHP内核中的HashTable","date":"2016-11-01T07:24:25.000Z","path":"2016/11/01/PHP内核中的HashTable/","text":"PHP内核中的HashTable原理简易的结构12345678910111213typedef struct _Bucket&#123; char *key; void *value; struct _Bucket *next;&#125; Bucket; typedef struct _HashTable&#123; int size; int elem_num; Bucket** buckets;&#125; HashTable; 这个是一个简化过的哈希表结构Bucket是一个链表，而_HashTable用于存储hash值并指向真正的数据储存单位 解决冲突算法DJBX33A而链表是为了解决冲突用的，冲突解决采用DJBX33A算法，算法的内容如下1234567891011121314151617181920212223242526inline unsigned time33(char const*str, int len) &#123; unsigned long hash = 5381; /* variant with the hash unrolled eight times */ for (; len &gt;= 8; len -= 8) &#123; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; hash = ((hash &lt;&lt; 5) + hash) + *str++; &#125; switch (len) &#123; case 7: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 6: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 5: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 4: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 3: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 2: hash = ((hash &lt;&lt; 5) + hash) + *str++; /* fallthrough... */ case 1: hash = ((hash &lt;&lt; 5) + hash) + *str++; break; case 0: break; &#125; return hash; &#125; HashTable的初始化初始化，申请空间并且设置初始化值123456789101112int hash_init(HashTable *ht)&#123; ht-&gt;size = HASH_TABLE_INIT_SIZE; ht-&gt;elem_num = 0; ht-&gt;buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *)); if(ht-&gt;buckets == NULL) return FAILED; LOG_MSG(\"[init]\\tsize: %i\\n\", ht-&gt;size); return SUCCESS;&#125; HashTable的插入插入函数，插入时验证key是否存在，存在更新value值，不存在并取发生冲突则创建新节点并插入到原有链表的头部123456789101112131415161718192021222324252627282930313233343536373839404142434445int hash_insert(HashTable *ht, char *key, void *value)&#123; // check if we need to resize the hashtable resize_hash_table_if_needed(ht); int index = HASH_INDEX(ht, key); Bucket *org_bucket = ht-&gt;buckets[index]; Bucket *tmp_bucket = org_bucket; // check if the key exits already while(tmp_bucket) &#123; if(strcmp(key, tmp_bucket-&gt;key) == 0) &#123; LOG_MSG(\"[update]\\tkey: %s\\n\", key); tmp_bucket-&gt;value = value; return SUCCESS; &#125; tmp_bucket = tmp_bucket-&gt;next; &#125; Bucket *bucket = (Bucket *)malloc(sizeof(Bucket)); bucket-&gt;key = key; bucket-&gt;value = value; bucket-&gt;next = NULL; ht-&gt;elem_num += 1; if(org_bucket != NULL) &#123; LOG_MSG(\"[collision]\\tindex:%d key:%s\\n\", index, key); bucket-&gt;next = org_bucket; &#125; ht-&gt;buckets[index]= bucket; LOG_MSG(\"[insert]\\tindex:%d key:%s\\tht(num:%d)\\n\", index, key, ht-&gt;elem_num); return SUCCESS;&#125; HashTable的扩容当Hash表容量满了的时候，Hash表的性能会下降，这时候需要对Hash表进行扩容先把原来Hash表容量变成两倍，然后对其进行重新插入操作，时间复杂度为O(n)1234567891011121314151617181920212223242526272829303132333435363738394041424344static void resize_hash_table_if_needed(HashTable *ht)&#123; if(ht-&gt;size - ht-&gt;elem_num &lt; 1) &#123; hash_resize(ht); &#125;&#125; static int hash_resize(HashTable *ht)&#123; // double the size int org_size = ht-&gt;size; ht-&gt;size = ht-&gt;size * 2; ht-&gt;elem_num = 0; LOG_MSG(\"[resize]\\torg size: %i\\tnew size: %i\\n\", org_size, ht-&gt;size); Bucket **buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *)); Bucket **org_buckets = ht-&gt;buckets; ht-&gt;buckets = buckets; int i = 0; for(i=0; i &lt; org_size; ++i) &#123; Bucket *cur = org_buckets[i]; Bucket *tmp; while(cur) &#123; // rehash: insert again hash_insert(ht, cur-&gt;key, cur-&gt;value); // free the org bucket, but not the element tmp = cur; cur = cur-&gt;next; free(tmp); &#125; &#125; free(org_buckets); LOG_MSG(\"[resize] done\\n\"); return SUCCESS;&#125; HashTable的查找元素的查找和插入采取相同的策略，都是先获得hash值，然后取得bucket链表，随后比较键名进行查找12345678910111213141516171819202122232425int hash_lookup(HashTable *ht, char *key, void **result)&#123; int index = HASH_INDEX(ht, key); Bucket *bucket = ht-&gt;buckets[index]; if(bucket == NULL) goto failed; while(bucket) &#123; if(strcmp(bucket-&gt;key, key) == 0) &#123; LOG_MSG(\"[lookup]\\t found %s\\tindex:%i value: %p\\n\", key, index, bucket-&gt;value); *result = bucket-&gt;value; return SUCCESS; &#125; bucket = bucket-&gt;next; &#125; failed: LOG_MSG(\"[lookup]\\t key:%s\\tfailed\\t\\n\", key); return FAILED;&#125; 参考哈希表(HashTable)","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"内核","slug":"内核","permalink":"https://github.com/kong36088/kong36088.github.io/tags/内核/"}]},{"title":"PHP内核哈希表实现","date":"2016-11-01T06:24:25.000Z","path":"2016/11/01/PHP内核哈希表实现/","text":"哈希表结构先看看哈希表的结构1234567891011121314151617typedef struct _hashtable &#123; uint nTableSize; // hash Bucket的大小，最小为8，以2x增长。 uint nTableMask; // nTableSize-1 ， 索引取值的优化 uint nNumOfElements; // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 ulong nNextFreeElement; // 下一个数字索引的位置，当数组成员没有指定键值时则采用该数字索引 Bucket *pInternalPointer; // 当前遍历的指针（foreach比for快的原因之一） Bucket *pListHead; // 存储数组头元素指针 Bucket *pListTail; // 存储数组尾元素指针 Bucket **arBuckets; // 存储hash数组 dtor_func_t pDestructor; // 在删除元素时执行的回调函数，用于资源的释放 zend_bool persistent; //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。 unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归） zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; PHP的GC（内存回收）机制就是根据nNumOfElements大小来进行判断，当采取unset()时，该字段的值减一，在字段值为0时进行内存回收首先初始化HashTable的大小为8 初始化123456789101112131415161718192021222324252627282930313233ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; //... if (nSize &gt;= 0x80000000) &#123; /* prevent overflow */ ht-&gt;nTableSize = 0x80000000; &#125; else &#123; while ((1U &lt;&lt; i) &lt; nSize) &#123; i++; &#125; ht-&gt;nTableSize = 1 &lt;&lt; i; &#125; // ... ht-&gt;nTableMask = ht-&gt;nTableSize - 1; /* Uses ecalloc() so that Bucket* == NULL */ if (persistent) &#123; tmp = (Bucket **) calloc(ht-&gt;nTableSize, sizeof(Bucket *)); if (!tmp) &#123; return FAILURE; &#125; ht-&gt;arBuckets = tmp; &#125; else &#123; tmp = (Bucket **) ecalloc_rel(ht-&gt;nTableSize, sizeof(Bucket *)); if (tmp) &#123; ht-&gt;arBuckets = tmp; &#125; &#125; return SUCCESS;&#125; 例如如果设置初始大小为10，则上面的算法将会将大小调整为16。也就是始终将大小调整为接近初始大小的2的整数次方。为什么会做这样的调整呢？我们先看看HashTable将哈希值映射到槽位的方法，上一小节我们使用了取模的方式来将哈希值映射到槽位，例如大小为8的哈希表，哈希值为100， 则映射的槽位索引为: 100 % 8 = 4，由于索引通常从0开始，所以槽位的索引值为3，在PHP中使用如下的方式计算索引： h = zend_inline_hash_func(arKey, nKeyLength);nIndex = h &amp; ht-&gt;nTableMask;从上面的_zend_hash_init()函数中可知，ht-&gt;nTableMask的大小为ht-&gt;nTableSize -1。这里使用&amp;操作而不是使用取模，这是因为是相对来说取模操作的消耗和按位与的操作大很多。 Bucket结构123456789101112typedef struct bucket &#123; ulong h; // 对char *key进行hash后的值，或者是用户指定的数字索引值 uint nKeyLength; // hash关键字的长度，如果数组索引为数字，此值为0 void *pData; // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr void *pDataPtr; //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值 struct bucket *pListNext; // 整个hash表的下一元素 struct bucket *pListLast; // 整个哈希表该元素的上一个元素 struct bucket *pNext; // 存放在同一个hash Bucket内的下一个元素 struct bucket *pLast; // 同一个哈希bucket的上一个元素 // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体 char arKey[1]; &#125; Bucket; 如上面各字段的注释。h字段保存哈希表key哈希后的值。这里保存的哈希值而不是在哈希表中的索引值，这是因为索引值和哈希表的容量有直接关系，如果哈希表扩容了，那么这些索引还得重新进行哈希在进行索引映射，这也是一种优化手段。在PHP中可以使用字符串或者数字作为数组的索引。数字索引直接就可以作为哈希表的索引，数字也无需进行哈希处理。h字段后面的nKeyLength字段是作为key长度的标示，如果索引是数字的话，则nKeyLength为0。在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。所以在PHP中例如’10’，’11’这类的字符索引和数字索引10， 11没有区别。 HashTable接口的调用这里介绍的是插入操作，对于数组的添加操作，其最终调用的都是该接口所以这里主要针对插入接口进行介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ZEND_API int _zend_hash_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)&#123; //...省略变量初始化和nKeyLength &lt;=0 的异常处理 h = zend_inline_hash_func(arKey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets[nIndex]; while (p != NULL) &#123; if ((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength)) &#123; if (!memcmp(p-&gt;arKey, arKey, nKeyLength)) &#123; // 更新操作 if (flag &amp; HASH_ADD) &#123; return FAILURE; &#125; HANDLE_BLOCK_INTERRUPTIONS(); //..省略debug输出 if (ht-&gt;pDestructor) &#123; ht-&gt;pDestructor(p-&gt;pData); &#125; UPDATE_DATA(ht, p, pData, nDataSize); if (pDest) &#123; *pDest = p-&gt;pData; &#125; HANDLE_UNBLOCK_INTERRUPTIONS(); return SUCCESS; &#125; &#125; p = p-&gt;pNext; &#125; p = (Bucket *) pemalloc(sizeof(Bucket) - 1 + nKeyLength, ht-&gt;persistent); if (!p) &#123; return FAILURE; &#125; memcpy(p-&gt;arKey, arKey, nKeyLength); p-&gt;nKeyLength = nKeyLength; INIT_DATA(ht, p, pData, nDataSize); p-&gt;h = h; CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex]); //Bucket双向链表操作 if (pDest) &#123; *pDest = p-&gt;pData; &#125; HANDLE_BLOCK_INTERRUPTIONS(); CONNECT_TO_GLOBAL_DLLIST(p, ht); // 将新的Bucket元素添加到数组的链接表的最后面 ht-&gt;arBuckets[nIndex] = p; HANDLE_UNBLOCK_INTERRUPTIONS(); ht-&gt;nNumOfElements++; ZEND_HASH_IF_FULL_DO_RESIZE(ht); /* 如果此时数组的容量满了，则对其进行扩容。*/ return SUCCESS;&#125; 生成hash值，通过与nTableMask执行与操作，获取在arBuckets数组中的Bucket。 如果Bucket中已经存在元素，则遍历整个Bucket，查找是否存在相同的key值元素，如果有并且是update调用，则执行update数据操作。 创建新的Bucket元素，初始化数据，并将新元素添加到当前hash值对应的Bucket链表的最前面（CONNECT_TO_BUCKET_DLLIST）。 将新的Bucket元素添加到数组的链接表的最后面（CONNECT_TO_GLOBAL_DLLIST）。 将元素个数加1，如果此时数组的容量满了，则对其进行扩容。这里的判断是依据nNumOfElements和nTableSize的大小。如果nNumOfElements &gt; nTableSize则会调用zend_hash_do_resize以2X的方式扩容（nTableSize &lt;&lt; 1）。 更多HashTable的具体接口操作可以查看上一节内容 参考资料PHP的哈希表实现","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"内核","slug":"内核","permalink":"https://github.com/kong36088/kong36088.github.io/tags/内核/"}]},{"title":"关于python爬虫的深坑：requests抛出异常Max retries exceeded with url","date":"2016-10-29T06:24:25.000Z","path":"2016/10/29/关于python爬虫的深坑：requests抛出异常Max retries exceeded with url/","text":"1requests.packages.urllib3.exceptions.MaxRetryError: HTTPSConnectionPool(host='www.zhihu.com', port=443): Max retries exceeded with url: /people/claire-98-77/about (Caused by NewConnectionError('&lt;requests.packages.urllib3.connection.VerifiedHTTPSConnection object at 0x7f2ee28c6588&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution',)) 在调试的过程中，不断抛出该错误，在google查了很久，总结如下：http的连接数超过最大限制，默认的情况下连接是Keep-alive的，所以这就导致了服务器保持了太多连接而不能再新建连接解决方案： 解决一：error trace is misleading it should be something like “No connection could be made because the target machine actively refused it”. 因为目标地址拒绝连接而产生的异常1234try: page1 = requests.get(ap)except requests.exceptions.ConnectionError: r.status_code = \"Connection refused\" 解决二： 产生的连接数过多而导致Max retries exceeded在header中不使用持久连接&#39;Connection&#39;: &#39;close&#39;或requests.adapters.DEFAULT_RETRIES = 5 解决三：其实这个异常也有另一种可能性：在使用requests库的时候，由于请求失败而由程序本身发送重连连接的速度过快导致产生该错误。减缓出错时重连的速度可能可以有效地解决这一个问题。 具体可以参照一下这个例子： 12345678910111213import timepage = ''while page == '': try: page = requests.get(url) except: print(\"Connection refused by the server..\") print(\"Let me sleep for 5 seconds\") print(\"ZZzzzz...\") time.sleep(5) print(\"Was a nice sleep, now let me continue...\") continue 闲话~ 在python3中redis取出的值是以b’…….’的形式可以像redis_con.rpop(&quot;user_queue&quot;).decode(&#39;utf-8&#39;)这样转换一下","tags":[{"name":"Python","slug":"Python","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Python/"}]},{"title":"开源项目：删除微博工具","date":"2016-09-17T06:24:25.000Z","path":"2016/09/17/开源项目：删除微博工具/","text":"介绍利用该工具可以实现删除个人所有微博功能，不用受到第三方调用API次数限制不能保证工具长期有效 GITHUB地址: https://github.com/kong36088/DeleteWeiboTool 使用方法配置好代码根目录下的Config/config.php中要求必填的项目$config[&#39;sina_cookie&#39;]：登陆好后，打开F12开发者工具获取REQUEST中的cookie值填入$config[&#39;self_page_url&#39;]：打开开发者工具设置模拟IPHONE6访问页面m.weibo.cn,点击查看我的所有微博，复制页面URL 然后开始运行 cd /xxx/xxx/DelWeibo php Delete.php 设置教程如下 总结1.尽量模拟好所有的header，包括host，referer等 2.在个人服务器上经常会出现504 GATEWAY错误，具体设置是加大nginx中的buffersize以及PHP max_childrend的大小 3.关于PHP CURL中post数据需要注意的地方：如果$data是字符串，则Content-Type是application/x-www-form-urlencoded。 HTML Form URL Encoded: application/x-www-form-urlencoded Form item: “uname” = “nickname” Key: uname Value: nickname 如果$data是k=&gt;v的数组，则Content-Type是multipart/form-data, 4.模拟登陆可以采用手动登陆后直接获取到浏览器的cookie每次登陆采用该cookie，curl_setopt($ch, CURLOPT_COOKIE, $this-&gt;cookie) 5.出现乱码等情况时可以加入gzip解析，curl_setopt($ch, CURLOPT_ENCODING, &#39;gzip&#39;)","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"开源","slug":"开源","permalink":"https://github.com/kong36088/kong36088.github.io/tags/开源/"}]},{"title":"一个很好的epoll解析","date":"2016-08-28T15:24:25.000Z","path":"2016/08/28/一个很好的epoll解析/","text":"epoll介绍转自知乎 作者：蓝形参，Geek 伪技术宅 首先我们来定义流的概念，一个流可以是文件，socket，pipe等等可以进行I/O操作的内核对象。 不管是文件，还是套接字，还是管道，我们都可以把他们看作流。 之后我们来讨论I/O的操作，通过read，我们可以从流中读入数据；通过write，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读如数据，但是服务器还没有把数据传回来），这时候该怎么办？ 阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。 非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？” 很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。 大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了。 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。 假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满” 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。 然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。 于是再来考虑非阻塞忙轮询的I/O方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）： 123456while true &#123; for i in stream[]; &#123; if i has data read until unavailable &#125;&#125; 我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。 为了避免CPU空转，可以引进了一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。代码长这样: 1234567while true &#123; select(streams[]) for i in streams[] &#123; if i has data read until unavailable &#125;&#125; 于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。 但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，没一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了 epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)） 在讨论epoll的实现细节之前，先把epoll的相关操作列出： epoll_create 创建一个epoll对象，一般epollfd = epoll_create() epoll_ctl （epoll_add/epoll_del的合体），往epoll对象中增加/删除某一个流的某一个事件 比如 epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN);//注册缓冲区非空事件，即有数据流入 epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);//注册缓冲区非满事件，即流可以被写入 epoll_wait(epollfd,...)等待直到注册的事件发生 （注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，write/read会返回-1，并设置errno=EAGAIN。而epoll只关心缓冲区非满和缓冲区非空事件）。 一个epoll模式的代码大概的样子是： 123456while true &#123; active_stream[] = epoll_wait(epollfd) for i in active_stream[] &#123; read or write till &#125;&#125; 限于篇幅，我只说这么多，以揭示原理性的东西，至于epoll的使用细节，请参考man和google，实现细节，请参阅linux kernel source。 个人总结看完以上对于epoll的介绍，对于linux中的IO模型有了一定的认知相比于传统的select/poll模型，epoll利用了事件通知的形式，减少了接受IO信号后对所有socket进行轮询的开销，大大提升效率 epoll是linux所特有，而select是POSIX所规定，一般操作系统均有实现。 关于linux中的几种IO模型介绍： select：查找select本质是通过设置或检查存放fd标志位的数据结构来进行下一步处理。缺点是： 1、单个进程可监视的fd数量被限制，即能监听端口的大小有限。 一般来说和系统内存有关，具体数目可以cat /proc/sys/fs/file-max察看。32位默认是1024个，64位默认为2048个 2、对socket进行扫描时是线性扫描，即采用轮询方法，效率低。 当套接字比较多的时候，每次select()都要遍历FD_SETSIZE个socket来完成调度，不管socket是否活跃都遍历一遍。会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，就避免了轮询，这正是epoll与kqueue做的 3、需要维护一个用来存放大量fd的数据结构，会使得用户空间和内核空间在传递该结构时复制开销大 poll：poll本质和select相同，将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或主动超时，被唤醒后又要再次遍历fd 它没有最大连接数的限制，原因是它是基于链表来存储的，但缺点是： 1、大量的fd的数组被整体复制到用户态和内核空间之间，不管有无意义。 2、poll还有一个特点“水平触发”，如果报告了fd后，没有被处理，那么下次poll时再次报告该ffd。 epoll：epoll支持水平触发和边缘触发，最大特点在于边缘触发，只告诉哪些fd刚刚变为就绪态，并且只通知一次。还有一特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一量该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。 epoll的优点： 1、没有最大并发连接的限制 2、效率提升，只有活跃可用的FD才会调用callback函数 3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递。 select、poll、epoll区别总结： 1、支持一个进程打开连接数 select：32位机器1024个，64位2048个 poll：无限制，原因基于链表存储 epoll：有上限，但很大，2G内存20W左右 2、IO效率 select：IO效率低 poll：IO效率低 epoll：只有活跃的socket才调用callback，IO效率高。 3、消息传递方式 select：内核需要将消息传递到用户空间，都需要内核拷贝动作 poll：同上 epoll：通过内核与用户空间共享一块内存来实现。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"Swoole中的几个进程：Reactor、Worker、Task","date":"2016-08-28T06:24:25.000Z","path":"2016/08/28/Swoole中的几个进程：Reactor、Worker、Task/","text":"Swoole的进程Swoole中有几种进程，分别是：Manager、Reactor线程、Worker、TaskWoker根据官方文档的介绍，分别介绍 Manager进程swoole中worker/task进程都是由Manager进程Fork并管理的。子进程结束运行时，manager进程负责回收此子进程，避免成为僵尸进程。并创建新的子进程服务器关闭时，manager进程将发送信号给所有子进程，通知子进程关闭服务服务器reload时，manager进程会逐个关闭/重启子进程 Reactor线程负责维护客户端机器的TCP连接、处理网络IO、收发数据完全是异步非阻塞的模式全部为C代码，除Start/Shudown事件回调外，不执行任何PHP代码将TCP客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包Reactor以多线程的方式运行 Worker进程接受由Reactor线程投递的请求数据包，并执行PHP回调函数处理数据生成响应数据并发给Reactor线程，由Reactor线程发送给TCP客户端可以是异步非阻塞模式，也可以是同步阻塞模式Worker以多进程的方式运行当一个Worker进程被成功创建后，会调用onWorkerStart回调，随后进入事件循环等待数据。当通过回调函数接收到数据后，开始处理数据。如果处理数据过程中出现严重错误导致进程退出，或者Worker进程处理的总请求数达到指定上限，则Worker进程调用onWorkerStop回调并结束进程。 Task进程接受由Worker进程通过swoole_server-&gt;task/taskwait方法投递的任务处理任务，并将结果数据返回给Worker进程完全是同步阻塞模式Task以多进程的方式运行 Task、Worker、Reator的关系可以理解为reactor就是nginx，worker就是php-fpm。reactor线程异步并行地处理网络请求，然后再转发给worker进程中去处理。reactor和worker间通过IPC方式通信。swoole的reactor，worker，task_worker之间可以紧密的结合起来，提供更高级的使用方式。 一个更通俗的比喻，假设Server就是一个工厂，那reactor就是销售，帮你接项目订单。而worker就是工人，当销售接到订单后，worker去工作生产出客户要的东西。而task_worker可以理解为行政人员，可以帮助worker干些杂事，让worker专心工作。 底层会为Worker进程、Task进程分配一个唯一的ID不同的task/worker进程之间可以通过sendMessage接口进行通信 生命周期程序全局期在swoole_server-&gt;start之前就创建好的对象，我们称之为程序全局生命周期。这些变量在程序启动后就会一直存在，直到整个程序结束运行才会销毁。 有一些服务器程序可能会连续运行数月甚至数年才会关闭/重启，那么程序全局期的对象在这段时间持续驻留在内存中的。 由于swoole是多进程的，所以程序全局对象在代码中仅是可读的程序全局对象所在用的内存是共享的，不会额外占用内存 进程全局期swoole拥有进程生命周期控制的机制，一个worker子进程处理的请求数超过max_request配置后，就会自动销毁。worker进程启动后创建的对象（onWorkerStart中创建的对象），在这个子进程存活周期之内，是常驻内存的。onConnect/onReceive/onClose 中都可以去访问它。 进程全局对象所在用的内存是在当前子进程内存堆的，并非共享内存。对此对象的修改仅在当前worker进程中有效进程期include/require的文件，在reload后就会重新加载 会话期会话期是在onConnect后创建，或者在第一次onReceive时创建，onClose时销毁。一个客户端连接进入后，创建的对象会常驻内存，直到此客户端离开才会销毁。 在LAMP中，一个客户端浏览器访问多次网站，就可以理解为会话期。但传统PHP程序，并不能感知到。只有单次访问时使用session_start，访问$_SESSION全局变量才能得到会话期的一些信息。 swoole中会话期的对象直接是常驻内存，不需要session_start之类操作。可以直接访问对象，并执行对象的方法。 请求期请求期就是指一个完整的请求发来，也就是onReceive收到请求开始处理，直到返回结果发送response。这个周期所创建的对象，会在请求完成后销毁。 swoole中请求期对象与普通PHP程序中的对象就是一样的。请求到来时创建，请求结束后销毁。 参考swoole_server中对象的4层生命周期","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"Swoole","slug":"Swoole","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Swoole/"}]},{"title":"linux——awk、sed、grep（鸟哥的私房菜）","date":"2016-08-19T06:24:25.000Z","path":"2016/08/19/linux——awk、sed、grep（鸟哥的私房菜）/","text":"grep[dmtsai@study ~]$ grep [-A] [-B] [--color=auto] '搜尋字串' filename 選項與參數： -A ：後面可加數字，為 after 的意思，除了列出該行外，後續的 n 行也列出來； -B ：後面可加數字，為 befer 的意思，除了列出該行外，前面的 n 行也列出來； --color=auto 可將正確的那個擷取資料列出顏色 範例一：用 dmesg 列出核心訊息，再以 grep 找出內含 qxl 那行 [dmtsai@study ~]$ dmesg | grep 'qxl' [ 0.522749] [drm] qxl: 16M of VRAM memory size [ 0.522750] [drm] qxl: 63M of IO pages memory ready (VRAM domain) [ 0.522750] [drm] qxl: 32M of Surface memory size [ 0.650714] fbcon: qxldrmfb (fb0) is primary device [ 0.668487] qxl 0000:00:02.0: fb0: qxldrmfb frame buffer device # dmesg 可列出核心產生的訊息！包括硬體偵測的流程也會顯示出來。 # 鳥哥使用的顯卡是 QXL 這個虛擬卡，透過 grep 來 qxl 的相關資訊，可發現如上資訊。 範例二：承上題，要將捉到的關鍵字顯色，且加上行號來表示： [dmtsai@study ~]$ dmesg | grep -n --color=auto 'qxl' 515:[ 0.522749] [drm] qxl: 16M of VRAM memory size 516:[ 0.522750] [drm] qxl: 63M of IO pages memory ready (VRAM domain) 517:[ 0.522750] [drm] qxl: 32M of Surface memory size 529:[ 0.650714] fbcon: qxldrmfb (fb0) is primary device 539:[ 0.668487] qxl 0000:00:02.0: fb0: qxldrmfb frame buffer device # 除了 qxl 會有特殊顏色來表示之外，最前面還有行號喔！其實顏色顯示已經是預設在 alias 當中了！ 範例三：承上題，在關鍵字所在行的前兩行與後三行也一起捉出來顯示 [dmtsai@study ~]$ dmesg | grep -n -A3 -B2 --color=auto 'qxl' # 你會發現關鍵字之前與之後的數行也被顯示出來！這樣可以讓你將關鍵字前後資料捉出來進行分析啦！ grep 是一個很常見也很常用的指令，他最重要的功能就是進行字串資料的比對，然後將符合使用者需求的字串列印出來。 需要說明的是『grep 在資料中查尋一個字串時，是以 \"整行\" 為單位來進行資料的擷取的！』也就是說，假如一個檔案內有 10 行，其中有兩行具有你所搜尋的字串，則將那兩行顯示在螢幕上，其他的就丟棄了！ 在 CentOS 7 當中，預設已經將 –color=auto 加入在 alias 當中了！使用者就可以直接使用有關鍵字顯色的 grep 囉！非常方便！ sed在瞭解了一些正規表示法的基礎應用之後，再來呢？呵呵～兩個東西可以玩一玩的，那就是 sed 跟底下會介紹的 awk 了！ 這兩個傢伙可是相當的有用的啊！舉例來說，鳥哥寫的 logfile.sh 分析登錄檔的小程式 (第十八章會談到)，絕大部分分析關鍵字的取用、統計等等，就是用這兩個寶貝蛋來幫我完成的！那麼你說，要不要玩一玩啊？^_^ 我們先來談一談 sed 好了， sed 本身也是一個管線命令，可以分析 standard input 的啦！ 而且 sed 還可以將資料進行取代、刪除、新增、擷取特定行等等的功能呢！很不錯吧～ 我們先來瞭解一下 sed 的用法，再來聊他的用途好了！ [dmtsai@study ~]$ sed [-nefr] [動作] 選項與參數： -n ：使用安靜(silent)模式。在一般 sed 的用法中，所有來自 STDIN 的資料一般都會被列出到螢幕上。 但如果加上 -n 參數後，則只有經過 sed 特殊處理的那一行(或者動作)才會被列出來。 -e ：直接在指令列模式上進行 sed 的動作編輯； -f ：直接將 sed 的動作寫在一個檔案內， -f filename 則可以執行 filename 內的 sed 動作； -r ：sed 的動作支援的是延伸型正規表示法的語法。(預設是基礎正規表示法語法) -i ：直接修改讀取的檔案內容，而不是由螢幕輸出。 動作說明： [n1[,n2]]function n1, n2 ：不見得會存在，一般代表『選擇進行動作的行數』，舉例來說，如果我的動作 是需要在 10 到 20 行之間進行的，則『 10,20[動作行為] 』 function 有底下這些咚咚： a ：新增， a 的後面可以接字串，而這些字串會在新的一行出現(目前的下一行)～ c ：取代， c 的後面可以接字串，這些字串可以取代 n1,n2 之間的行！ d ：刪除，因為是刪除啊，所以 d 後面通常不接任何咚咚； i ：插入， i 的後面可以接字串，而這些字串會在新的一行出現(目前的上一行)； p ：列印，亦即將某個選擇的資料印出。通常 p 會與參數 sed -n 一起運作～ s ：取代，可以直接進行取代的工作哩！通常這個 s 的動作可以搭配正規表示法！ 例如 1,20s/old/new/g 就是啦！ 以行為單位的新增/刪除功能 sed 光是用看的是看不懂的啦！所以又要來練習了！先來玩玩刪除與新增的功能吧！ 範例一：將 /etc/passwd 的內容列出並且列印行號，同時，請將第 2~5 行刪除！ [dmtsai@study ~]$ nl /etc/passwd | sed '2,5d' 1 root:x:0:0:root:/root:/bin/bash 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown .....(後面省略)..... 看到了吧？sed 的動作為 ‘2,5d’ ，那個 d 就是刪除！因為 2-5 行給他刪除了，所以顯示的資料就沒有 2-5 行囉～ 另外，注意一下，原本應該是要下達 sed -e 才對，沒有 -e 也行啦！同時也要注意的是， sed 後面接的動作，請務必以 ‘’ 兩個單引號括住喔！ 如果題型變化一下，舉例來說，如果只要刪除第 2 行，可以使用『 nl /etc/passwd | sed ‘2d’ 』來達成， 至於若是要刪除第 3 到最後一行，則是『 nl /etc/passwd | sed ‘3,$d’ 』的啦，那個錢字號『 $ 』代表最後一行！ 範例二：承上題，在第二行後(亦即是加在第三行)加上『drink tea?』字樣！ [dmtsai@study ~]$ nl /etc/passwd | sed '2a drink tea' 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin drink tea 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin .....(後面省略)..... 嘿嘿！在 a 後面加上的字串就已將出現在第二行後面囉！那如果是要在第二行前呢？『 nl /etc/passwd | sed ‘2i drink tea’ 』就對啦！就是將『 a 』變成『 i 』即可。 增加一行很簡單，那如果是要增將兩行以上呢？ 範例三：在第二行後面加入兩行字，例如『Drink tea or …..』與『drink beer?』 [dmtsai@study ~]$ nl /etc/passwd | sed '2a Drink tea or ......\\ &gt; drink beer ?' 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin Drink tea or ...... drink beer ? 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin .....(後面省略)..... 這個範例的重點是『我們可以新增不只一行喔！可以新增好幾行』但是每一行之間都必須要以反斜線『 \\ 』來進行新行的增加喔！所以，上面的例子中，我們可以發現在第一行的最後面就有 \\ 存在啦！在多行新增的情況下， \\ 是一定要的喔！ 以行為單位的取代與顯示功能剛剛是介紹如何新增與刪除，那麼如果要整行取代呢？看看底下的範例吧： 範例四：我想將第2-5行的內容取代成為『No 2-5 number』呢？ [dmtsai@study ~]$ nl /etc/passwd | sed '2,5c No 2-5 number' 1 root:x:0:0:root:/root:/bin/bash No 2-5 number 6 sync:x:5:0:sync:/sbin:/bin/sync .....(後面省略)..... 透過這個方法我們就能夠將資料整行取代了！非常容易吧！sed 還有更好用的東東！我們以前想要列出第 11~20 行， 得要透過『head -n 20 | tail -n 10』之類的方法來處理，很麻煩啦～ sed 則可以簡單的直接取出你想要的那幾行！是透過行號來捉的喔！看看底下的範例先： 範例五：僅列出 /etc/passwd 檔案內的第 5-7 行 [dmtsai@study ~]$ nl /etc/passwd | sed -n '5,7p' 5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 上述的指令中有個重要的選項『 -n 』，按照說明文件，這個 -n 代表的是『安靜模式』！ 那麼為什麼要使用安靜模式呢？你可以自行下達 sed ‘5,7p’ 就知道了 (5-7 行會重複輸出)！ 有沒有加上 -n 的參數時，輸出的資料可是差很多的喔！你可以透過這個 sed 的以行為單位的顯示功能， 就能夠將某一個檔案內的某些行號捉出來查閱！很棒的功能！不是嗎？ 部分資料的搜尋並取代的功能除了整行的處理模式之外， sed 還可以用行為單位進行部分資料的搜尋並取代的功能喔！ 基本上 sed 的搜尋與取代的與 vi 相當的類似！他有點像這樣： sed ‘s/要被取代的字串/新的字串/g’上表中特殊字體的部分為關鍵字，請記下來！至於三個斜線分成兩欄就是新舊字串的替換啦！ 我們使用底下這個取得 IP 數據的範例，一段一段的來處理給您瞧瞧，讓你瞭解一下什麼是咱們所謂的搜尋並取代吧！ 步驟一：先觀察原始訊息，利用 /sbin/ifconfig 查詢 IP 為何？ [dmtsai@study ~]$ /sbin/ifconfig eth0 eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 inet6 fe80::5054:ff:fedf:e174 prefixlen 64 scopeid 0x20&lt;link&gt; ether 52:54:00:df:e1:74 txqueuelen 1000 (Ethernet) .....(以下省略)..... 因為我們還沒有講到 IP ，這裡你先有個概念即可啊！我們的重點在第二行，也就是 192.168.1.100 那一行而已！先利用關鍵字捉出那一行！ 步驟二：利用關鍵字配合 grep 擷取出關鍵的一行資料 [dmtsai@study ~]$ /sbin/ifconfig eth0 | grep 'inet ' inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 當場僅剩下一行！要注意， CentOS 7 與 CentOS 6 以前的 ifconfig 指令輸出結果不太相同，鳥哥這個範例主要是針對 CentOS 7 以後的喔！接下來，我們要將開始到 addr: 通通刪除，就是像底下這樣：inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255上面的刪除關鍵在於『 ^.inet 』啦！正規表示法出現！ ^_^* 步驟三：將 IP 前面的部分予以刪除 [dmtsai@study ~]$ /sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 # 仔細與上個步驟比較一下，前面的部分不見了！接下來則是刪除後續的部分，亦即： 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 # 此時所需的正規表示法為：『 ' *netmask.*$ 』就是啦！ 步驟四：將 IP 後面的部分予以刪除 [dmtsai@study ~]$ /sbin/ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g' \\ &gt; | sed 's/ *netmask.*$//g' 192.168.1.100 透過這個範例的練習也建議您依據此一步驟來研究你的指令！就是先觀察，然後再一層一層的試做， 如果有做不對的地方，就先予以修改，改完之後測試，成功後再往下繼續測試。以鳥哥上面的介紹中， 那一大串指令就做了四個步驟！對吧！ ^_^ 讓我們再來繼續研究 sed 與正規表示法的配合練習！假設我只要 MAN 存在的那幾行資料， 但是含有 # 在內的註解我不想要，而且空白行我也不要！此時該如何處理呢？可以透過這幾個步驟來實作看看： 步驟一：先使用 grep 將關鍵字 MAN 所在行取出來 [dmtsai@study ~]$ cat /etc/man_db.conf | grep 'MAN' # MANDATORY_MANPATH manpath_element # MANPATH_MAP path_element manpath_element # MANDB_MAP global_manpath [relative_catpath] # every automatically generated MANPATH includes these fields ....(後面省略).... 步驟二：刪除掉註解之後的資料！ [dmtsai@study ~]$ cat /etc/man_db.conf | grep 'MAN'| sed 's/#.*$//g' MANDATORY_MANPATH /usr/man ....(後面省略).... # 從上面可以看出來，原本註解的資料都變成空白行啦！所以，接下來要刪除掉空白行 [dmtsai@study ~]$ cat /etc/man_db.conf | grep 'MAN'| sed 's/#.*$//g' | sed '/^$/d' MANDATORY_MANPATH /usr/man MANDATORY_MANPATH /usr/share/man MANDATORY_MANPATH /usr/local/share/man ....(後面省略).... 直接修改檔案內容(危險動作)你以為 sed 只有這樣的能耐嗎？那可不！ sed 甚至可以直接修改檔案的內容呢！而不必使用管線命令或資料流重導向！ 不過，由於這個動作會直接修改到原始的檔案，所以請你千萬不要隨便拿系統設定檔來測試喔！ 我們還是使用你下載的 regular_express.txt 檔案來測試看看吧！ 範例六：利用 sed 將 regular_express.txt 內每一行結尾若為 . 則換成 ! [dmtsai@study ~]$ sed -i 's/\\.$/\\!/g' regular_express.txt # 上頭的 -i 選項可以讓你的 sed 直接去修改後面接的檔案內容而不是由螢幕輸出喔！ # 這個範例是用在取代！請您自行 cat 該檔案去查閱結果囉！ 範例七：利用 sed 直接在 regular_express.txt 最後一行加入『# This is a test』 [dmtsai@study ~]$ sed -i '$a # This is a test' regular_express.txt # 由於 $ 代表的是最後一行，而 a 的動作是新增，因此該檔案最後新增囉！ sed 的『 -i 』選項可以直接修改檔案內容，這功能非常有幫助！舉例來說，如果你有一個 100 萬行的檔案，你要在第 100 行加某些文字，此時使用 vim 可能會瘋掉！因為檔案太大了！那怎辦？就利用 sed 啊！透過 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修訂！很棒吧！ 總之，這個 sed 不錯用啦！而且很多的 shell script 都會使用到這個指令的功能～ sed 可以幫助系統管理員管理好日常的工作喔！要仔細的學習呢！ awkawk 也是一個非常棒的資料處理工具！相較於 sed 常常作用於一整個行的處理， awk 則比較傾向於一行當中分成數個『欄位』來處理。因此，awk相當的適合處理小型的數據資料處理呢！awk 通常運作的模式是這樣的： [dmtsai@study ~]$ awk &#39;條件類型1{動作1} 條件類型2{動作2} ...&#39; filenameawk 後面接兩個單引號並加上大括號 {} 來設定想要對資料進行的處理動作。 awk 可以處理後續接的檔案，也可以讀取來自前個指令的 standard output 。 但如前面說的， awk 主要是處理『每一行的欄位內的資料』，而預設的『欄位的分隔符號為 “空白鍵” 或 “[tab]鍵” 』！舉例來說，我們用 last 可以將登入者的資料取出來，結果如下所示： [dmtsai@study ~]$ last -n 5 &lt;==僅取出前五行 dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) 若我想要取出帳號與登入者的 IP ，且帳號與 IP 之間以 [tab] 隔開，則會變成這樣： [dmtsai@study ~]$ last -n 5 | awk '{print $1 \"\\t\" $3}' dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai 192.168.1.100 dmtsai Fri 上表是 awk 最常使用的動作！透過 print 的功能將欄位資料列出來！欄位的分隔則以空白鍵或 [tab] 按鍵來隔開。 因為不論哪一行我都要處理，因此，就不需要有 “條件類型” 的限制！我所想要的是第一欄以及第三欄， 但是，第五行的內容怪怪的～這是因為資料格式的問題啊！所以囉～使用 awk 的時候，請先確認一下你的資料當中，如果是連續性的資料，請不要有空格或 [tab] 在內，否則，就會像這個例子這樣，會發生誤判喔！ 另外，由上面這個例子你也會知道，在 awk 的括號內，每一行的每個欄位都是有變數名稱的，那就是 $1, $2… 等變數名稱。以上面的例子來說， dmtsai 是 $1 ，因為他是第一欄嘛！至於 192.168.1.100 是第三欄， 所以他就是 $3 啦！後面以此類推～呵呵！還有個變數喔！那就是 $0 ，$0 代表『一整列資料』的意思～以上面的例子來說，第一行的 $0 代表的就是『dmtsai …. 』那一行啊！ 由此可知，剛剛上面五行當中，整個 awk 的處理流程是： 讀入第一行，並將第一行的資料填入 $0, $1, $2…. 等變數當中；依據 “條件類型” 的限制，判斷是否需要進行後面的 “動作”；做完所有的動作與條件類型；若還有後續的『行』的資料，則重複上面 1~3 的步驟，直到所有的資料都讀完為止。經過這樣的步驟，你會曉得， awk 是『以行為一次處理的單位』， 而『以欄位為最小的處理單位』。好了，那麼 awk 怎麼知道我到底這個資料有幾行？有幾欄呢？這就需要 awk 的內建變數的幫忙啦～ 變數名稱 代表意義 NF 每一行 ($0) 擁有的欄位總數NR 目前 awk 所處理的是『第幾行』資料FS 目前的分隔字元，預設是空白鍵 我們繼續以上面 last -n 5 的例子來做說明，如果我想要： 列出每一行的帳號(就是 $1)；列出目前處理的行數(就是 awk 內的 NR 變數)並且說明，該行有多少欄位(就是 awk 內的 NF 變數)則可以這樣： Tips鳥哥的圖示 要注意喔，awk 後續的所有動作是以單引號『 ‘ 』括住的，由於單引號與雙引號都必須是成對的， 所以， awk 的格式內容如果想要以 print 列印時，記得非變數的文字部分，包含上一小節 printf 提到的格式中，都需要使用雙引號來定義出來喔！因為單引號已經是 awk 的指令固定用法了！ [dmtsai@study ~]$ last -n 5| awk '{print $1 \"\\t lines: \" NR \"\\t columns: \" NF}' dmtsai lines: 1 columns: 10 dmtsai lines: 2 columns: 10 dmtsai lines: 3 columns: 10 dmtsai lines: 4 columns: 10 dmtsai lines: 5 columns: 9 注意喔，在 awk 內的 NR, NF 等變數要用大寫，且不需要有錢字號 $ 啦！這樣可以瞭解 NR 與 NF 的差別了吧？好了，底下來談一談所謂的 “條件類型” 了吧！ awk 的邏輯運算字元既然有需要用到 “條件” 的類別，自然就需要一些邏輯運算囉～例如底下這些： 運算單元 代表意義 大於&lt; 小於= 大於或等於&lt;= 小於或等於== 等於!= 不等於 值得注意的是那個『 == 』的符號，因為： 邏輯運算上面亦即所謂的大於、小於、等於等判斷式上面，習慣上是以『 == 』來表示；如果是直接給予一個值，例如變數設定時，就直接使用 = 而已。好了，我們實際來運用一下邏輯判斷吧！舉例來說，在 /etc/passwd 當中是以冒號 “:” 來作為欄位的分隔， 該檔案中第一欄位為帳號，第三欄位則是 UID。那假設我要查閱，第三欄小於 10 以下的數據，並且僅列出帳號與第三欄， 那麼可以這樣做： [dmtsai@study ~]$ cat /etc/passwd | awk '{FS=\":\"} $3 &lt; 10 {print $1 \"\\t \" $3}' root:x:0:0:root:/root:/bin/bash bin 1 daemon 2 ....(以下省略).... 有趣吧！不過，怎麼第一行沒有正確的顯示出來呢？這是因為我們讀入第一行的時候，那些變數 $1, $2… 預設還是以空白鍵為分隔的，所以雖然我們定義了 FS=”:” 了， 但是卻僅能在第二行後才開始生效。那麼怎麼辦呢？我們可以預先設定 awk 的變數啊！ 利用 BEGIN 這個關鍵字喔！這樣做： [dmtsai@study ~]$ cat /etc/passwd | awk 'BEGIN {FS=\":\"} $3 &lt; 10 {print $1 \"\\t \" $3}' root 0 bin 1 daemon 2 ......(以下省略)...... 很有趣吧！而除了 BEGIN 之外，我們還有 END 呢！另外，如果要用 awk 來進行『計算功能』呢？以底下的例子來看， 假設我有一個薪資資料表檔名為 pay.txt ，內容是這樣的： Name 1st 2nd 3th VBird 23000 24000 25000 DMTsai 21000 20000 23000 Bird2 43000 42000 41000 如何幫我計算每個人的總額呢？而且我還想要格式化輸出喔！我們可以這樣考慮： 第一行只是說明，所以第一行不要進行加總 (NR==1 時處理)；第二行以後就會有加總的情況出現 (NR&gt;=2 以後處理) [dmtsai@study ~]$ cat pay.txt | \\ &gt; awk 'NR==1{printf \"%10s %10s %10s %10s %10s\\n\",$1,$2,$3,$4,\"Total\" } &gt; NR&gt;=2{total = $2 + $3 + $4 &gt; printf \"%10s %10d %10d %10d %10.2f\\n\", $1, $2, $3, $4, total}' Name 1st 2nd 3th Total VBird 23000 24000 25000 72000.00 DMTsai 21000 20000 23000 64000.00 Bird2 43000 42000 41000 126000.00 上面的例子有幾個重要事項應該要先說明的： awk 的指令間隔：所有 awk 的動作，亦即在 {} 內的動作，如果有需要多個指令輔助時，可利用分號『;』間隔， 或者直接以 [Enter] 按鍵來隔開每個指令，例如上面的範例中，鳥哥共按了三次 [enter] 喔！邏輯運算當中，如果是『等於』的情況，則務必使用兩個等號『==』！格式化輸出時，在 printf 的格式設定當中，務必加上 \\n ，才能進行分行！與 bash shell 的變數不同，在 awk 當中，變數可以直接使用，不需加上 $ 符號。利用 awk 這個玩意兒，就可以幫我們處理很多日常工作了呢！真是好用的很～ 此外， awk 的輸出格式當中，常常會以 printf 來輔助，所以， 最好你對 printf 也稍微熟悉一下比較好啦！另外， awk 的動作內 {} 也是支援 if (條件) 的喔！ 舉例來說，上面的指令可以修訂成為這樣： [dmtsai@study ~]$ cat pay.txt | \\ &gt; awk '{if(NR==1) printf \"%10s %10s %10s %10s %10s\\n\",$1,$2,$3,$4,\"Total\"} &gt; NR&gt;=2{total = $2 + $3 + $4 &gt; printf \"%10s %10d %10d %10d %10.2f\\n\", $1, $2, $3, $4, total}' 你可以仔細的比對一下上面兩個輸入有啥不同～從中去瞭解兩種語法吧！我個人是比較傾向於使用第一種語法， 因為會比較有統一性啊！ ^_^ 除此之外， awk 還可以幫我們進行迴圈計算喔！真是相當的好用！不過，那屬於比較進階的單獨課程了， 我們這裡就不再多加介紹。如果你有興趣的話，請務必參考延伸閱讀中的相關連結喔 链接鸟哥的私房菜：第十一章、正規表示法與文件格式化處理","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"}]},{"title":"Shell脚本错误提示——binsh^Mbad interpreter","date":"2016-08-19T06:24:25.000Z","path":"2016/08/19/Shell脚本错误提示——binsh^Mbad interpreter/","text":"执行脚本的时候一直发现执行失败，命令没有达到预期效果 /bin/sh^M:bad interpreter: No such file or directory 这个错误发生在你在windows下编写文件上传到linux服务器去运行的时候。错误原因：windows和linux的文件不一样。解决办法:vi该文件 在命令模式下输入 :set ff=unix 回车例如 a.sh vi a.sh 进入输入 :set ff=unix 回车输入:wq 回车 再次执行就不会有这样的问题了。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"}]},{"title":"BucketSort桶排序","date":"2016-08-14T07:24:25.000Z","path":"2016/08/14/BucketSort桶排序/","text":"Bucket Sort介绍桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。 假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] &lt;1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。 介绍一个非常易于理解Bucket Sort的网站：Bucket Sort 桶排序有一个比较明显的缺点：数据最好都处于一个比较小的区间内，如果数据处于1-2亿的区间当中，用桶排序显然不合适 实现123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; bucket(vector&lt;int&gt;&amp; nums) &#123; int maxValue = getMax(nums); int numsSize = nums.size(); vector&lt;vector&lt;int&gt;&gt;bucket(numsSize + 1); //找桶：value*numsSize/(maxValue+1) for (int i = 0; i &lt; numsSize; i++) &#123; int bucketNum = (nums[i] * numsSize) / (maxValue + 1); bucket[bucketNum].push_back(nums[i]); &#125; //按顺序遍历桶，生成结果 for (int i = 0, m = 0; i &lt; numsSize + 1; i++) &#123; if (!bucket[i].empty()) &#123; //如果桶的数字个数大于1，对桶内进行排序 if (bucket[i].size() &gt; 1) &#123; sort(bucket[i].begin(), bucket[i].end()); &#125; for (int size = bucket[i].size(), j = 0; j &lt; size; j++, m++) &#123; nums[m] = bucket[i][j]; &#125; &#125; &#125; return nums; &#125; int getMax(vector&lt;int&gt; &amp;nums) &#123; int size = nums.size(); int max = INT_MIN; for (int i = 0; i &lt; size; i++) &#123; if (nums[i] &gt; max) &#123; max = nums[i]; &#125; &#125; return max; &#125;&#125;;","tags":[{"name":"BucketSort","slug":"BucketSort","permalink":"https://github.com/kong36088/kong36088.github.io/tags/BucketSort/"},{"name":"排序","slug":"排序","permalink":"https://github.com/kong36088/kong36088.github.io/tags/排序/"},{"name":"算法","slug":"算法","permalink":"https://github.com/kong36088/kong36088.github.io/tags/算法/"}]},{"title":"Leetcode题解——347Top K Frequent Elements","date":"2016-08-14T06:24:25.000Z","path":"2016/08/14/Leetcode题解——347Top K Frequent Elements/","text":"题目题目地址：347. Top K Frequent Elements Given a non-empty array of integers, return the k most frequent elements. For example,Given [1,1,1,2,2,3] and k = 2, return [1,2]. Note:You may assume k is always valid, 1 ≤ k ≤ number of unique elements.Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 根据题目大意就是，给出一个数组，找出其中出现次数前K多的数字并以数组形式返回 题解利用优先队列123456789101112131415161718192021222324252627282930class Solution &#123;private : unordered_map&lt;int, int&gt;um; vector&lt;int&gt;n; int numsSize;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; numsSize = nums.size(); n = nums; priority_queue&lt;pair&lt;int,int&gt;&gt;pq; vector&lt;int&gt;result; //利用hashmap进行个数的统计 for (int i = 0; i &lt; numsSize; i++) &#123; um[n[i]]++; &#125; auto it = um.begin(); //新建一个优先队列，优先队列是堆排序的升级版O(nlog2n)的时间复杂度，默认大顶堆 for (int size = um.size(),i = 0; i &lt; size; i++) &#123; pq.push(make_pair(it-&gt;second, it-&gt;first)); it++; &#125; //最后取堆顶 for (int i = 0; i &lt; k; i++) &#123; result.push_back(pq.top().second); pq.pop(); &#125; return result; &#125;&#125;; 大顶堆的特性是从顶部元素往下依次从大到小进行排序，小顶堆则反之要取得前K个出现次数最多的数，只需要每次都取堆顶元素-&gt;删除堆顶-&gt;调整堆继续取堆顶 利用Bucket Sort利用桶排序中桶号作为出现次数，桶中放入次数对应的数字 1234567891011121314151617181920212223242526public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;Integer, Integer&gt;(); for (int n : nums) &#123; frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1); &#125; for (int key : frequencyMap.keySet()) &#123; int frequency = frequencyMap.get(key); if (bucket[frequency] == null) &#123; bucket[frequency] = new ArrayList&lt;&gt;(); &#125; bucket[frequency].add(key); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int pos = bucket.length - 1; pos &gt;= 0 &amp;&amp; res.size() &lt; k; pos--) &#123; if (bucket[pos] != null) &#123; res.addAll(bucket[pos]); &#125; &#125; return res;&#125;","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/kong36088/kong36088.github.io/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/kong36088/kong36088.github.io/tags/LeetCode/"}]},{"title":"LeetCode题解——299Bulls_and_Cows","date":"2016-07-28T06:24:25.000Z","path":"2016/07/28/LeetCode题解——299Bulls_and_Cows/","text":"我的4ms解法题目地址：Bulls and Cows题目：You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number. For example: Secret number: “1807”Friend’s guess: “7810”Hint: 1 bull and 3 cows. (The bull is 8, the cows are 0, 1 and 7.)Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. In the above example, your function should return “1A3B”. Please note that both secret number and friend’s guess may contain duplicate digits, for example: Secret number: “1123”Friend’s guess: “0111”In this case, the 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow, and your function should return “1A1B”.You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal. 题目大意在Secret串和Guess串中找出位置相同且数字相同的数量A，并且计算出位置不一样但是数字相同的数量B 以下是代码1234567891011121314151617181920212223242526272829class Solution &#123;public: string getHint(string secret, string guess) &#123; int countA = 0, countB = 0; int sizeA = secret.size(), sizeB = guess.size(); int pos = 0; int markA[10] = &#123;0&#125;,markB[10]=&#123;0&#125;; for (pos=0;pos &lt; sizeA;pos++) &#123; int tmpA=secret.at(pos)-48,tmpB=guess.at(pos)-48; if(tmpA==tmpB)&#123; countA++; continue; &#125; markA[tmpA]++; markB[tmpB]++; &#125; //计算B的大小 for(int i=0;i&lt;10;i++)&#123; if(markA[i]&gt;0&amp;&amp;markB[i]&gt;0)&#123; if(markA[i]&gt;=markB[i])&#123; countB+=markB[i]; &#125;else&#123; countB+=markA[i]; &#125; &#125; &#125; return to_string(countA)+\"A\"+to_string(countB)+\"B\"; &#125;&#125;;","tags":[{"name":"C++","slug":"C","permalink":"https://github.com/kong36088/kong36088.github.io/tags/C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://github.com/kong36088/kong36088.github.io/tags/LeetCode/"}]},{"title":"设计模式（创建型 二）——单例模式和原型模式","date":"2016-07-25T10:24:25.000Z","path":"2016/07/25/设计模式（创建型 二）——单例模式和原型模式/","text":"本文主要讲解设计模式：单例模式（Singleton）、原型模式（Prototype） 单例模式单例模式可以使一些特殊的类只被实例化一次，保持每次只使用同一个类关于适用性：1）当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。2）当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 关于单例模式的实现也非常简单以下是实现的代码1234567891011121314151617181920&lt;?php class Singleton &#123; static private $_instance = null;//静态成员保存唯一实例 /** * 私有构造函数，保证不能被外部访问 * */ private function __construct() &#123;&#125; /** * 静态方法将创建这个实例的操作并保证只有一个实例被创建 * * @return unknown */ public static function getInstance() &#123; if (!self::$_instance) &#123; self::$_instance = new self(); &#125; return self::$_instance; &#125; &#125; 同时，通过改造单例模式也可以实现多例模式1234567891011121314151617181920212223&lt;?php class Singleton &#123; static private $_instance[] = array();//静态成员保存唯一实例 private $uid; /** * 私有构造函数，保证不能被外部访问 * */ private function __construct($uid) &#123; $this-&gt;uid = $uid; &#125; /** * 静态方法将创建这个实例的操作并保证只有一个实例被创建 * * @return unknown */ public static function getInstance($uid = 0) &#123; if (!self::$_instance || !isset(self::$_instance[$uid])) &#123; self::$_instance[$uid] = new self($uid); &#125; return self::$_instance[$uid]; &#125; &#125; 原型模式原型模式适用于初始化过程非常繁琐的类当中。通过clone()这一方法可以更为简单的得到初始化之后的类同时也适用于已经改变结构的类。简而言之，简化初始化过程，提高计算效率 1 ) 运行时刻增加和删除产品： Prototype允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。2 ) 改变值以指定新对象： 高度动态的系统允许你通过对象复合定义新的行为—例如，通过为一个对象变量指定值—并且不定义新的类。你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新的行为。这种设计使得用户无需编程即可定义新“类” 。实际上，克隆一个原型类似于实例化一个类。Prototype模式可以极大的减少系统所需要的类的数目。3) 改变结构以指定新对象：许多应用由部件和子部件来创建对象。4) 减少子类的构造 Factory Method 经常产生一个与产品类层次平行的 Creator类层次。Prototype模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因此你根本不需要Creator类层次。这一优点主要适用于像 C + +这样不将类作为一级类对象的语言。像Smalltalk和Objective C这样的语言从中获益较少，因为你总是可以用一个类对象作为生成者。在这些语言中，类对象已经起到原型一样的作用了。5) 用类动态配置应用 一些运行时刻环境允许你动态将类装载到应用中。在像 C + +这样的语言中，Prototype模式是利用这种功能的关键。一个希望创建动态载入类的实例的应用不能静态引用类的构造器。而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例（参见实现一节） 。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。 E T + +应用框架[ W G M 8 8 ]有一个运行系统就是使用这一方案的。 以下是代码示例12345678910111213141516171819202122232425262728293031323334353637/** * 原型模式 */ /** * 抽象原型角色 */ interface Prototype &#123; public function copy(); &#125; /** * 具体原型角色 */ class ConcretePrototype implements Prototype&#123; private $_name; public function __construct($name) &#123; $this-&gt;_name = $name; &#125; public function setName($name) &#123; $this-&gt;_name = $name; &#125; public function getName() &#123; return $this-&gt;_name; &#125; public function copy() &#123; /** 深拷贝 */ return clone $this; /** 浅拷贝 */ //return $this; &#125; &#125; 参考文章设计模式（二）单件模式Singleton（创建型）设计模式（四）原型模式Prototype（创建型）","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/kong36088/kong36088.github.io/tags/设计模式/"}]},{"title":"设计模式（创建型 一）——建造模式与工厂模式","date":"2016-07-25T06:24:25.000Z","path":"2016/07/25/设计模式（创建型 一）——建造模式与工厂模式/","text":"创建型的设计模式主要包括：工厂模式、建造模式、单例模式、原型模式本文主要针对建造模式类似的两种设计模式进行学习记录总结主要介绍：工厂模式Factory、建造者模式（Builder） 工厂模式工厂模式在日常设计开发中较为常见。使用场景：1)当客户程序不需要知道要使用对象的创建过程。2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。 由产品类、工厂类、客户类三中类构成这里举个例子 产品类：12345678910111213141516171819/** * 车子系列 * */ abstract Class BWM&#123; function __construct($pa) &#123; &#125; &#125; Class BWM320 extends BWM&#123; function __construct($pa) &#123; &#125; &#125; Class BMW523 extends BWM&#123; function __construc($pb)&#123; &#125;&#125; 工厂类1234567891011121314151617181920212223242526272829/** * 创建工厂的接口 * */ interface FactoryBMW &#123; function createBMW(); &#125; /** * * 创建BWM320车 */ class FactoryBWM320 implements FactoryBMW &#123; function createBMW($type)&#123; return new BWM320(); &#125; &#125; /** * * 创建BWM523车 */ class FactoryBWM523 implements FactoryBMW &#123; function createBMW($type)&#123; return new BMW523(); &#125; &#125; 客户类123456789101112131415161718/** * * 客户得到车 */ class Customer &#123; private $BMW; function getBMW($type)&#123; switch ($type) &#123; case 320: $BWM320 = new FactoryBWM320(); return $BWM320-&gt;createBMW(); case 523: $BWM523 = new FactoryBWM523(); return $BWM320-&gt;createBMW(); //.... &#125; &#125;&#125; 工厂模式较为适合进行未知产品类型的开发，在需要进行多种不同类型的产品的开发时，使用单一的工厂可以保持产品的单一入口，从而提高代码的复用率和开发时效率 建造者模式建造者模式和工厂模式较为相似，但是在生成复杂产品的时候使用建造者模式会比较的适合建造者模式比工厂模式多出一个指导者类，用于组装builder生产出的组件以下是例子： 指导者类12345678910111213141516&lt;?php /** * 指导者:收银员 * */ class DirectorCashier &#123; /** * 收银餐馆员工返回的食物 * */ public function buildFood(Builder $builder) &#123; $builder-&gt;buildPart1(); $builder-&gt;buildPart2(); &#125; &#125; 建造者类（不同的产品有不同的组件）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 具体建造者类:餐馆员工,返回的套餐是：汉堡两个+饮料一个 * */ class ConcreteBuilder1 extends Builder &#123; protected $_product = null;//产品对象 function __construct()&#123; $this-&gt;_product = new Product(); &#125; /** * 创建产品的第一部分::汉堡=2 */ public function buildPart1() &#123; $this-&gt;_product-&gt;add('Hamburger',2); &#125; /** * * 创建产品的第二部分： */ public function buildPart2() &#123; $this-&gt;_product-&gt;add('Drink', 1); &#125; /** * 返回产品对象 : * */ public function getProduct() &#123; return $this-&gt;_product; &#125; &#125; /** * 具体建造者类:餐馆员工，汉堡1个+饮料2个 * */ class ConcreteBuilder2 extends Builder &#123; protected $_product = null;//产品对象 function __construct()&#123; $this-&gt;_product = new Product(); &#125; /** * 创建产品的第一部分:汉堡 */ public function buildPart1() &#123; $this-&gt;_product-&gt;add('Hamburger', 1); &#125; /** * * 创建产品的第二部分:drink=2 */ public function buildPart2() &#123; $this-&gt;_product-&gt;add('Drink', 2); &#125; /** * 返回产品对象 : * */ public function getProduct() &#123; return $this-&gt;_product; &#125; &#125; 产品类12345678910111213141516171819202122/** * 产品类 */ class Product &#123; public $products = array(); /** * 添加具体产品 */ public function add($name, $value) &#123; $this-&gt;products[$name] = $value; &#125; /** * 给顾客查看产品 */ public function showToClient() &#123; foreach ($this-&gt;products as $key =&gt; $v) &#123; echo $key , '=' , $v ,'&lt;br&gt;'; &#125; &#125; &#125; 客户程序123456789101112131415161718192021222324class Client &#123; /** * 顾客购买套餐 * */ public function buy($type) &#123; //指导者，收银员 $director = new DirectorCashier(); //餐馆员工，收银员 $class = new ReflectionClass('ConcreteBuilder' .$type ); $concreteBuilder = $class-&gt;newInstanceArgs(); //收银员组合员工返回的食物 $director-&gt;buildFood($concreteBuilder); //返回给顾客 $concreteBuilder-&gt;getProduct()-&gt;showToClient(); &#125; &#125; //测试 ini_set('display_errors', 'On'); $c = new Client(); $c-&gt;buy(1);//购买套餐1 $c-&gt;buy(2);//购买套餐1 如果产品的建造很复杂，使用工厂模式如果产品的建造更加复杂，使用建造者模式按照个人理解来说，其实建造者模式就是工厂模式的上升，在生产出产品的类上再次封装一层，使得代码封装程度更高，更加便于维护建造模式把生产出产品之上再加一层，工厂生产出的只是组件，还需要指导者去组装这些组件使之成为产品 参考文章设计模式（一）工厂模式Factory（创建型）设计模式（三）建造者模式Builder（创建型）","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/kong36088/kong36088.github.io/tags/设计模式/"}]},{"title":"基于docker搭建gogs","date":"2016-07-08T06:24:25.000Z","path":"2016/07/08/基于docker搭建gogs/","text":"在linux下利用docker搭建gogs首先需要在服务器上安装docker-compose和docker在之前的 docker-compose快速搭建lnmp+redis服务器环境 文章中有介绍，这里就不再赘述了 搭建mysql的容器123mkdir /mysqlcd /mysqlvi docker-compose.yml 生成docker-compose.yml并且内容如下12345678910mysql: container_name: mysql build: . volumes: - /mysql/data/:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: root ports: - &quot;3306:3306&quot; restart: always 保存并退出 :wq，在同一目录下创建Dockerfile123456vi Dockerfile#编辑Dockerfile文件保存From mysql#保存退出 :wqmkdir /mysql/datadocker-compose up -d mysql容器搭建完成 搭建gogs容器1234mkdir /gogsmkdir /gogs/datacd /gogsvi docker-compose.yml 其中docker-compose.yml内容如下，完成编辑后保存退出1234567891011gogs: container_name: gogs build: . ports: - &quot;10002:22&quot; - &quot;3000:3000&quot; external_links: - mysql:mysql volumes: - /gogs/data:/data restart: always 1234vi Dockerfile#内容如下From gogs/gogsdocker-compose up -d 完成创建 进入mysql创建gogs库123mysql -uroot -proot -h0.0.0.0 mysql &gt; CREATE DATABASE `gogs` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;mysql &gt; exit 进行gogs的相关设置在浏览器访问本机地址的3000端口，进行初始化设置按照下图参考设置 安装完成后注册一个账户作为管理员账户大功告成！","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/docker/"}]},{"title":"docker-compose快速搭建lnmp+redis服务器环境","date":"2016-06-01T06:24:25.000Z","path":"2016/06/01/docker-compose快速搭建lnmp7+redis服务器环境/","text":"安装最新版本docker这里我系统用的是centos7，具体安装方法也可以到官网上去查看官网地址 Docker requires a 64-bit installation regardless of your CentOS version. Also, your kernel must be 3.10 at minimum, which CentOS 7 runs.To check your current kernel version, open a terminal and use uname -r to display your kernel version: 12$ uname -r3.10.0-229.el7.x86_64 确认系统版本符合后开始安装1234567891011$ sudo yum update$ sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-'EOF'[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF$ sudo yum install docker-engine$ sudo service docker start 安装docker-compose先安装pip123sudo yum updatesudo yum -y install epel-releasesudo yum -y install python-pip 安装完成后我们接着安装docker-compose1sudo pip install -U docker-compose 大功告成 搭建lnmp7+redis环境生成目录结构在根目录下创建一个app目录然后在app目录下生成nginx-php mysql redis子目录，用于存放各类数据1sudo mkdir /app 这里是目录结构 ~/Dockerfiles├── mysql│ └── Dockerfile├── nginx-php│ ├── Dockerfile├── redis│ └── Dockerfile└── www └── 网站代码 利用docker-compose生成环境docker-compose.yml的内容1234567891011121314151617181920212223242526nginx-php: build: ./nginx-php ports: - &quot;80:80&quot; links: - &quot;mysql&quot; volumes: - /app/www:/var/www/html environment: WEB_DOCUMENT_ROOT: /var/www/htmlmysql: build: ./mysql ports: - &quot;3306:3306&quot; volumes: - /app/mysql/data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: rootredis: build: ./redis ports: - &quot;6379:6379&quot; volumes: - /app/redis/data:/data nginx-php的Dockerfile1From webdevops/php-nginx:debian-8-php7 这个是一个第三方的nginx php服务器，自带redis memcached gd mysql等拓展mysql的Dockerfile1From mysql:latest redis的Dockerfile1From redis:latest 最后运行命令12cd /appdocker-compose up -d 等待自动生成容器后环境搭建成功 参考资料Docker File ReferenceDocker在PHP项目开发环境中的应用用 Docker 来运行和调试 PHP 网站","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/docker/"}]},{"title":"利用docker搭建lnmp7服务器环境教程","date":"2016-05-30T06:24:25.000Z","path":"2016/05/30/利用docker搭建lnmp7服务器环境教程/","text":"ubuntu镜像从官方下载一个ubuntu镜像1docker pull ubuntu:14.04 安装nginx安装nginx服务1234docker run --net=host -it ubuntu:14.04 bashapt-get update apt-get install nginx 完成安装 配置1sudo vim /etc/nginx/sites-available/kejyun.dev 完成主机的设定123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051server &#123; # 設定 Listen 的 port listen 80; # 設定服務主機名稱 server_name kejyun.dev; # 設定網站根目錄路徑 root \"/home/kejyun/laravel52/public\"; # 設定讀取檔案優先順序 index index.html index.htm index.php; # 設定網站編碼 charset utf-8; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location = /favicon.ico &#123; access_log off; log_not_found off; &#125; location = /robots.txt &#123; access_log off; log_not_found off; &#125; access_log off; # 設定 Log 路徑 error_log /var/log/nginx/kejyun.dev-error.log error; sendfile off; client_max_body_size 100m; # 設定 php 檔案處理方式 location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; &#125; location ~ /\\.ht &#123; deny all; &#125;&#125; 连接配置文件1sudo ln -s /etc/nginx/sites-available/kejyun.dev /etc/nginx/sites-enabled/kejyun.dev 重启服务1service nginx restart 安装php7添加环境安装添加ppa所需环境12sudo apt-get install software-properties-commonsudo apt-get install python3-software-properties 添加源1LC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/php LC_ALL=C.UTF-8是为了指定编码，不添加这一段会报错，这是官方的一个bug 关闭selinux这里要先关闭selinux否则会报错1sudo vim /etc/selinux/.conf 在文件底部增加这一行1SELINUX=disabled 重启容器12exitdocker restart xxxx 安装php712sudo apt-get updatesudo apt-get install php7.0-fpm php7.0-mysql php7.0-mcrypt php7.0-gd php7.0-cli php7.0-curl php7.0-imap 完成 安装mysql5.7获取mysql5.7套件123wget http://dev.mysql.com/get/mysql-apt-config_0.6.0-1_all.debsudo dpkg -i mysql-apt-config_0.6.0-1_all.debsudo dpkg-reconfigure mysql-apt-config 设定mysql预设安装版本 安装mysql12sudo apt-get updatesudo apt-get install mysql-server-5.7 完成 参考资料主機環境建置","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/docker/"}]},{"title":"Centos7下搭建gogs","date":"2016-05-24T06:24:25.000Z","path":"2016/05/24/Centos7下搭建gogs/","text":"新建用户Gogs 默认以 git 用户运行。运行 sudo adduser git 新建好 git 用户。su git 以 git 用户登录，到 git 用户的主目录中新建好 .ssh 文件夹。完成 下载二进制代码在 这里 可以根据系统下载二进制代码之后解压到任意地方，在这里我选择解压到/home/git 下12345$ ls /home/git/gogs/$ custom data gogs LICENSE log public README.md README_ZH.md scripts templates$ #这里给把gogs目录权限赋予git用户$ sudo chown -R git:git /home/git/gogs/$ sudo chmod -R 760 /home/git/gogs/ 运行安装首先安装数据库，这里我们安装mariadb，在centos7中mariadb代替了mysql 12sudo yum updateyum -y install mariadb 安装好数据库后我们进行安装gogs123456$ mysql -u root -p&gt; # （输入密码）&gt; create user 'gogs'@'localhost' identified by '密码';&gt; grant all privileges on gogs.* to 'gogs'@'localhost';&gt; flush privileges;&gt; exit; 这里配置好数据库后即可开始安装gogs啦12$ cd /home/git/gogs/$ ./gogs web 到gogs解压目录下，./gogs web开启gogs默认端口是3000，也可以通过./gogos web -port 3301来改变端口至3301访问localhost:3000/install进行安装在这里要注意对gogs相应目录赋予git用户权限，根据缺省设置，这里我这么配置123$ mkdir /home/git/gogs-repositories/$ sudo chown -R git:git ./gogs-repositories/$ sudo chmod -R 760 ./gogs-repositories/ 安装完成后即可访问啦 gogs守护进程启动gogs中的app.ini配置首先配置 gogs/custom/conf/app.ini根据本地环境进行相应配置以下是我的配置文件123456789101112131415161718192021222324252627282930313233343536373839404142APP_NAME = Gogs: Go Git ServiceRUN_USER = gitRUN_MODE = prod[database]DB_TYPE = mysqlHOST = 127.0.0.1:3306NAME = gogsUSER = rootPASSWD = rootSSL_MODE = disablePATH = data/gogs.db[repository]ROOT = /home/git/gogs-repositories[server]DOMAIN = 115.159.146.149HTTP_PORT = 3000ROOT_URL = http://115.159.146.149:3000/DISABLE_SSH = falseSSH_PORT = 22OFFLINE_MODE = false[mailer]ENABLED = false[service]REGISTER_EMAIL_CONFIRM = falseENABLE_NOTIFY_MAIL = falseDISABLE_REGISTRATION = falseENABLE_CAPTCHA = trueREQUIRE_SIGNIN_VIEW = false[picture]DISABLE_GRAVATAR = false[session]PROVIDER = file[log]MODE = file RUN_USER 默认是 git，指定 Gogs 以哪个用户运行 ROOT 所有仓库的存储根路径 PROTOCOL 如果你使用 nginx 反代的话请使用 http，如果直接裸跑对外服务的话随意 DOMAIN 域名。会影响 SSH clone 地址 ROOT_URL 完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址 HTTP_ADDR 监听地址，使用 nginx 的话建议 127.0.0.1，否则 0.0.0.0 也可以 HTTP_PORT 监听端口，默认 3000 INSTALL_LOCK 锁定安装页面 Mailer 相关的选项 systemd服务配置在 GitHub 上的 Gogs 仓库有一个 systemd服务模版文件 更新 User、Group、WorkingDirectory、ExecStart 和 Environment 为相对应的值。其中 WorkingDirectory 为Gogs实际安装路径根目录。[可选] 如果您 Gogs 安装示例使用 MySQL/MariaDB、PostgreSQL、Redis 或 memcached，请去掉相应 After 属性的注释。完成修改后，将文件保存至 /etc/systemd/system/gogs.service，然后通过 sudo systemctl enable gogs 命令激活，最后执行 sudo systemd start gogs启动。 通过 sudo systemd status gogs -l 或 sudo journalctl -b -u gogs 可以查看 Gogs 的运行状态。 这是我的/etc/systemd/system/gogs.service配置文件1234567891011121314151617181920212223242526[Unit]Description=Gogs (Go Git Service)After=syslog.targetAfter=network.targetAfter=mariadb.service#After=postgresql.service#After=memcached.service#After=redis.service[Service]# Modify these two values and uncomment them if you have# repos with lots of files and get an HTTP error 500 because# of that####LimitMEMLOCK=infinity#LimitNOFILE=65535Type=simpleUser=gitGroup=gitWorkingDirectory=/home/git/gogsExecStart=/home/git/gogs/gogs webRestart=alwaysEnvironment=USER=git HOME=/home/git[Install]WantedBy=multi-user.target 大功告成 另一种比较暴力的守护进程启动方式切换到gogs所在目录，执行nohup ./gogs web &amp;12$ cd /home/git/gogs$ nohup ./gogs web &amp; 参考参考文章：https://mynook.info/blog/post/host-your-own-git-server-using-gogs","tags":[{"name":"gogs","slug":"gogs","permalink":"https://github.com/kong36088/kong36088.github.io/tags/gogs/"},{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"}]},{"title":"在JS中对异步数据请求进行封装","date":"2016-05-23T06:24:25.000Z","path":"2016/05/23/在JS中对异步数据请求进行封装/","text":"前戏介绍jQuery.ajax返回的是jqXHR对象，它是浏览器原生XMLHttpRequest对象的一个超集，并实现了Promise接口。使它拥有了Promise的所有属性，方法和行为。为了让回调函数名字统一，便于$.ajax中使用，jqXHR也提供了.error()，.success()，.complete()但是由于版本的升级相应的.fail()，.done()，.always()代替了前三个方法，使用方式和解释并没有什么区别。 jqXHR.fail(function(jqXHR, textStatus, errorThrown) {});一种可供选择的请求失败时调用的回调选项构造函数，.fail()方法取代了的过时的.error()方法。jqXHR.done(function(data, textStatus, jqXHR) {});一种可供选择的请求成功时调用的回调选项构造函数，.done()方法取代了过时的.success()方法。jqXHR.always(function(data|jqXHR, textStatus, jqXHR|errorThrown) {});一种可供选择的请求结束时调用的回调选项构造函数，.always()方法代替了过时的.complete()方法,当请求成功时，该函数的参数与.done()的参数一致；当请求失败时，该函数的参数与.fail()的参数一致。 过程介绍封装成两个文件，分别为逻辑层和视图层 逻辑层 12345678910111213141516171819202122232425262728293031323334353637$(function () &#123; http = &#123; httpGet: function (url, data) &#123; return $.ajax(&#123; type: \"GET\", headers: &#123;'X-CSRF-TOKEN': csrf_token&#125;, url: url, async: true &#125;); &#125;, httpPost: function (url, data) &#123; return $.ajax(&#123; type: \"POST\", headers: &#123;'X-CSRF-TOKEN': csrf_token&#125;, url: url, data: data, async: true &#125;); &#125;, httpPut: function (url, data) &#123; return $.ajax(&#123; type: \"PUT\", headers: &#123;'X-CSRF-TOKEN': csrf_token&#125;, url: url, data: data, async: true &#125;); &#125;, httpDelete: function (url, data) &#123; return $.ajax(&#123; type: \"DELETE\", headers: &#123;'X-CSRF-TOKEN': csrf_token&#125;, url: url, data: data, async: true &#125;); &#125; &#125;;&#125;); 视图层 1234567891011121314151617181920212223242526272829303132333435$(function () &#123; callAjax = function (type, request_url, data, redirect) &#123; var xhr; $(\".loading\").css('display', 'block'); type = type.toLowerCase(); switch (type) &#123; case 'get': xhr = http.httpGet(request_url, data); break; case 'post': xhr = http.httpPost(request_url, data); break; case 'put': xhr = http.httpPut(request_url, data); break; case 'delete': xhr = http.httpDelete(request_url, data); break; &#125; xhr.fail(function (jqXHR, textStatus, errorThrown) &#123; alert(\"加载失败，请重试\"); &#125;).done(function (data, textStatus, jqXHR) &#123; if (data.status == 1) &#123; alert(data.message); if (redirect) &#123; window.location.href = redirect; &#125; &#125; else &#123; alert(data.message); &#125; &#125;).always(function (data, textStatus, errorThrown) &#123; $(\".loading\").css('display', 'none'); &#125;); &#125;&#125;); 封装代码很好地提高了代码的规范和代码的复用性","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"}]},{"title":"docker使用安装教程（二）","date":"2016-05-10T11:24:25.000Z","path":"2016/05/10/docker使用安装教程（二）/","text":"根据上一节配置的容器，继续进行操作 apt-get update apt-get install -y nginx 安装好之后，退出容器 root@ubuntu:/# exit exit root@ubuntu:/home/jwl# 保存修改 root@ubuntu:/home/jwl# docker commit -m \"add nginx\" 596e william/ubuntu-nginx:v1 dab208031d1dc8f6a10f91363959a943f86f6233d790bbba10f44fe278b4c195 root@ubuntu:/home/jwl# docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE william/ubuntu-nginx v1 dab208031d1d 8 seconds ago 299.9 MB ubuntu 14.04 d4751aa1c40a 6 days ago 188 MB 此时已经加入到镜像了","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Docker/"}]},{"title":"docker使用安装教程（一）","date":"2016-05-10T06:24:25.000Z","path":"2016/05/10/docker使用安装教程（一）/","text":"本人使用的安装环境是ubuntu15.04那么，开始~ 安装docker首先，安装docker apt-get update apt-get install docker.io 安装完成后，输入docker查看docker信息 Usage: docker [OPTIONS] COMMAND [arg...] A self-sufficient runtime for linux containers. Options: --api-cors-header= Set CORS headers in the remote API -b, --bridge= Attach containers to a network bridge --bip= Specify network bridge IP -D, --debug=false Enable debug mode -d, --daemon=false Enable daemon mode --default-ulimit=[] Set default ulimits for containers --dns=[] DNS server to use --dns-search=[] DNS search domains to use -e, --exec-driver=native Exec driver to use --fixed-cidr= IPv4 subnet for fixed IPs --fixed-cidr-v6= IPv6 subnet for fixed IPs -G, --group=docker Group for the unix socket -g, --graph=/var/lib/docker Root of the Docker runtime -H, --host=[] Daemon socket(s) to connect to -h, --help=false Print usage --icc=true Enable inter-container communication --insecure-registry=[] Enable insecure registry communication --ip=0.0.0.0 Default IP when binding container ports --ip-forward=true Enable net.ipv4.ip_forward --ip-masq=true Enable IP masquerading --iptables=true Enable addition of iptables rules --ipv6=false Enable IPv6 networking -l, --log-level=info Set the logging level --label=[] Set key=value labels to the daemon --log-driver=json-file Containers logging driver --mtu=0 Set the containers network MTU -p, --pidfile=/var/run/docker.pid Path to use for daemon PID file --registry-mirror=[] Preferred Docker registry mirror -s, --storage-driver= Storage driver to use --selinux-enabled=false Enable selinux support --storage-opt=[] Set storage driver options --tls=false Use TLS; implied by --tlsverify --tlscacert=~/.docker/ca.pem Trust certs signed only by this CA --tlscert=~/.docker/cert.pem Path to TLS certificate file --tlskey=~/.docker/key.pem Path to TLS key file --tlsverify=false Use TLS and verify the remote -v, --version=false Print version information and quit Commands: attach Attach to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders from a container's filesystem to the host path create Create a new container diff Inspect changes on a container's filesystem events Get real time events from the server exec Run a command in a running container export Stream the contents of a container as a tar archive history Show the history of an image images List images import Create a new filesystem image from the contents of a tarball info Display system-wide information inspect Return low-level information on a container or image kill Kill a running container load Load an image from a tar archive login Register or log in to a Docker registry server logout Log out from a Docker registry server logs Fetch the logs of a container port Lookup the public-facing port that is NAT-ed to PRIVATE_PORT pause Pause all processes within a container ps List containers pull Pull an image or a repository from a Docker registry server push Push an image or a repository to a Docker registry server rename Rename an existing container restart Restart a running container rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save an image to a tar archive search Search for an image on the Docker Hub start Start a stopped container stats Display a stream of a containers' resource usage statistics stop Stop a running container tag Tag an image into a repository top Lookup the running processes of a container unpause Unpause a paused container version Show the Docker version information wait Block until a container stops, then print its exit code Run 'docker COMMAND --help' for more information on a command. 开始新建一个docker容器在docker镜像市场上找到需要下载的镜像，进行下载 docker pull ubuntu:14.04 下载镜像的过程可能比较慢，镜像大小有差不多200MB 下载完成之后，可以查看本地拥有的镜像 root@ubuntu:/# docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 d4751aa1c40a 5 days ago 188 MB 之后就可以开始创建容器了 root@ubuntu:/# docker run --net=host -it ubuntu:14.04 root@c944a54f35dc:/# 创建成功 但是发现ping 8.8.8.8失败 root@c944a54f35dc:/# ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. From 172.17.0.1 icmp_seq=1 Destination Host Unreachable From 172.17.0.1 icmp_seq=2 Destination Host Unreachable 根据stackover找到的答案I was facing the same problem. So, to solve that issue I’ve started the container using the argument –net=host, it worked perfectly for me. Here goes the full statement sudo docker start --net=host -it --name ex_ngninx ubuntu This made it temporarily work but I still couldn’t docker build. A sudo systemctl restart docker fixed it tho – Freedom_Ben Jan 24 at 22:41 所以遇到不能上网的情况可以通过sudo systemctl restart docker解决 root@5acfffe415ce:/# exit exit root@ubuntu:/home/jwl# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5acfffe415ce ubuntu:14.04 \"/bin/bash\" 15 seconds ago Exited (0) 5 seconds ago dreamy_feynman root@ubuntu:/home/jwl# sudo systemctl restart docker root@ubuntu:/home/jwl# docker start 5acff 5acff root@ubuntu:/home/jwl# docker exec -it 5acff bash root@5acfffe415ce:/# ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=127 time=28.2 ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=127 time=27.0 ms 成功","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Docker/"}]},{"title":"分享一个JS中去除指定字符的trim方法","date":"2016-05-08T06:24:25.000Z","path":"2016/05/08/分享一个JS中去除指定字符的trim方法/","text":"说明第一个参数char指定要去除的字符第二个参数type指定左边或右边 代码123456789101112131415161718192021222324252627282930313233343536373839404142String.prototype.trim = function (char, type) &#123; if (char) &#123; if (type == 'left') &#123; return this.replace(new RegExp('^\\\\'+char+'+', 'g'), ''); &#125; else if (type == 'right') &#123; return this.replace(new RegExp('\\\\'+char+'+$', 'g'), ''); &#125; return this.replace(new RegExp('^\\\\'+char+'+|\\\\'+char+'+$', 'g'), ''); &#125; return this.replace(/^\\s+|\\s+$/g, '');&#125;;// 去除字符串首尾的全部空白var str = ' Ruchee ';console.log('xxx' + str.trim() + 'xxx'); // xxxRucheexxx// 去除字符串左侧空白str = ' Ruchee ';console.log('xxx' + str.trim(' ', 'left') + 'xxx'); // xxxRuchee xxx&lt;!--more--&gt;// 去除字符串右侧空白str = ' Ruchee ';console.log('xxx' + str.trim(' ', 'right') + 'xxx'); // xxx Rucheexxx// 去除字符串两侧指定字符str = '/Ruchee/';console.log(str.trim('/')); // Ruchee// 去除字符串左侧指定字符str = '/Ruchee/';console.log(str.trim('/', 'left')); // Ruchee/// 去除字符串右侧指定字符str = '/Ruchee/';console.log(str.trim('/', 'right')); // /Ruchee 参考自：https://segmentfault.com/a/1190000002438098","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"},{"name":"trim","slug":"trim","permalink":"https://github.com/kong36088/kong36088.github.io/tags/trim/"}]},{"title":"jquery-file-upload使用总结","date":"2016-04-30T17:24:25.000Z","path":"2016/05/01/jquery-file-upload使用总结/","text":"123456789101112131415&lt;div class=\"row fileupload-buttonbar\" style=\"padding-left:15px;\"&gt; &lt;div class=\"thumbnail\"&gt; &lt;img id=\"weixin_show\" style=\"height:300px;margin-top:10px;margin-bottom:8px;\" src=\"/uploads/head/head.jpg\" data-holder-rendered=\"true\"&gt; &lt;div class=\"progress progress-striped active\" role=\"progressbar\" aria-valuemin=\"10\" aria-valuemax=\"100\" aria-valuenow=\"0\"&gt; &lt;div id=\"weixin_progress\" class=\"progress-bar progress-bar-success\" style=\"width:0%;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"caption\" align=\"center\"&gt; &lt;span id=\"weixin_upload\" class=\"btn btn-primary fileinput-button\"&gt; &lt;span&gt;上传&lt;/span&gt; &lt;input type=\"file\" id=\"weixin_image\" name=\"weixin_image\" multiple&gt; &lt;/span&gt; &lt;a id=\"weixin_cancel\" href=\"javascript:void(0)\" class=\"btn btn-warning\" role=\"button\" style=\"display:none\"&gt;删除&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526$(\"#weixin_image\").fileupload(&#123; acceptFileTypes: /(\\.|\\/)(gif|jpe?g|png)$/i, maxFileSize: 999000, url: '/data/upload', sequentialUploads: true, previewCrop: true &#125;).on('fileuploadprogress', function (e, data) &#123; var progress = parseInt(data.loaded / data.total * 100, 10); $(\"#weixin_progress\").css('width', progress + '%'); $(\"#weixin_progress\").html(progress + '%'); &#125;).on('fileuploaddone', function (e, data) &#123; d = data.result; console.log(e); console.log(data); if (d.status == 1) &#123; $(\"#weixin_show\").attr(\"src\", d.url); $(\"#weixin_upload\").css(&#123;display: \"none\"&#125;); $(\"#weixin_cancel\").css(&#123;display: \"\"&#125;); &#125; else &#123; alert(d.msg); &#125;&#125;).on('fileuploadfail', function (e, data) &#123; console.log(e); console.log(data); alert(data.msg);&#125;); server端代码，java spring12345678910111213141516@RequestMapping(value = \"/upload\", method = RequestMethod.POST, produces = &#123;\"application/json;charset=UTF-8\"&#125;)@ResponseBodypublic String upload(@RequestParam(\"weixin_image\") MultipartFile multipartFile) throws IOException &#123; JSONObject res = new JSONObject(); if (!multipartFile.isEmpty()) &#123; String preName = \"/uploads/head/\"; String subName = System.currentTimeMillis() + multipartFile.getOriginalFilename(); FileUtils.copyInputStreamToFile(multipartFile.getInputStream(), new File(\"H:\\\\apache-tomcat-9.0.0.M4\\\\webapps\\\\contact\\\\src\\\\main\\\\webapp\\\\WEB-INF\\\\uploads\\\\head\\\\\", subName)); res.put(\"url\", preName+subName); res.put(\"status\", 1); &#125; else &#123; res.put(\"msg\", \"上传失败\"); res.put(\"status\", 0); &#125; return res.toString();&#125; 以上demo是单文件上传，若要开启多文件上传可以把$(&quot;#weixin_upload&quot;).css({display: &quot;none&quot;});这句注释掉","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"},{"name":"file-upload","slug":"file-upload","permalink":"https://github.com/kong36088/kong36088.github.io/tags/file-upload/"}]},{"title":"Laravel中提示Class XXSeeder does not exist解决办法","date":"2016-04-21T06:24:25.000Z","path":"2016/04/21/Laravel中提示Class XXSeeder does not exist解决办法/","text":"在coding的时候写了一个seed，用作填充数据库数据在本地调试的时候没有任何问题，php artisan db:seed 完美运行当把代码上传到服务器进行调试的时候却出现了问题，提示以下错误： [ReflectionException] Class EquipmentSeeder does not exist 在stackoverflow上找到了这个解决方案： You need to put SongsTableSeeder into file SongsTableSeeder.php in the same directory where you have your DatabaseSeeder.php file. And you need to run in your console: composer dump-autoload to generate new class map and then run: php artisan db:seedI’ve just tested it. It is working without a problem in Laravel 5 根据意思就是，要把新建的seeder文件与DatabaseSeeder.php放在同一目录下并且执行命令composer dump-autoload ，问题解决","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"Laravel","slug":"Laravel","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Laravel/"}]},{"title":"PHP中循环foreach小笔记","date":"2016-04-04T06:24:25.000Z","path":"2016/04/04/PHP中循环foreach小笔记/","text":"foreach会保存数组当前的状态，改变$arr对于$v并没有影响即，在下面例子foreach当中，$arr的值会被复制到内存当中，供循环使用，改变$arr的值不会影响$v（注：在$arr中已赋值二维数组） //PHP会复制$arr的值到内存中 foreach ($arr as $k1 =&gt; $v1) { $arr['id']=1; $parent_id = $v1['id']; echo $parent_id; } //输出值：5049484746454443424140393837369143419242913828332318121732227271162621311615351025302015432 如果对$v使用引用，即$v引用$arr中的对应的每一个值，结果将会不同 foreach ($arr as $key =&gt; &amp;$v1) { $arr[$key]['id'] = 1; $parent_id = $v1['id']; echo $parent_id; } //输出：11111111111111111111111111111111111111111111111111","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"JS获取URL中的query string","date":"2016-03-30T06:24:25.000Z","path":"2016/03/30/JS获取URL中的query string/","text":"function getQueryString(key){ var reg = new RegExp(\"(^|&amp;)\"+key+\"=([^&amp;]*)(&amp;|$)\"); var result = window.location.search.substr(1).match(reg); return result?decodeURIComponent(result[2]):null; } //用法： //getQueryString('arg') //getQueryString('test')","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"}]},{"title":"JS刷新页面的几种方式","date":"2016-03-30T06:24:25.000Z","path":"2016/03/30/JS刷新页面的几种方式/","text":"history.go(0) location.reload() location=location location.assign(location) document.execCommand('Refresh') window.navigate(location) location.replace(location) document.URL=location.href","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"}]},{"title":"CSRF攻击以及防范","date":"2016-03-29T06:24:25.000Z","path":"2016/03/29/CSRF攻击以及防范/","text":"CSRF简介CSRF一种网站的攻击方式，黑客利用网站对用户的信任进行伪造请求进而发出非用户发出的请求简而言之，伪造用户的身份发出表单请求 下面看一个例子：一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片src。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。 可见这对于用户或系统都是严重的破坏，造成用户利益损失，账户被盗等。 几种CSRF的防范方法一、 在表单中加入一个cookie的Hash值$value=\"someValueHere\"; setcookie(\"cookie\",$value,time()+3600); &lt;input type=\"hidden\" name=\"hash\" value=\"&lt;?php echo md5($_COOKIE('cookie'));\" /&gt; 服务端的验证 $hash=md5($_COOKIE('cookie')); if($hash==$_POST['hash']){ //验证通过 }else{ //验证不通过 } 二、 验证码在表单域中加入验证码可以杜绝csrf攻击的可能但是这个对于用户体验并不是那么好 三、 加入一个csrf token&lt;input type=\"hidden\" name=\"csrf_token\" value=\"&lt;?php echo $_SESSION['STOKEN_NAME'];?&gt;\"&gt; $pToken = \"\"; if($_SESSION[STOKEN_NAME] == $pToken){ //没有值，赋新值 $_SESSION[STOKEN_NAME] = gen_token(); } else{ //继续使用旧的值 } function gen_token() { //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token = md5(uniqid(rand(), true)); return $token; } 最后对token进行验证 $token=$_POST['csrf_token']; if($token==$_SESSION('STOKEN_NAME')){ //验证通过 }else{ //验证不通过 } 参考 http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.htmlhttp://baike.baidu.com/link?url=IhevG_bwOLXJBLKcOTo-tn19lfk6P70IwOdAJW9FDLMTzSoJumMZr58OwJr20YhpNYcGm9dX-UH3FHzyI0cQr_","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"centos6、centos7通过yum方式安装php7","date":"2016-03-21T06:24:25.000Z","path":"2016/03/21/centos6、centos7通过yum方式安装php7/","text":"安装PHP7如果想要通过yum安装php7的话，根据你的centos的版本进行安装源的类型，从下面的地址进行选择https://mirror.webtatic.com/如果和我一样，是centos6选择https://mirror.webtatic.com/yum/el6/latest.rpm如果是centos7的版本的话，选择https://mirror.webtatic.com/yum/el7/webtatic-release.rpm至于安装方式，也非常简单，centos6下面安装如下 rpm -Uvh https://mirror.webtatic.com/yum/el6/latest.rpmcentos7下面的安装方式 rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm然后就可以安装php7了，安装方式如下 [root@VM_13_18_centos /]# php -v PHP 7.0.4 (cli) (built: Mar 5 2016 00:55:49) ( NTS ) Copyright (c) 1997-2016 The PHP Group Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies with Xdebug v2.4.0RC3, Copyright (c) 2002-2015, by Derick Rethans [root@VM_13_18_centos /]# yum search php70 Loaded plugins: fastestmirror, langpacks Repository epel is listed more than once in the configuration Loading mirror speeds from cached hostfile * webtatic: uk.repo.webtatic.com =============================================================================================== N/S matched: php70 =============================================================================================== php70w.x86_64 : PHP scripting language for creating dynamic web sites php70w-bcmath.x86_64 : A module for PHP applications for using the bcmath library php70w-cli.x86_64 : Command-line interface for PHP php70w-common.x86_64 : Common files for PHP php70w-dba.x86_64 : A database abstraction layer module for PHP applications php70w-devel.x86_64 : Files needed for building PHP extensions php70w-embedded.x86_64 : PHP library for embedding in applications php70w-enchant.x86_64 : Enchant spelling extension for PHP applications php70w-fpm.x86_64 : PHP FastCGI Process Manager php70w-gd.x86_64 : A module for PHP applications for using the gd graphics library php70w-imap.x86_64 : A module for PHP applications that use IMAP php70w-interbase.x86_64 : A module for PHP applications that use Interbase/Firebird databases php70w-intl.x86_64 : Internationalization extension for PHP applications php70w-ldap.x86_64 : A module for PHP applications that use LDAP php70w-mbstring.x86_64 : A module for PHP applications which need multi-byte string handling php70w-mcrypt.x86_64 : Standard PHP module provides mcrypt library support php70w-mysql.x86_64 : A module for PHP applications that use MySQL databases php70w-mysqlnd.x86_64 : A module for PHP applications that use MySQL databases php70w-odbc.x86_64 : A module for PHP applications that use ODBC databases php70w-opcache.x86_64 : An opcode cache Zend extension php70w-pdo.x86_64 : A database access abstraction module for PHP applications php70w-pdo_dblib.x86_64 : MSSQL database module for PHP php70w-pear.noarch : PHP Extension and Application Repository framework php70w-pecl-apcu.x86_64 : APCu - APC User Cache php70w-pecl-apcu-devel.x86_64 : APCu developer files (header) php70w-pecl-imagick.x86_64 : Provides a wrapper to the ImageMagick library php70w-pecl-imagick-devel.x86_64 : Imagick developer files (header) php70w-pecl-xdebug.x86_64 : PECL package for debugging PHP scripts php70w-pgsql.x86_64 : A PostgreSQL database module for PHP php70w-phpdbg.x86_64 : Interactive PHP debugger php70w-process.x86_64 : Modules for PHP script using system process interfaces php70w-pspell.x86_64 : A module for PHP applications for using pspell interfaces php70w-recode.x86_64 : A module for PHP applications for using the recode library php70w-snmp.x86_64 : A module for PHP applications that query SNMP-managed devices php70w-soap.x86_64 : A module for PHP applications that use the SOAP protocol php70w-tidy.x86_64 : Standard PHP module provides tidy library support php70w-xml.x86_64 : A module for PHP applications which use XML php70w-xmlrpc.x86_64 : A module for PHP applications which use the XML-RPC protocol 根据自己需要进行安装，要说明的是，php70w-mysql.x86_64 和php70w-mysqlnd.x86_64 只能够安装其中一个,本地电脑带安装方式 yum install php70w php70w-bcmath php70w-cli php70w-common php70w-dba php70w-devel php70w-embedded php70w-enchant php70w-gd php70w-imap php70w-interbase php70w-intl php70w-ldap php70w-mbstring php70w-mcrypt php70w-mysqlnd php70w-odbc php70w-opcache php70w-pdo php70w-pdo_dblib php70w-pear php70w-pecl-apcu php70w-pecl-apcu-devel php70w-pecl-imagick php70w-pecl-imagick-devel php70w-pecl-xdebug php70w-pgsql php70w-phpdbg php70w-process php70w-pspell php70w-recode php70w-snmp php70w-soap php70w-tidy php70w-xml php70w-xmlrpc 附：centos下编译安装PHP所需环境#c和c++编译器 yum install -y gcc gcc-c++ #PHP扩展依赖 yum install -y libxml2-devel openssl-devel libcurl-devel libjpeg-devel libpng-devel libicu-devel openldap-devel","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"PHP7","slug":"PHP7","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP7/"}]},{"title":"Nginx反向代理配置（负载均衡）","date":"2016-03-10T06:24:25.000Z","path":"2016/03/10/Nginx反向代理配置（负载均衡）/","text":"负载均衡分配 根据ip轮询： upstream backend { server 192.168.102.143; server 192.168.102.144; } 根据ip的hash值分配（轮询）： upstream backend { ip_hash; server 192.168.102.143; server 192.168.102.144; } 根据权值分配： upstream hello{ server 192.168.102.143 weight=1; server 192.168.102.144 weight=1; } 最少连接数： upstream hello{ least_conn; server 192.168.102.143; server 192.168.102.144; } 完整文件的配置 #负责压缩数据流 worker_processes 1; events { worker_connections 1024; } gzip on; gzip_min_length 1000; gzip_types text/plain text/css application/x-javascript; #设定负载均衡的服务器列表 upstream backend { server 192.168.102.143; server 192.168.102.144; } server { #侦听的80端口 listen 80; server_name localhost; #设定查看Nginx状态的地址 location /nginxstatus{ stub_status on; access_log on; auth_basic \"nginxstatus\"; auth_basic_user_file htpasswd; } #匹配以jsp结尾的，tomcat的网页文件是以jsp结尾 location / { index index.jsp; proxy_pass http://backend; #在这里设置一个代理，和upstream的名字一样 #以下是一些反向代理的配置可删除 proxy_redirect off; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 proxy_connect_timeout 300; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 300; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 300; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 } } 配置完成后，重启nginx： service nginx restart 参考文章：http://www.cnblogs.com/sixiweb/p/3988805.htmlhttp://www.jb51.net/article/60523.htm","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Nginx/"}]},{"title":"PHP中的自动加载函数","date":"2016-03-04T06:24:25.000Z","path":"2016/03/04/PHP中的自动加载函数/","text":"对于大多数框架中，都会使用spl_autoload_register函数，而不使用__autoload函数 在官方文档的解释是这样的： If there must be multiple autoload functions, spl_autoload_register() allows for this. It effectively creates a queue of autoload functions, and runs through each of them in the order they are defined. By contrast, __autoload() may only be defined once. spl_autoload_register 可以很好地处理需要多个加载器的情况，这种情况下 spl_autoload_register 会按顺序依次调用之前注册过的加载器。作为对比， __autoload 因为是一个函数，所以只能被定义一次。 __autoload只能被定义一次，自然spl_autoload_register更好用 以下是代码： Main.php &lt;?php class Loader { public static function load($class) { $file = $class . '.class.php'; if (is_file ( $file )) { include ($file); } } } spl_autoload_register(array('Loader','load')); /* 替代方法 function __autoload($class){ $file = $class . '.class.php'; if (is_file ( $file )) { include ($file); } } */ $main=new Class1(); $main-&gt;index(); $main=new Class2(); $main-&gt;index(); Class1.class.php &lt;?php class Class1{ public function index(){ echo \"Class Class1 function index here\\n\"; } } Class2.class.php &lt;?php class Class2{ public function index(){ echo \"Class Class2 function index here\\n\"; } } 运行Main.php输出： Class Class1 function index here class Class2 function index here","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"使用Nginx、Nginx Plus抵御DDOS攻击","date":"2016-03-02T06:24:25.000Z","path":"2016/03/02/使用Nginx、Nginx Plus抵御DDOS攻击/","text":"DDOS是一种通过大流量的请求对目标进行轰炸式访问，导致提供服务的服务器资源耗尽进而无法继续提供服务的攻击手段。 一般情况下，攻击者通过大量请求与连接使服务器处于饱和状态，以至于无法接受新的请求或变得很慢。 应用层DDOS攻击的特征应用层（七层/HTTP层）DDOS攻击通常由木马程序发起，其可以通过设计更好的利用目标系统的脆弱点。例如，对于无法处理大量并发请求的系统，仅仅通过建立大量的连接，并周期性的发出少量数据包来保持会话就可以耗尽系统的资源，使其无法接受新的连接请求达到DDOS的目的。其他还有采用发送大量连接请求发送大数据包的请求进行攻击的形式。因为攻击是由木马程序发起，攻击者可以在很短时间内快速建立大量的连接，并发出大量的请求。 以下是一些DDOS的特证，我们可以据此特征来抵抗DDOS（包括但不限于）：攻击经常来源于一些相对固定的IP或IP段，每个IP都有远大于真实用户的连接数和请求数。备注：这并不表明这种请求都是代表着DDOS攻击。在很多使用NAT的网络架构中，很多的客户端使用网关的IP地址访问公网资源。但是，即便如此，这样的请求数和连接数也会远少于DDOS攻击。因为攻击是由木马发出且目的是使服务器超负荷，请求的频率会远远超过正常人的请求。User-Agent通常是一个非标准的值Referer有时是一个容易联想到攻击的值 使用Nginx、Nginx Plus抵抗DDOS攻击结合上面提到的DDOS攻击的特征，Nginx、Nginx Plus有很多的特性可以用来有效的防御DDOS攻击，可以从调整入口访问流量和控制反向代理到后端服务器的流量两个方面来达到抵御DDOS攻击的目的。 限制请求速度 设置Nginx、Nginx Plus的连接请求在一个真实用户请求的合理范围内。比如，如果你觉得一个正常用户每两秒可以请求一次登录页面，你就可以设置Nginx每两秒钟接收一个客户端IP的请求（大约等同于每分钟30个请求）。 limit_req_zone $binary_remote_addr zone=one:10m rate=30r/m; server { ... location /login.html { limit_req zone=one; ... } } limit_req_zone命令设置了一个叫one的共享内存区来存储请求状态的特定键值，在上面的例子中是客户端IP($binary_remote_addr)。location块中的limit_req通过引用one共享内存区来实现限制访问/login.html的目的。 限制连接数量设置Nginx、Nginx Plus的连接数在一个真实用户请求的合理范围内。比如，你可以设置每个客户端IP连接/store不可以超过10个。 limit_conn_zone $binary_remote_addr zone=addr:10m; server { ... location /store/ { limit_conn addr 10; ... } } limit_conn_zone命令设置了一个叫addr的共享内存区来存储特定键值的状态，在上面的例子中是客户端IP（ $binary_remote_addr）。location块中limit_conn通过引用addr共享内存区来限制到/store/的最大连接数为10。 关闭慢连接有一些DDOS攻击，比如Slowlris，是通过建立大量的连接并周期性的发送一些数据包保持会话来达到攻击目的，这种周期通常会低于正常的请求。这种情况我们可以通过关闭慢连接来抵御攻击。 client_body_timeout命令用来定义读取客户端请求的超时时间，client_header_timeout命令用来定于读取客户端请求头的超时时间。这两个参数的默认值都是60s，我们可以通过下面的命令将他们设置为5s： server { client_body_timeout 5s; client_header_timeout 5s; ... } 设置IP黑名单如果确定攻击来源于某些IP地址，我们可以将其加入黑名单，Nginx就不会再接受他们的请求。比如，你已经确定攻击来自于从123.123.123.1到123.123.123.16的一段IP地址，你可以这样设置： location / { deny 123.123.123.0/28; ... } 或者你确定攻击来源于123.123.123.3、123.123.123.5、123.123.123.7几个IP，可以这样设置： location / {deny 123.123.123.3;deny 123.123.123.5;deny 123.123.123.7;…} 设置IP白名单如果你的网站仅允许特定的IP或IP段访问，你可以结合使用allow和deny命令来限制仅允许你指定的IP地址访问你的网站。如下，你可以设置仅允许192.168.1.0段的内网用户访问： location / { allow 192.168.1.0/24; deny all; ... } deny命令会拒绝除了allow指定的IP段之外的所有其他IP的访问请求。 使用缓存进行流量削峰通过打开Nginx的缓存功能并设置特定的缓存参数，可以削减来自攻击的流量，同时也可以减轻对后端服务器的请求压力。以下是一些有用的设置：proxy_cache_use_stale的updating参数告诉Nginx什么时候该更新所缓存的对象。只需要到后端的一个更新请求，在缓存有效期间客户端对该对象的请求都无需访问后端服务器。当通过对一个文件的频繁请求来实施攻击时，缓存功能可极大的降低到后端服务器的请求。proxy_cache_key命令定义的键值通常包含一些内嵌的变量（默认的键值$scheme$proxy_host$request_uri包含了三个变量）。如果键值包含$query_string变量，当攻击的请求字符串是随机的时候就会给Nginx代理过重的缓存负担，因此我们建议一般情况下不要包含$query_string变量。 屏蔽特定的请求可以设置Nginx、Nginx Plus屏蔽一些类型的请求：针对特定URL的请求针对不是常见的User-Agent的请求针对Referer头中包含可以联想到攻击的值的请求针对其他请求头中包含可以联想到攻击的值的请求 比如，如果你判定攻击是针对一个特定的URL：/foo.php，我们就可以屏蔽到这个页面的请求： location /foo.php { deny all; } 或者你判定攻击请求的User-Agent中包含foo或bar，我们也可以屏蔽这些请求： location / { if ($http_user_agent ~* foo|bar) { return 403; } ... } http_name变量引用一个请求头，上述例子中是User-Agent头。可以针对其他的http头使用类似的方法来识别攻击。 限制到后端服务器的连接数一个Nginx、Nginx Plus实例可以处理比后端服务器多的多的并发请求。在Nginx Plus中，你可以限制到每一个后端服务器的连接数，比如可以设置Nginx Plus与website upstream中的每个后端服务器建立的连接数不得超过200个： upstream website { server 192.168.100.1:80 max_conns=200; server 192.168.100.2:80 max_conns=200; queue 10 timeout=30s; } max_conns参数可以针对每一个后端服务器设置Nginx Plus可以与之建立的最大连接数。queue命令设置了当每个后端服务器都达到最大连接数后的队列大小，timeout参数指定了请求在队列中的保留时间。 处理特定类型的攻击有一种攻击是发送包含特别大的值的请求头，引起服务器端缓冲区溢出。Nginx、Nginx Plus针对这种攻击类型的防御，可以参考Using NGINX and NGINX Plus to Protect Against CVE-2015-1635 优化Nginx性能DDOS攻击通常会带来高的负载压力，可以通过一些调优参数，提高Nginx、Nginx Plus处理性能，硬抗DDOS攻击，详细参考：Tuning NGINX for Performance 识别DDOS攻击到目前为止，我们都是集中在如何是用Nginx、Nginx Plus来减轻DDOS攻击带来的影响。如何才能让Nginx、Nginx Plus帮助我们识别DDOS攻击呢？Nginx Plus Status module提供了到后端服务器流量的详细统计，可以用来识别异常的流量。Nginx Plus提供一个当前服务状态的仪表盘页面，同时也可以在自定义系统或其他第三方系统中通过API的方式获取这些统计信息，并根据历史趋势分析识别非正常的流量进而发出告警。 总结Nginx和Nginx Plus可以作为抵御DDOS攻击的一个有力手段，而且Nginx Plus中提供了一些附加的特性来更好的抵御DDOS攻击并且当攻击发生时及时的识别到。 原文地址：http://mp.weixin.qq.com/s?__biz=MzA3MzYwNjQ3NA==&amp;mid=208998983&amp;idx=1&amp;sn=57c74bef6c19227660236fff74557c50&amp;scene=1&amp;srcid=1016w7ZDYGI9DVkRNtr8fNis&amp;from=groupmessage&amp;isappinstalled=0#wechat_redirect译者：陈洋 (运维帮)","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Nginx/"}]},{"title":"PHP的魔术方法（下）","date":"2016-02-25T15:24:25.000Z","path":"2016/02/25/PHP的魔术方法（下）/","text":"sleep和wakeup serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。serialize — 产生一个可存储的值的表示。 __toString __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 __invoke 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 __set_state 自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。 __debugInfo 当尝试使用var_dump()打印出对象时，如果没有定义该魔术方法，PHP会打印出所有public，protected，private属性 &lt;?php class Train2 { public $public_num = 1; protected $protected_num = 2; private $private_num = 3; public function __sleep() { return array ( 'public_num' ); } public function __wakeup() { echo __CLASS__ . \" wakeup\\n\"; } public function __invoke() { echo \"invoke here\\n\"; } public function __toString() { return __CLASS__ . \" to string \\n\"; } public function __debugInfo() { return [ 'public_num' =&gt; $this-&gt;public_num * 100 ]; } public static function __set_state() { $obj = new Train2 (); $obj-&gt;public_num = 999; return $obj; } } $train = new Train2 (); // serialize — 产生一个可存储的值的表示(via php手册) $serial = serialize ( $train ); echo \"serial value: \" . $serial . \"\\n\"; unset ( $train ); $train = unserialize ( $serial ); echo $train (); echo $train; var_dump ( $train ) . \"\\n\"; eval ( '$val=' . var_export ( $train, true ) . ';' ); echo var_export ( $val ) . \"\\n\"; 输出： root@ubuntu:/var/www/html/train# php Train2.php serial value: O:6:\"Train2\":1:{s:10:\"public_num\";i:1;} Train2 wakeup invoke here Train2 to string object(Train2)#1 (1) { [\"public_num\"]=&gt; int(100) } Train2::__set_state(array( 'public_num' =&gt; 999, 'protected_num' =&gt; 2, 'private_num' =&gt; 3, )) 参考自PHP手册","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"PHP的魔术方法（上）","date":"2016-02-25T06:24:25.000Z","path":"2016/02/25/PHP的魔术方法（上）/","text":"PHP所提供的”重载”（overloading）是指动态地”创建”类属性和方法。我们是通过魔术方法（magic methods）来实现的。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。本节后面将使用”不可访问属性（inaccessible properties）”和”不可访问方法（inaccessible methods）”来称呼这些未定义或不可见的类属性或方法。 所有的重载方法都必须被声明为 public。 在给不可访问属性赋值时，__set() 会被调用。 读取不可访问属性的值时，__get() 会被调用。 当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问属性调用 unset() 时，__unset() 会被调用。 &lt;?php class Train { public $public_num = 999; private $private_num = 1; public function __construct(){ echo __CLASS__.\" construct\\n\"; } public function __clone() { echo __CLASS__ . \" is cloned\\n\"; } public function __get($name) { echo \"Get {$name} \"; return $this-&gt;$name; } public function __set($name, $value) { echo \"Set {$name}\\n\"; $this-&gt;$name = $value; } public function __destruct(){ echo __CLASS__.\" destruct\\n\"; } public function __isset($name){ echo \"judging {$name}\\n\"; if(empty($this-&gt;$name)){ return false; }else{ return true; } } public function __unset($name){ echo \"unset {$name}\\n\"; } } $train1 = new Train (); $train2 = clone $train1; echo $train1-&gt;private_num . \"\\n\"; $train2-&gt;private_num = 666; echo $train2-&gt;private_num . \"\\n\"; echo $train1-&gt;public_num . \"\\n\"; if(empty($train1-&gt;private_num)){ echo '$private_num isn\\'t set'.\"\\n\"; }else{ echo '$private_num is set'.\"\\n\"; } unset($train1-&gt;private_num); 测试结果： root@ubuntu:/var/www/html/train# php Train.php Train construct Train is cloned Get private_num 1 Set private_num Get private_num 666 999 judging private_num Get private_num $private_num is set unset private_num Train destruct Train destruct","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"Centos升级php版本","date":"2016-02-20T06:24:25.000Z","path":"2016/02/20/Centos升级php版本/","text":"默认的版本太低了，手动安装有一些麻烦，想采用Yum安装的可以使用下面的方案： 检查当前安装的PHP包 yum list installed | grep php 如果有安装的PHP包，先删除他们 yum remove php.x86_64 php-cli.x86_64 php-common.x86_64 php-gd.x86_64 php-ldap.x86_64 php-mbstring.x86_64 php-mcrypt.x86_64 php-mysql.x86_64 php-pdo.x86_64 Centos 5.X rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpm CentOs 6.x rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm CentOs 7.X rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 如果想删除上面安装的包，重新安装rpm -qa | grep webstaticrpm -e 上面搜索到的包即可 运行yum install yum install php55w.x86_64 php55w-cli.x86_64 php55w-common.x86_64 php55w-gd.x86_64 php55w-ldap.x86_64 php55w-mbstring.x86_64 php55w-mcrypt.x86_64 php55w-mysql.x86_64 php55w-pdo.x86_64 yum install php56w.x86_64 php56w-cli.x86_64 php56w-common.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 注：如果想升级到5.6把上面的55w换成56w就可以了。 yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_644.安装PHP FPMyum install php55w-fpmyum install php56w-fpmyum install php70w-fpm注：如果想升级到5.6把上面的55w换成56w就可以了。 转自vb2005xu","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Centos/"}]},{"title":"搭建一个简单的git服务器","date":"2016-02-15T06:24:25.000Z","path":"2016/02/15/搭建一个简单的git服务器/","text":"在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 git server配置安装 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.git Cloning into 'sample'... warning: You appear to have cloned an empty repository. 剩下的就是普通的git操作了，如果对git操作有陌生的可以参考这里。 如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 Gitosis配置相关： 一、架设步骤 下载并安装python setuptoolssudo apt-get install python-setuptools 下载并安装gitosiscd ~/src git clone https://github.com/res0nat0r/gitosis.git cd gitosis python setup.py install 添加用户gitsudo adduser \\ --system \\ --shell /bin/sh \\ --gecos 'git version control' \\ --group \\ --disabled-password \\ --home /home/git \\ git 生成本机密钥切换到个人机，如果已有~/.ssh/id_rsa.pub略过此步ssh-keygen -t rsa 上传密钥到服务器临时目录scp ~/.ssh/id_rsa.pub 用户名@主机:/tmp 初使化gitosis切回到服务器sudo -H -u git gitosis-init &lt; /tmp/id_rsa.pub 修改post-update权限sudo chmod 755 /home/git/repositories/gitosis-admin.git/hooks/post-update clone gitosis管理平台git clone git@主机名:gitosis-admin.git cd gitosis-admin 安装完成通过修改gitosis-admin管理gitosis用户权限添加公密到keydir，添加用户修改完后commit，push到中服务器即可完成仓库权限的相关操作。 二、实例 用户john添加并发送id_rsa.pub给miao目标：添加用户 john 和仓库 foo 到gitosis，并和管理员miao合作管理john:~$ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/home/john/.ssh/id_rsa): Created directory '/home/john/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/john/.ssh/id_rsa. Your public key has been saved in /home/john/.ssh/id_rsa.pub. john:~$ cp /home/john/.ssh/id_rsa.pub /tmp gitosis管理员miao分配john权限miao:~$ cd ~/projects git clone git@192.168.1.115:gitosis-admin cd gitosis-admin cat gitosis.conf [gitosis] [group gitosis-admin] writable = gitosis-admin members = miao@u32-192-168-1-110 ls keydir/ miao@u32-192-168-1-110.pub cp /tmp/id_rsa.pub keydir/john.pub vi gitosis.conf [gitosis] [group gitosis-admin] writable = gitosis-admin members = miao@u32-192-168-1-110 [group foo] writable = foo members = miao@u32-192-168-1-110 john git add . git commit -am \"add member john and project foo\" git push 用户 miao 添加项目foomiao:~$ cd ~/projects mkdir foo cd foo git init touch hello.txt git add hello.txt git commit -am 'first commit' git remote add origin git@192.168.1.115:foo.git git push origin master 用户 john clone Foo并修改hello.txtjohn:~$ git clone git@192.168.1.115:foo.git cd foo ls date &gt; hello.txt git commit -am 'add time to hello.txt' &amp;&amp; git push 用户 miao pull Foomiao:~/projects/foo$ vi .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true [remote \"origin\"] url = git@192.168.1.115:foo.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master git pull 三、常见问题首先确定 /home/git/repositories/gitosis-admin.git/hooks/post-update 为可执行即属性为 0755 git操作需要输入密码原因公密未找到解决上传id_pub.rsa到keydir并改为’gitosis帐号.pub’形式，如miao.pub。扩展名.pub不可省略 ERROR:gitosis.serve.main:Repository read access denied原因gitosis.conf中的members与keydir中的用户名不一致，如gitosis中的members = foo@bar，但keydir中的公密名却叫foo.pub解决使keydir的名称与gitosis中members所指的名称一致。改为members = foo 或 公密名称改为foo@bar.pub 参考文章地址： http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000http://blog.csdn.net/king_sundi/article/details/7065525","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"}]},{"title":"python百度图片爬虫","date":"2016-02-06T06:24:25.000Z","path":"2016/02/06/python百度图片爬虫/","text":"花了一晚时间写了一个百度图片的爬虫，可以搜索任意关键字python2.7对于中文的支持实在是十分之蛋疼对于出现异常的情况处理的并不是很完美，等待后续处理getImagesURL(max_number, word) max_number是要抓取图片的数量，word是搜索的关键字 #!/usr/bin/env python # -*- coding:utf-8 -*- import os import urllib import json from urllib import quote import socket import sys reload(sys) sys.setdefaultencoding('utf-8') #设置超时 socket.setdefaulttimeout(10) counter=1 # 获取图片url内容等 def getImagesURL(max_number, word='美女'): search = quote(word) pn = 0 while pn &lt;= max_number: global counter url = 'http://image.baidu.com/search/avatarjson?tn=resultjsonavatarnew&amp;ie=utf-8&amp;word=' + search + '&amp;cg=girl&amp;pn=' + str(pn) + '&amp;rn=60&amp;itg=0&amp;z=0&amp;fr=&amp;width=&amp;height=&amp;lm=-1&amp;ic=0&amp;s=0&amp;st=-1&amp;gsm=1e0000001e' page = urllib.urlopen(url) data = page.read() data = json.loads(data) saveImage(data, word) pn += 60 # 保存图片 def saveImage(json, word): global counter if not os.path.exists(\"./\" + word): os.mkdir(\"./\" + word) #判断名字是否重复 index=len(os.listdir('./'+word)) if os.path.exists(\"./\"+word+\"/\"+str(counter)+\".jpeg\"): counter=index check='&lt;html&gt;&lt;body&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;' for info in json['imgs']: urllib.urlretrieve(info['objURL'], './' + word + '/' + str(counter) +'.jpeg') #判断防爬虫 &lt;html&gt;&lt;body&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt; fp=open(\"./\"+word+\"/\"+str(counter)+\".jpeg\") if not cmp(fp.readline(),'&lt;html&gt;&lt;body&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;\\n'): os.remove(\"./\"+word+\"/\"+str(counter)+\".jpeg\") counter-=1 fp.close() counter += 1 print \"小黄图+1，已经保存\"+str(counter-1)+\"张小黄图\\n\" return counter #获取后缀名 def getFix(name): return name[name.find('.'):] #获取前缀 def getPrefix(name): return name[:name.find('.')] #print getFix('123.txt') #getImagesURL(390,'美女') getImagesURL(240,'二次元') #getImagesURL(360,'帅哥') 效果图","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/kong36088/kong36088.github.io/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Python/"}]},{"title":"微信客服接口（主动向用户推送消息）","date":"2016-01-30T15:50:25.000Z","path":"2016/01/30/微信客服接口（主动向用户推送消息）/","text":"function http_post_data($url, $data) { $curl = curl_init (); curl_setopt ( $curl, CURLOPT_URL, $url ); curl_setopt ( $curl, CURLOPT_SSL_VERIFYPEER, FALSE ); curl_setopt ( $curl, CURLOPT_SSL_VERIFYHOST, FALSE ); curl_setopt ( $curl, CURLOPT_POST, 1 ); curl_setopt ( $curl, CURLOPT_POSTFIELDS, $data ); curl_setopt ( $curl, CURLOPT_RETURNTRANSFER, 1 ); $result = curl_exec ( $curl ); if (curl_errno ( $curl )) { return 'Errno' . curl_error ( $curl ); } curl_close ( $curl ); return $result; } $url = 'https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=' . ACCESS_TOKEN; $data = json_encode ( array ( \"touser\" =&gt; \"oUc9GvzIY4ZZkb5yxIY8zGTUS0kI\", \"msgtype\" =&gt; \"text\", \"text\" =&gt; array ( \"content\" =&gt; \"abc\" ) ) ); http_post_data($url,$data); 这里是利用curl来post数据到微信的服务器，其中需要access_token的支持，以下是access_token获取的方法 function get_access_token() { $values = json_decode ( file_get_contents ( 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=' . APPID . '&amp;secret=' . APPSECRET ) ); if ($values) { $access_token = $values-&gt;access_token; return $access_token; } else { return false; } }","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"微信","slug":"微信","permalink":"https://github.com/kong36088/kong36088.github.io/tags/微信/"}]},{"title":"ubuntu下apache开启SSL提示443端口被占用","date":"2016-01-30T15:24:25.000Z","path":"2016/01/30/ubuntu下apache开启SSL提示443端口被占用/","text":"You guys are going to laugh at this. I had an extra Listen 443 in ports.conf that shouldn’t have been there. Removing that solved this. 因为在ports.conf中重复出现443端口的配置，所以做以下修改把多余的Listen 443注释掉，所以ports.conf的内容应该是这样的 NameVirtualHost *:80 Listen 80 NameVirtualHost *:443 #Listen 443 &lt;IfModule mod_ssl.c&gt; Listen 443 &lt;/IfModule&gt; &lt;IfModule mod_gnutls.c&gt; Listen 443 &lt;/IfModule&gt; 另外在虚拟服务器中不要加 NameVirtualHost *:443","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"微信支付的经验总结","date":"2016-01-30T06:24:25.000Z","path":"2016/01/30/微信支付的经验总结/","text":"在这次微信支付开发过程中总共遇到过两种错误 1.要记得把微信支付授权精确到二级或者三级目录，并且保证支付调用的页面和支付接口API一致2.要把timestamp类型转换为string类型3.如果要保证代码逻辑控制器之间的分离但是又要保证支付的域名统一，可以使用路由功能将路径重定向 苹果的点击选择功能有一个坑就是，在元素内需要加一个css属性： cursor:pointer","tags":[{"name":"微信","slug":"微信","permalink":"https://github.com/kong36088/kong36088.github.io/tags/微信/"},{"name":"随笔","slug":"随笔","permalink":"https://github.com/kong36088/kong36088.github.io/tags/随笔/"}]},{"title":"ubuntu设置系统时间与网络同步（转）","date":"2016-01-06T08:24:25.000Z","path":"2016/01/06/ubuntu设置系统时间与网络同步/","text":"Linux的时间分为System Clock（系统时间）和Real Time Clock （硬件时间，简称RTC）。 系统时间：指当前Linux Kernel中的时间。 硬件时间：主板上有电池供电的时间。 查看系统时间的命令： #date 设置系统时间的命令： #date –set（月/日/年 时：分：秒） 例：#date –set “10/11/10 10:15” 查看硬件时间的命令： # hwclock 设置硬件时间的命令： # hwclock –set –date = （月/日/年 时：分：秒） 上述提到的是手动设置时间到一个时间点，可能与当前网络的时间有误差。下面介绍一下与时间服务器上的时间同步的方法 安装ntpdate工具# sudo apt-get install ntpdate 设置系统时间与网络时间同步# ntpdate cn.pool.ntp.org 将系统时间写入硬件时间# hwclock --systohc","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"微信网页授权的巨坑","date":"2016-01-06T06:24:25.000Z","path":"2016/01/06/微信网页授权的巨坑/","text":"微信授权记得在下面填写授权的要授权的URL！！！授权的URL记得不要加http！！！！！授权的URL记得不要加http！！！！！授权的URL记得不要加http！！！！！","tags":[{"name":"微信","slug":"微信","permalink":"https://github.com/kong36088/kong36088.github.io/tags/微信/"},{"name":"随笔","slug":"随笔","permalink":"https://github.com/kong36088/kong36088.github.io/tags/随笔/"}]},{"title":"PHP三种POST数据的方式","date":"2015-12-28T08:24:25.000Z","path":"2015/12/28/PHP三种POST数据的方式/","text":"第一种 $_POST这种方式只能够接收Content-type为application/x-www-form-urlencoded提交的数据这种方式提交server会自动将数据转为key=&gt;value的方式 第二种 $GLOBALS[‘HTTP_RAW_POST_DATA’]总是产生 $HTTP_RAW_POST_DATA 变量包含有原始的 POST 数据。此变量仅在碰到未识别 MIME 类型的数据时产生。$HTTP_RAW_POST_DATA 对于 enctype=”multipart/form-data” 表单数据不可用如果post过来的数据不是PHP能够识别的，可以用 $GLOBALS[‘HTTP_RAW_POST_DATA’]来接收，比如 text/xml 或者 soap 等等 第三种 file_get_contents(“php://input”)允许读取 POST 的原始数据。和 $HTTP_RAW_POST_DATA 比起来，它给内存带来的压力较小，并且不需要任何特殊的 php.ini 设置。php://input 不能用于 enctype=”multipart/form-data”。这一种接受原始数据的方式优于第二种方式，推荐使用该方法接受POST数据 参考自——here","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"ubuntu安装swoole拓展","date":"2015-12-28T06:24:25.000Z","path":"2015/12/28/ubuntu安装swoole拓展/","text":"1安装swoole：可pecl直接在线安装，或下载 releases版本的swoole编译安装2.11编译安装swoole扩展 从此处下载： http://pecl.php.net/package/swoole # cd swoole # phpize # ./configure # make &amp;&amp; make install 2.pecl安装swoole扩展 pecl不可用的请确认php安装目录的bin目录已加入系统变量 用pecl方式来安装 zzs@ubuntu:~$ sudo pecl install swoole downloading swoole-1.7.8.tgz … Starting to download swoole-1.7.8.tgz (412,906 bytes) ….done: 412,906 bytes 130 source files, building running: phpize sh: 1: phpize: not found If the command failed with ‘phpize: not found’ then you need to install php5-dev packageYou can do it by running ‘apt-get install php5-dev’ as a root userERROR: `phpize’ failed zzs@ubuntu:~$ sudo apt-get install php5-dev 正在读取软件包列表… 完成 正在分析软件包的依赖关系树 正在读取状态信息… 完成 将会安装下列额外的软件包： pkg-php-tools shtool 建议安装的软件包： dh-make 下列【新】软件包将被安装： php5-dev pkg-php-tools shtool 升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 13 个软件包未被升级。 需要下载 0 B/527 kB 的软件包。 解压缩后会消耗掉 4,431 kB 的额外空间。 您希望继续执行吗？ [Y/n] y … install ok: channel://pecl.php.net/swoole-1.7.8 configuration option “php_ini” is not set to php.ini location You should add “extension=swoole.so” to php.ini zzs@ubuntu:~$ sudo vim /etc/php5/mods-available/swoole.ini 里面加入内容 ; configuration for php Swoole module extension=swoole.so php -m | grep swoole 此时还没有swoole模块 sudo ln -s /etc/php5/mods-available/swoole.ini /etc/php5/cli/conf.d/20-swoole.ini 下面两行酌情使用 sudo ln -s /etc/php5/mods-available/swoole.ini /etc/php5/apache2/conf.d/20-swoole.ini sudo ln -s /etc/php5/mods-available/swoole.ini /etc/php5/fpm/conf.d/20-swoole.ini php -m | grep swoole swoole 测试扩展 server.php: on('connect', function ($serv, $fd){ echo \"Client:Connect.\\n\"; }); $serv-&gt;on('receive', function ($serv, $fd, $from_id, $data) { $serv-&gt;send($fd, 'Swoole: '.$data); }); $serv-&gt;on('close', function ($serv, $fd) { echo \"Client: Close.\\n\"; }); $serv-&gt;start(); ?&gt; client.php: on(\"connect\", function($cli) { $cli-&gt;send(\"hello world\\n\"); }); $client-&gt;on(\"receive\", function($cli, $data){ echo \"Receive: $data\\n\"; }); $client-&gt;on(\"error\", function($cli){ echo \"connect fail\\n\"; }); $client-&gt;on(\"close\", function($cli){ echo \"close\\n\"; }); $client-&gt;connect('127.0.0.1', 9501, 0.5); ?&gt;","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"ubuntu在遇到一直停留在waiting for headers的解决办法","date":"2015-12-26T06:24:25.000Z","path":"2015/12/26/ubuntu在遇到一直停留在waiting for headers的解决办法/","text":"新装了一个ubuntu kylin15.10，在更换成阿里的源之后，前面的update和install都非常的顺畅但是在安装phpmyadmin的时候却一直在waiting for headers网上说可以rm -rvf /var/cache/apt/archives但是除了重新加载到79%然后继续waiting之外毫无作用最后看了下install的过程，发现 Get:12 http://mirrors.hust.edu.cn/ubuntu/ wily-security/main php5-mysql amd64 5.6.11+dfsg-1ubuntu3.1 [65.3 kB] 最后通过取消Software&amp;Updates-&gt;other software里面所有源的钩子，再执行 sudo apt-get update 搞定","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"JS时间格式化","date":"2015-12-15T06:24:25.000Z","path":"2015/12/15/JS时间格式化/","text":"javascript时间格式化 // 对Date的扩展，将 Date 转化为指定格式的String // 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， // 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) // 例子： // (new Date()).Format(\"yyyy-MM-dd hh:mm:ss.S\") ==&gt; 2015-07-02 08:09:04.423 // (new Date()).Format(\"yyyy-M-d h:m:s.S\") ==&gt; 2015-7-2 8:9:4.18 Date.prototype.Format = function(fmt) { var o = { \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 }; if(/(y+)/.test(fmt)) fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o) if(new RegExp(\"(\"+ k +\")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); return fmt; }","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"},{"name":"时间","slug":"时间","permalink":"https://github.com/kong36088/kong36088.github.io/tags/时间/"}]},{"title":"无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系 解决办法","date":"2015-12-04T06:24:25.000Z","path":"2015/12/04/无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系 解决办法/","text":"ubuntu下apt-get install安装软件， 报“无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系”，今天终于找到解决方法了。 一般出现这种情况的原因时 要装A， 依赖B, 但是已经安装的软件C也依赖B， 但是A依赖的B的版本和C依赖的B的版本不一致， 导致了如果要安装B，那么C便不能正常运行了，所以系统报错，组织安装B。 那么解决方法就是： 安装指定版本号的B。 例如 我今天 sudo apt-get install subversion 系统报错如下： 下列软件包有未满足的依赖关系： subversion : 依赖: libsvn1 (= 1.8.8-1ubuntu3) 但是 1.8.8-1ubuntu3.1 正要被安装E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 解决方法如下： sudo apt-get install libsvn1=1.8.8-1ubuntu3 ， 这样可以制定libsvn的版本安装，安装成功后， 在运行sudo apt-get install subversion 就可以安装了。 其他遇到类似问题的同学们可以试一下： 根据报错的信息 “subversion : 依赖: libsvn1 (= 1.8.8-1ubuntu3) 但是 1.8.8-1ubuntu3.1 正要被安装” 那么只需要sudo apt-get install xxx=yyy (xxx为提示信息的libsvn1， yyy为提示错误的1.8.8-1ubuntu3) 原文：http://blog.csdn.net/smallmao/article/details/45626555","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"Linux下PHP源码编译安装","date":"2015-11-30T06:24:25.000Z","path":"2015/11/30/Linux下PHP源码编译安装/","text":"要用swoole，首先需要有PHP环境。由于swoole的某些特性，最好是能够从源码编译安装PHP，这样在使用过程中可以避免很多不必要的错误。PHP下载地址：PHP官网在这里挑选你想用的版本即可。下载源码包后，解压至本地任意目录（保证读写权限），留待使用。安装PHP前，需要安装编译环境和PHP的相关依赖。下面是相关命令：Ubuntu环境下：sudo apt-get install build-essential gcc g++ autoconf libiconv-hook-dev libmcrypt-dev libxml2-dev libmysqlclient-dev libcurl4-openssl-dev libjpeg8-dev libpng12-dev libfreetype6-devCentOS环境下：yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers gd gd2 gd-devel gd2-devel perl-CPAN pcre-devel（注：以上命令是我在实际使用中验证过的可以使用的，可能会和其他教程提供的命令不同）当上述命令执行后，即可开始安装PHP。命令如下： cd php-5.5.10/ ./configure --prefix=/usr/local/php --with-config-file-path=/etc/php --enable-fpm --enable-pcntl --enable-mysqlnd --enable-opcache --enable-sockets --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-shmop --enable-zip --enable-ftp --enable-soap --enable-xml --enable-mbstring --disable-rpath --disable-debug --disable-fileinfo --with-mysql=mysqlnd --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-pcre-regex --with-iconv --with-zlib --with-mcrypt --with-gd --with-openssl --with-mhash --with-xmlrpc --with-curl --with-imap-ssl sudo make sudo make install sudo cp php.ini-development /etc/php/ 至此，PHP已经成功安装，但是此时在终端里是无法直接通过php –version查看php版本的还需要将PHP的可执行目录添加到环境变量中。使用Vim/Sublime打开~/.bashrc，在末尾添加如下内容： export PATH=/usr/local/php/bin:$PATH export PATH=/usr/local/php/sbin:$PATH 保存后，终端输入命令： source ~/.bashrc 此时即可通过php –version查看php版本，看到如下内容： PHP 5.5.10 (cli) (built: Apr 26 2014 09:46:14)Copyright (c) 1997-2014 The PHP GroupZend Engine v2.5.0, Copyright (c) 1998-2014 Zend Technologies即说明安装成功。 memcached扩展： wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz tar -zxvf libmemcached-1.0.18.tar.gz ./configure make &amp;&amp; make install wget http://pecl.php.net/get/memcached-2.2.0.tgz tar -zxvf memcached-2.2.0.tgz phpize ./configure make &amp;&amp; make install vi /etc/php/php.ini extension = memcached.so redis扩展： https://github.com/phpredis/phpredis.git cd phpredis/ /usr/local/php/bin/phpize ./configure --with-php-config=/usr/local/php/bin/php-config make &amp;&amp; make install vi /etc/php/php.ini extension=redis.so mongo扩展： wget http://pecl.php.net/get/mongo-1.5.8.tgz tar -zxvf mongo-1.5.8.tgz /usr/local/php/bin/phpize ./configure --with-php-config=/usr/local/php/bin/php-config make make install vi /etc/php/php.ini extension=mongo.so","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"PHP分离curl header和body","date":"2015-11-28T07:24:25.000Z","path":"2015/11/28/PHP分离curl header和body/","text":"$header = array ( \"Content-Type:application/json;encoding=utf-8\" ); $ch = curl_init (); curl_setopt ( $ch, CURLOPT_URL, $uri ); curl_setopt ( $ch, CURLOPT_POST, 1 ); curl_setopt ( $ch, CURLOPT_HEADER, $header ); curl_setopt ( $ch, CURLOPT_RETURNTRANSFER, 1 ); curl_setopt ( $ch, CURLOPT_POSTFIELDS, $data ); $response = curl_exec ( $ch ); $http_status = curl_getinfo ( $ch, CURLINFO_HTTP_CODE ); curl_close ( $ch ); print_r($response); 返回结果如下 HTTP/1.1 200 OK Content-Type: application/json;encoding=utf-8 Access-Control-Allow-Origin: * Set-Cookie: key1=value1 Set-Cookie: key2=value2 {“header”:{“handler_id”:3001,”command_id”:3004,”terminal”:1001,”version”:0,”reserved”:0},”data”:{“service_types”:[{“name”:”A号：收款、退费、科研经费入账”,”id”:1,”count”:0},{“name”:”B号：请款、内部转账、出国业务咨询及报销”,”id”:2,”count”:0},{“name”:”C号：报销（含劳务收入酬金报销）”,”id”:3,”count”:0},{“name”:”D号：零余额优先报账”,”id”:4,”count”:0}],”code”:1,”msgCode”:23000,”msg”:”获得排队业务清单请求成功”}} 要获取分离body和header的数据可以用以下方法： if (curl_getinfo($ch, CURLINFO_HTTP_CODE) == '200') {//判断是否成功获取数据 $headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE); $header = substr($response, 0, $headerSize); $body = substr($response, $headerSize); } 或者（个人比较偏好第二种） if (curl_getinfo($ch, CURLINFO_HTTP_CODE) == '200') {//判断是否成功获取数据 list($header, $body) = explode(\"\\r\\n\\r\\n\", response, 2); } 处理结果如下（body部分）： { “header”: { “handler_id”: 3001, “command_id”: 3004, “terminal”: 1001, “version”: 0, “reserved”: 0 }, “data”: { “service_types”: [ { “name”: “A号：收款、退费、科研经费入账”, “id”: 1, “count”: 0 }, { “name”: “B号：请款、内部转账、出国业务咨询及报销”, “id”: 2, “count”: 0 }, { “name”: “C号：报销（含劳务收入酬金报销）”, “id”: 3, “count”: 0 }, { “name”: “D号：零余额优先报账”, “id”: 4, “count”: 0 } ], “code”: 1, “msgCode”: 23000, “msg”: “获得排队业务清单请求成功” }}","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"curl","slug":"curl","permalink":"https://github.com/kong36088/kong36088.github.io/tags/curl/"}]},{"title":"计算机网络——应用层的协议总结","date":"2015-11-25T07:24:25.000Z","path":"2015/11/25/计算机网络——应用层的协议总结/","text":"协议大致有：HTTP、FTP、DNS、SMTP。HTTP HTTP的发展是万维网协会（World Wide Web Consortium）和Internet工作小组（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，其中最著名的就是RFC 2616。RFC 2616定义了HTTP协议中一个现今被广泛使用的版本——HTTP 1.1。HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）调用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnel）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers，或者，更准确一些，URI）来标识。 FTP FTP服务一般运行在20和21两个端口。端口20用于在客户端和服务器之间传输数据流，而端口21用于传输控制流，并且是命令通向ftp服务器的进口。当数据通过数据流传输时，控制流处于空闲状态。而当控制流，空闲很长时间后，客户端的防火墙，会将其会话置为超时，这样当大量数据通过防火墙时，会产生一些问题。此时，虽然文件可以成功的传输，但因为控制会话，会被防火墙断开；传输会产生一些错误。FTP实现的目标：促进文件的共享（计算机程序或数据）鼓励间接或者隐式的使用远程计算机向用户屏蔽不同主机中各种文件存储系统（File system）的细节可靠和高效的传输数据缺点：密码和文件内容都使用明文传输，可能产生不希望发生的窃听。因为必须开放一个随机的端口以建立连接，当防火墙存在时，客户端很难过滤处于主动模式下的FTP流量。这个问题，通过使用被动模式的FTP，得到了很大解决。服务器可能会被告知连接一个第三方计算机的保留端口。此方式在需要传输文件数量很多的小文件时，效能不好FTP虽然可以被终端用户直接使用，但是它是设计成被FTP客户端程序所控制。运行FTP服务的许多站点都开放匿名服务，在这种设置下，用户不需要帐号就可以登录服务器，默认情况下，匿名用户的用户名是：“anonymous”。这个帐号不需要密码，虽然通常要求输入用户的邮件地址作为认证密码，但这只是一些细节或者此邮件地址根本不被确定，而是依赖于FTP服务器的配置情况。应用层协议为应用程序之间的通信提供规则，为确保通信畅通，源主机和目的主机上所实现的应用层协议必须一致。应用层协议的功能：为通信双方定义过程；定义消息类型；定义消息的语法；定义任何信息性字段的含义；定义发送消息的方式和预期的响应；定义与下一层之间的交互。 DNS 每个IP地址都可以有一个主机名，主机名由一个或多个字符串组成，字符串之间用小数点隔开。有了主机名，就不要死记硬背每台IP设备的IP地址，只要记住相对直观有意义的主机名就行了。这就是DNS协议所要完成的功能。主机名到IP地址的映射有两种方式：1）静态映射，每台设备上都配置主机到IP地址的映射，各设备独立维护自己的映射表，而且只供本设备使用；2）动态映射，建立一套域名解析系统（DNS），只在专门的DNS服务器上配置主机到IP地址的映射，网络上需要使用主机名通信的设备，首先需要到DNS服务器查询主机所对应的IP地址。[1]通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。在解析域名时，可以首先采用静态域名解析的方法，如果静态域名解析不成功，再采用动态域名解析的方法。可以将一些常用的域名放入静态域名解析表中，这样可以大大提高域名解析效率。 SMTP SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。它使用由TCP提供的可靠的数据传输服务把邮件消息从发信人的邮件服务器传送到收信人的邮件服务器。跟大多数应用层协议一样，SMTP也存在两个 端：在发信人的邮件服务器上执行的客户端和在收信人的邮件服务器上执行的服务器端。SMTP的客户端和服务器端同时运行在每个邮件服务器上。当一个邮件服 务器在向其他邮件服务器发送邮件消息时，它是作为SMTP客户在运行。SMTP协议与人们用于面对面交互的礼仪之间有许多相似之处。首先，运行在发送端邮件服务器主机上的SMTP客户，发起建立一个到运行在接收端邮件服务 器主机上的SMTP服务器端口号25之间的TCP连接。如果接收邮件服务器当前不在工作，SMTP客户就等待一段时间后再尝试建立该连接。SMTP客户和服务器先执行一些应用层握手操作。就像人们在转手东西之前往往先自我介绍那样，SMTP客户和服务器也在传送信息之前先自我介绍一下。 在这个SMTP握手阶段，SMTP客户向服务器分别指出发信人和收信人的电子邮件地址。彼此自我介绍完毕之后，客户发出邮件消息。 参考自百度百科","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://github.com/kong36088/kong36088.github.io/tags/计算机基础/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/kong36088/kong36088.github.io/tags/计算机网络/"}]},{"title":"ubuntu彻底卸载软件","date":"2015-11-22T07:24:25.000Z","path":"2015/11/22/ubuntu彻底卸载软件/","text":"在ubuntu中安装软件后通常想卸载都会卸载得不干净，以下献上把软件完全卸载干净的方法首先找到你想卸载的软件：software（这个是你想要卸载的软件的名称）然后打开teminal执行以下命令 sudo apt-get purge software purge参数为彻底删除文件,然后执行 sudo apt-get autoremove software sudo apt-get clean software dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P software 这些命令之后就可以彻底卸载干净软件了","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"java的一百多个练手小项目","date":"2015-11-22T07:24:25.000Z","path":"2015/11/22/java的一百多个练手小项目/","text":"文本操作 逆转字符串——输入一个字符串，将其逆转并输出。拉丁猪文字游戏——这是一个英语语言游戏。基本规则是将一个英语单词的第一个辅音音素的字母移动到词尾并且加上后缀-ay（譬如“banana”会变成“anana-bay”）。可以在维基百科上了解更多内容。统计元音字母——输入一个字符串，统计处其中元音字母的数量。更复杂点的话统计出每个元音字母的数量。判断是否为回文——判断用户输入的字符串是否为回文。回文是指正反拼写形式都是一样的词，譬如“racecar”。统计字符串中的单词数目——统计字符串中单词的数目，更复杂的话从一个文本中读出字符串并生成单词数目统计结果。文本编辑器——记事本类型的应用，可以打开、编辑、保存文本文档。可以增加单词高亮和其它的一些特性。RSS源创建器——可以从其它来源读取文本并将其以RSS或者Atom的格式发布出去。实时股价——可以查询股票当前价格。用户可以设定数据刷新频率，程序会用绿色和红色的箭头表示股价走势。访客留言簿/日志——允许人们添加评论或者日记，可以设置开启/关闭评论，并且可以记录下每一条目的时间。也可以做成喊话器。新闻和比分播报器——一个桌面应用，可以从网上收集新闻和比赛分数，将结果在屏幕上滚动播出。占星罗盘——用占星术来预测每天的运程。密码短信——可以将数据加密解密，并能将其发送给朋友。帮你挑礼物——输入一堆你可能会送的礼物，当有人过生日时，该程序会随机选择一样礼物。也可以加上一个额外功能，可以告知哪里可以弄到这个礼物。HTML生成器——将 TEXT 文档转换成HTML文件，对制作网页HTML文档很有用。CD-Key生成器——利用某种算法生成一个唯一的key。软件开发者可以用它来作为软件的激活器。正则表达式查询工具——用户可以输入一段文本，在另外的控件里输入一个正则表达式。运行以后会返回匹配的内容或者正则表达式中的错误。 网络 FTP工具——与远程网络服务器交互文件。原子钟校时——从网上同步原子钟时间。全世界有很多原子钟，可以把它们都列出来。聊天应用（IRC或者MSN风格的）——像IRC那样的聊天室软件或者MSN那样的实时聊天软件。更复杂一点的话，可以为聊天制定一套你自己的传输协议。获取当前天气——获取某个地区当前的天气情况。P2P文件共享应用——像LimeWire、FrostWire、Bearshare或者torrent风格的应用。端口扫描器——输入某个ip地址和端口区间，程序会逐个尝试区间内的端口，如果能成功连接的话就将该端口标记为open。邮件检查工具（POP3/IMAP）——用户输入一些账号信息，包括服务器、ip、协议类型（POP3或者IMAP），应用每隔一段时间就会检查下该账号下的邮箱。数据包嗅探器——侦测电脑上进出的数据包，获取诸如目的地和大小之类的信息。IP注册地查询——输入ip地址，查询该ip是在哪注册的。Whois查询工具——输入一个ip或者主机地址，通过whois查询并将结果返回。邮编查询——输入邮编，返回使用该邮编的地区名称。远程登入——远程登入桌面类型的应用，可以查看和控制远程电脑（假如你已经获得权限）。可能需要你自己的网络和两台电脑来进行测试。网站定时检查器——每隔一段时间或者在预定的时间尝试连接某个网站或者服务器，来检查它是否可以连上，如果连不上了会通过邮件或者桌面通知来告知你。小型网页服务器——简易版的网页服务器，可以存放包含Javascript和其它形式代码的HTML文件。复杂一点的话可以尝试流媒体视频、创建一种服务器端语言或者其它类型的流媒体。网络蜘蛛——一个可以自动执行网页上各种任务的程序，任务包括网站检查、页面抓取、数据摘要以及网络邮务。 类 产品库存管理——创建一个管理产品库存的应用。建立一个产品类，包含价格、id、库存数量。然后建立一个库存类，记录各种产品并能计算库存的总价值。电影商店——管理录像带租借，记录借出时间、到期时间、逾期费用。复杂一点可以生成逾期用户的账号报告。航空/酒店预订系统——创建一套预订航班或酒店的预订系统。不同的航班座位和酒店房间收费不一样。譬如头等舱要比经济舱贵。带阁楼的套间要更贵些。记录下何时有空房可供预订。学生成绩管理器——记录一个班级的学生（创建一个Student类，记录他们的名字、平均分和考试分数）和他们的成绩等级。根据学生的测验和作业的分数计算出平均分和成绩等级。复杂一点可以将数据画在贝尔曲线上。银行账户管家——创建一个名为“Account”的抽象类，有三个为“CheckingAccount”、“SavingsAccount”和“BusinessAccount”的子类。通过类似ATM的程序来管理这些账户的借贷。馆藏目录——创建一个图书类，记录书名、页数、国际标准书号、是否借出。用它来管理各种书籍，允许用户进行借出和归还操作。复杂一点的话，可以生成逾期图书和逾期费用的报告。也可以让用户进行预约操作。 线程处理 下载进度条——创建一个表示下载进度的进度条。进度条由独立的线程操作，通过委托来和主线程进行通讯。下载管理器——允许程序同时下载数个文件，每个都用单独的线程进行背景下载。主线程会关注下载进度并且在下载完成时通知用户。聊天软件（远程聊天）——做一个聊天软件，允许你通过ip直接连接到另一台电脑，也允许你的“服务器”程序处理多个请求连接。批量缩略图生成器——在进行图片转换的处理时会需要很多时间，尤其是图片很大时。做一个图片处理程序，能让你在做其它事的时候在后台线程里将数百张图片转换成某个大小的图片。复杂一点的话可以用一个线程来缩放，用另一个线程来为缩略图重命名。 Web应用 所见即所得编辑器——创建一个在线编辑器，允许用户移动元素、创建表格、书写文本、设置颜色，而用户不必懂HTML。就像Dreamweaver或者FrontPage。如果需要例子的话，可以参看DIC。分页浏览器——创建一个可以分页的小型网页浏览器，可以同时浏览几个网页。简化一点的话不要考虑Javascript或者其它客户端代码。文件下载器——该程序可以从网页上下载各种资源，包括视频和其它文件。用于有很多下载链接的网页。远程登录——创建一个远程登录的应用，可以通过网络登录服务器并能执行一些基本命令。在线白板——做一个在线白板程序，你和朋友们可以一起在白板上进行一些操作，画图、写字等等。带宽监视器——这个小工具可以记录你已经在网上上传和下载多少数据流量了。可以试着做份报告或者图表来展示各时段的使用情况。书签搜集管理器——该程序可以让用户上传书签并将它们排序，去掉重复的，并能生成书签文件以供Firefox/IE/Safari等使用。复杂一点的话可以试着将书签整理进不同的文件夹。密码保险箱——用来记录各种密码，并且将它们加密，这样别人就看不到了。iGoogle媒体播放器小部件——做一个iGoogle小部件，可以用来播放本地音乐列表，也可以每天分享一首歌。也许还可以让别人看到你最近听了些什么歌。基于文本的游戏——做一个像Utopia那样的文本RPG，游戏中，你可以创建一个文明、收集资源、共铸联盟、施放法术、回合制系统。看看是否能够统一王国。定时自动登录——做一个程序可以在预定的时间登录进某个指定的网页并且执行特定的动作，然后在登出。可以用来检查邮箱、发布常规内容、为其它程序获取信息。电子卡片生成器——可以让用户制作自己的电子卡片并发送给其他人。可以使用flash也可以不用。可以使用图片库，也可以加上深刻的格言警句。内容管理系统——像Joomala、Drupal、PHP Nuke这样的内容管理系统。从简单的做起，慢慢增加其它功能。模板制作器——该网站应用允许用户输入各种颜色代码、元素、尺寸，来为PHPBB、Invision Board、MySpace之类的应用创建模板文件。验证码生成器——应该在登录时见过有数字有字母的验证码图片吧？这可以防止自动登录和垃圾广告。试着自己做一个，如果使用PHP的话，看下GD的图片函数。 文件 试卷生成器——该程序可以从文件中随机挑选出不同的题目生成一份试卷。每份试卷可以不一样，通过读取答案来给打分。快速启动——该工具可以添加各个程序的小图标，点击小图标就可以运行程序。和Windows的快速启动类似。文件管理器——做一个文件管理器，要加些新特性，更佳的搜索功能、新图标、新外观。文件记录排序工具——从文件中读取记录，将其排序并写回文件中。允许用户选择排序风格以及排序关键字。生成财务交易文件并且算出平均值——将财务交易读进文件，按照账户分类、算出各项目的总量或平均值、理清各账户的借贷数据。Zip文件生成器——用户输入不同文件夹的文件，也许还包括其他电脑中的文件，然后程序将这些文件打包成zip文件。复杂一点的话，打包时对这些文件进行压缩。PDF生成器——从txt、html或其它文件中读取数据生成PDF文件。可以做成一个网页服务，用户上传文件，返回一个pdf版本。批量文件命名器——程序批量处理一些文件，将根据用户提供的过滤器为它们重命名。譬如用户输入的过滤器为myimage###.jpg，那么会生成至少包含3位数的文件名，譬如myimage001.jpg、myimage145.jpg，甚至是myimage1987.jpg，因为1987也满足了至少包含3位数的条件。MP3标签生成器——修改MP3文件的id3v1标签。还可以试着在MP3文件的头部加入id3v2的标签，譬如album art标签。日志文件生成器——该程序可以记录指定事件的日志。譬如程序做了什么、系统在干什么、文件什么时候被修改了。Excel分页输出器——做一个在线程序，可以读取文件内容生成一个excel分页。可以通过CVS或者其它文件格式来做。复杂一点的话看看是否能创建公式字段。RPG角色属性生成器——做一个程序来给RPG角色随机分配属性点数，可以由用户制定一些分配规则。可以生成职业、性别、力量/魔法/敏捷点数、额外能力或者贸易技能。把结果保存成文件，这样跑团的时候地下城主可以把它打印出来。文件复制工具——该工具可以批量处理文件复制和备份操作。 数据库 SQL查询分析器——该工具可以让用户输入一条查询命令，让其运行于本地数据库中。尽量让它运行得更高效。远程SQL工具——该工具能让你通过网络在远程服务器上执行查询操作。它能接收远程主机地址、验证用户名和密码、执行查询并返回结果。卡片整理器——创建一个在线应用，用来记录搜集到的卡片。可以让用户输入整套卡片，查看哪些已经有了，哪些还需要搜集。要增加复杂度的话，还可以让用户知道还差多少可以完成，或者已经收集卡片的价值。报告生成器——该工具可以根据数据库中的表格生成一份报告。譬如根据订单表格生成销售报告。数据库备份脚本制作器——该程序可以读取数据库的对象、关系、记录和步骤，生成一个sql文件，该文件可以导入另一个数据库或者作为备份文件。备忘录——该程序可以让用户设置一个日期和某个事件的时间、事件备注并将它们放到日历上。用户可以查看日历、搜索特定的事件。复杂一点的话，可以让用户设置重复发生的事件，譬如每天、每周、每月、每年等等。预算记录器——该程序可以记录家庭预算。用户可以添加支出、收入，计算一段时间内的收入和支出。复杂一点的话，让用户指定一个时间段，显示该时间段内的家庭收支情况。电话簿——记录各种联系人和他们的号码、邮箱、备注。复杂一点的话可以让用户连上网将电话簿发布到设置好的网站上。电视节目记录器——你是否有不想错过的电视节目？但没有录像机或者想之后能找到该电视节目然后录下来，那么可以做个程序寻找各种在线电视导航网站，记录下电视节目名称、播放时间、播放频道，存在数据库中。数据库或者网站到时就会发邮件提醒你，节目就快在某个频道开始了。旅行计划系统——该系统可以让用户管理旅行路线，记录下航班和酒店安排、感兴趣的地方、预算和时间表。实体关系图生成器——该程序可以让用户整合实体关系图，并将其保存起来，也可以用它来生成一些基础SQL语句。数据库翻译器（MySQL&lt;-&gt;SQL Server）——该工具可以从数据库A读取数据，生成数据库B使用的SQL语句，将数据存入数据库B。比较常用的是SQL Server和Oracle使用的MySQL服务器。BBS论坛——为你和小伙伴们做一个论坛，可以发帖、管理、分享想法和构思。 图像和多媒体 幻灯片——做一个以幻灯片形式显示各种图片的程序。为了增加难度可以做些额外的效果，譬如渐进检出、星型擦除、窗口渐隐。思维导图——允许用户记录下各种构思并且快速地进行头脑风暴将这些构思整合到一张思维导图中。越快越好，因此要让用户能迅速地写下构思，然后将其拖到可视的导图中去，将构思之间的关系展现出来。导入图片并存成灰度图——该工具将图片上的彩色除尽并保存。可以增加对比度调整、色化等额外功能以增加复杂度。在线流媒体视频——试着自己做一个在线流媒体视频播放器。MP3播放器（以及其他格式的音乐播放器）——该小程序用来播放你最爱的音乐文件。复杂一点的话看看能否加个播放列表功能和均衡器。批量图片处理——该程序可以将一个文件夹内的图片进行统一的处理，譬如降低图片色调、转换格式或者修改文件属性。还可以尝试给图片增加标签。CD烧录器——可以轻松烧录CD的工具。YouTube下载器——可以从Youtube.com上下载视频到硬盘中，要支持包括FLV和AVI在内的文件格式。墙纸管理工具——做一个管理墙纸的程序，可以定时更换刷新墙纸，也可以针对分辨率进行缩放。截屏程序——做一个可以截屏的工具，复杂一点可以增加一个转发邮件的功能。图片浏览器——该程序可以查看电脑上各种格式的图片，譬如PNG、GIF、JPG、BMP、TIFF等等。交通信号灯——试着做一个交通信号灯并且把它放到可以互动的场景中。不要让汽车闯红灯或者撞到其它车。MP3-WAV转换器——MP3格式本质上就是压缩版的WAV。试着将MP3转换成WAV格式以供可以处理WAV格式的程序使用。请记住1MB的MP3大约等于10MB的WAV。签名生成器——是否在网上见过有人的留言后面有条生成的签名？试着做个程序让用户可以指定背景、文字、颜色和对齐方式来定制一个签名档。屏保——电脑空闲时会运行的屏保程序。简单版的可以使用一些标准图片，复杂版的可以做出能在屏幕上转来转去的3D物体。水印——你是否想保护你图片的版权？在图片上加上标志或者文字，这样别人就不能轻易地从你网站上盗图了。做一个程序来给你的图片加上水印吧。海龟图——创建一个20*20的格子，用命令让一只海龟在格子上画线。可以前进、左转、右转，拿起或放下笔等等。复杂一点的话，允许程序从文件中读取命令列表。可以在网上了解到更多关于“海龟图”的信息。 游戏 战船——创建两块游戏面板，玩家各占一边，在上面放置一些战船，玩家看不到对方的面板。每艘船都占几个格子，玩家轮流攻击某个格子，如果格子上有船，那就命中目标，否则就是未命中。当一艘船所占的所有格子都被攻击命中了，那么船就被击沉。谁先将对方战船全部击沉就获胜。象棋跳棋——象棋或者跳棋游戏。可以试着做成可以联网玩，用图形用户界面来实现悔棋、保存走棋过程并且可以回放。刽子手——从文件中随机选择一个单词，让玩家猜单词中的字母。旁边是一幅隐藏的行绞刑的画，猜错一个单词，画就显示出一部分。画全部显示出来时还没能猜全的话玩家就输了。填字游戏——创建一个填字游戏，并为每个词提供一个提示信息，让玩家填上所有正确的单词。青蛙跳——让青蛙跳过河或者马路，过河的话要跳在顺流而下速度各异的木头或者睡莲叶子上，过马路的话要避开速度各异的车子。","tags":[{"name":"Java","slug":"Java","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Java/"},{"name":"练习题","slug":"练习题","permalink":"https://github.com/kong36088/kong36088.github.io/tags/练习题/"}]},{"title":"全面的防sql注入方法（转）","date":"2015-11-20T13:24:25.000Z","path":"2015/11/20/全面的防sql注入方法（转）/","text":"function inject_check($sql_str) { return eregi ( 'select|insert|and|or|update|delete|\\'|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile', $sql_str ); } function verify_id($id = null) { if (! $id) { exit ( '没有提交参数！' ); } elseif (inject_check ( $id )) { exit ( '提交的参数非法！' ); } elseif (! is_numeric ( $id )) { exit ( '提交的参数非法！' ); } $id = intval ( $id ); return $id; } function str_check($str) { if (! get_magic_quotes_gpc ()) { $str = addslashes ( $str ); // 进行过滤 } $str = str_replace ( \"_\", \"\\_\", $str ); $str = str_replace ( \"%\", \"\\%\", $str ); return $str; } function post_check($post) { if (! get_magic_quotes_gpc ()) { $post = addslashes ( $post ); } $post = str_replace ( \"_\", \"\\_\", $post ); $post = str_replace ( \"%\", \"\\%\", $post ); $post = nl2br ( $post ); $post = htmlspecialchars ( $post ); return $post; } 转自http://www.phpddt.com/php/228.html","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"SQL","slug":"SQL","permalink":"https://github.com/kong36088/kong36088.github.io/tags/SQL/"}]},{"title":"PHPsocket通信","date":"2015-11-19T11:24:25.000Z","path":"2015/11/19/PHPsocket通信/","text":"socket通信的思路是 server创建一个socket-&gt;server端对端口进行监听-&gt;write和read-&gt;close client创建一个socket-&gt;连接到server的IP/Port-&gt;write和read消息-&gt;close 下面是server端的代码 set_time_limit ( 0 ); $socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ); socket_bind ( $socket, '127.0.0.1', 1995 ); socket_listen ( $socket ); $counter = 0; while ( 1 ) { if (($connection = socket_accept ( $socket )) &lt; 0) { echo \"socket_accept failed:reason:\" . socket_strerror ( $connection ) . PHP_EOL; } else { $msg = 'server的消息' . PHP_EOL; socket_write ( $connection, $msg, strlen ( $msg ) ); echo \"server接收socket成功\" . PHP_EOL; $read = socket_read ( $connection, 1024 ); echo \"收到的信息：\" . $read . PHP_EOL; if (++ $counter &gt;= 10) { break; } } socket_close ( $connection ); } socket_close ( $socket ); 然后是client端的代码 // client端 $socket = socket_create ( AF_INET, SOCK_STREAM, SOL_TCP ); if ($socket &lt; 0) { echo socket_strerror ( $socket ); exit (); } else { echo \"创建socket成功\\n\"; } $connection = socket_connect ( $socket, '127.0.0.1', 1995 ); if ($connection &lt; 0) { echo socket_strerror ( $connection ); exit (); } else { echo \"连接socket成功\\n\"; } $in = \"来自client的消息\\n\"; if (! socket_write ( $socket, $in, strlen ( $in ) )) { echo socket_strerror ( $socket ); exit (); } else { echo \"write成功\\n\"; } while ( $out = socket_read ( $socket, 1024 ) ) { echo \"接受消息成功\\n\"; echo $out; } socket_close ( $socket ); echo \"关闭socket成功\\n\"; ?&gt; 效果图：","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"socket","slug":"socket","permalink":"https://github.com/kong36088/kong36088.github.io/tags/socket/"}]},{"title":"MYSQL按时间范围查询","date":"2015-11-16T12:24:25.000Z","path":"2015/11/16/MYSQL按时间范围查询/","text":"MYSQL按时间范围查询方法 前30天内的mysql查询：1mysql&gt; select * from TABLENAME where TO_DAYS(NOW())-TO_DAYS(Time_column)&lt;=30; 其中30为时间范围，Time_column可以替换成表中的时间字段名，TABLENAME换成表名。 另一种方法：1select * from TALBLENAME where DATE_SUB(CURDATE(), INTERVAL 30 DAY) &lt;= date(Time_column) 一段时间范围的查询： SELECT * FROM sp_xuanjiang WHERE Time between '2015-03-01 00:00:00' AND '2015-05-0 16:59:59'(类型为datetime)","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://github.com/kong36088/kong36088.github.io/tags/MYSQL/"}]},{"title":"ubuntu14.04仿mac界面的总结","date":"2015-11-16T12:24:25.000Z","path":"2015/11/16/ubuntu14.04仿mac界面的总结/","text":"最近想着怎么用自己的ubuntu系统装逼成一个mac系统，好提高自己的逼格，于是上网找了下资料，总结如下： 首先先下载一些mac的壁纸，用于装逼：点击这里 下载好之后可以自定义你的壁纸。 然后安装一个修改主题的工具tweak： sudo apt-get install unity-tweak-tool sudo add-apt-repository ppa:tualatrix/ppa sudo apt-get update sudo apt-get install ubuntu-tweak 按下win键，搜索tweak打开你刚才安装的软件，效果图如下： 然后敲入下面命令安装主题： sudo add-apt-repository ppa:noobslab/themes sudo apt-get update sudo apt-get install mac-ithemes-v3 sudo apt-get install mac-icons-v3 现在打开刚才安装的工具来选择主题，在GTK主题上选择MBuntu。再本地tab上选择Mbuntu-osx在光标tab上选择Mac-cursors. 再次安装docky，一个轻量级的任务栏软件 sudo add-apt-repository ppa:docky-core/ppa sudo apt-get update sudo apt-get install docky 在安装好以后，选择设置： 然后 再外观-&gt;行为中可以关闭启动器， 之后的桌面基本和mac相似，可以用来装逼","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Unbuntu","slug":"Unbuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Unbuntu/"}]},{"title":"PHP爬虫（红满堂）","date":"2015-11-16T12:24:25.000Z","path":"2015/11/16/PHP爬虫（红满堂）/","text":"红满堂链接：http://hometown.scau.edu.cn/bbs/forum.php 献上源码（爬虫的关键是正则表达式的编写），按板块分类出文章标题和URL地址： // 红满堂爬虫 class Crwaler { private $url; private $times = 1; // 初始化，获得URL,红满堂域名 function __construct($url) { $this-&gt;url = $url; } // 获取内容 function get_content($url) { $handle = fopen ( \"$url\", \"r\" ); if ($handle) { $content = stream_get_contents ( $handle ); return $content; } else { die ( 'get_content_1 error' ); } } // 获取首页url，获取各个模板块的URL function get_url_1() { $match = '/(href=[\\\"]{0,1})(forum\\.php\\?mod=forumdisplay[^\\\"]*)/'; $content = $this-&gt;get_content ( $this-&gt;url ); if (preg_match_all ( $match, $content, $results )) { foreach ( $results [2] as $value ) { $result [] = $value; } // 去重 $result = array_unique ( $result ); foreach ( $result as $value ) { $url_total [] = 'http://hometown.scau.edu.cn/bbs/' . $value; } return $url_total; } else { die ( 'get_url_1 error' ); } } // 获得各版标题 function get_title($url) { $match = '/class=\\\"xs2\\\"&gt;[^&lt;]*&lt;a[^&gt;]*&gt;([^&lt;]*)/'; $content = $this-&gt;get_content ( $url ); if (preg_match ( $match, $content, $title )) { // var_dump ( $title [1] ); return $title [1]; } else { die ( 'get_title error' ); } } // 获取版内信息，获得单一页数内的URL和标题 function get_information($content) { $match = '/href=\\\"(forum\\.php\\?mod=viewthread[^\\\"]*)\\\".*(?:class=\\\"s xst\\\"&gt;)([^&lt;]*).*/'; // $match='/.*(?:class=\\\"s xst\\\")/'; if (preg_match_all ( $match, $content, $results )) { // var_dump ( $results ); for($i = 0, $num = count ( $results [1] ); $i &lt; $num; $i ++) { $results [1] [$i] = str_replace ( ';', '&amp;', $results [1] [$i] ); $results [1] [$i] = str_replace ( '&amp;amp', '', $results [1] [$i] ); $result [] = '链接： http://hometown.scau.edu.cn/bbs/' . $results [1] [$i] . ' 标题：' . $results [2] [$i] . PHP_EOL; } return $result; } else { die ( 'get_information error' ); } } // 获取页码，获取模版内的页数 function get_page($url) { $match = '/&lt;span title=\\\"共[^0-9]*([0-9]+)/'; $content = $this-&gt;get_content ( $url ); if (preg_match ( $match, $content, $page )) { // var_dump($page); $page = $page [1]; if ($page &gt; 1500) { $page = 1; } return $page; } else { $page = 1; return $page; } } // 将内容写入TXT function write($info, $title) { $title = $title . '.txt'; file_put_contents ( $title, $info, FILE_APPEND ); } // 获取版面内的content，并且遍历所有页数，获得标题和URL function get() { $sign = 1; $url_total = $this-&gt;get_url_1 (); foreach ( $url_total as $url ) { $title = $this-&gt;get_title ( $url ); $page_num = $this-&gt;get_page ( $url ); for($flag = 1; $flag &lt;= $page_num; $flag ++) { $url_n = $url . '&amp;page=' . $flag; $content = $this-&gt;get_content ( $url_n ); $result = $this-&gt;get_information ( $content ); var_dump ( $flag ); $sign ++; $this-&gt;write ( $result, $title ); } } echo \"succeed\"; } } $crawler = new Crwaler ( 'http://hometown.scau.edu.cn/bbs/forum.php' ); $crawler-&gt;get (); 效果图：","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/kong36088/kong36088.github.io/tags/爬虫/"}]},{"title":"关于PHP对于时间存取的理解","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/关于PHP对于时间存取的理解/","text":"在使用PHP存取时间时，数据库表尽量使用int(10)这种类型，而不要使用datetime。 原因一：采用int数据量小，便于提高数据库效率 原因二：在进行提取时间操作的时候时间可以进行任意转换，可以通过php自带的函数 date(format,timestamp)进行转换 在储存数据的时候同样，可以利用函数strtotime转换成UNIX时间戳，然后作为int存入数据库，灵活变换 PHP中要获取一个月前的时间戳可以这样用： strtotime(\"-1 month\") 结果为： 1429287142 一年前的时间戳： strtotime(\"-1 year\") 结果为： 1400343128 转换成可读时间： date(\"Y-m-d\",strtotime(\"-1 month\")) 结果为： 2015-04-18 由此可见，strtotime这个函数十分之强大","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/ThinkPHP/"},{"name":"验证码","slug":"验证码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/验证码/"}]},{"title":"PHP开发小技巧——显示错误","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/PHP开发小技巧——显示错误/","text":"在开发调试阶段，可以在代码的开头添加 error_reporting(E_ALL); ini_set('display_errors', '1'); 来显示出php运行时的错误，不用去修改php.ini","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"ThinkPHP经常用到的系统变量","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/ThinkPHP经常用到的系统变量/","text":"原文地址：http://www.jb51.net/article/47642.htm （1）系统变量：在模板中输出系统变量：包括server、env、session、post、get、request、cookie{$Think.server.script_name} // 输出$_SERVER变量{$Think.session.session_id|md5} // 输出$_SESSION变量{$Think.get.pageNumber} // 输出$_GET变量{$Think.cookie.name} // 输出$_COOKIE变量 以上方式还可以写成：{$_SERVER.script_name} // 输出$_SERVER变量{$_SESSION.session_id|md5} // 输出$_SESSION变量{$_GET.pageNumber} // 输出$_GET变量{$_COOKIE.name} // 输出$_COOKIE变量 系统常量 ：使用$Think.const 输出注意：server、cookie、config不区分大小写，但是变量区分大小写。例如：{$Think.server.script_name}和{$Think.SERVER.script_name}等效SESSION 、COOKIE还支持二维数组的输出 例如：{$Think.CONFIG.user.user_name}{$Think.session.user.user_name}系统不支持三维以上的数组输出。 （2）语言变量：输出项目的当前语言定义值 {$Think.lang.page_error}{$Think.const.MODULE_NAME} 或者直接使用{$Think.MODULE_NAME} （3）特殊变量 ：由ThinkPHP系统内部定义的常量 {$Think.version} //版本{$Think.now} //现在时间{$Think.template|basename} //模板页面{$Think.LDELIM} //模板标签起始符号{$Think.RDELIM} //模板标签结束符号（4）配置参数 ：输出项目的配置参数值 {$Think.config.db_charset} 输出的值和 C(‘db_charset’) 的结果是一样的。 THINK_PATH // ThinkPHP 系统目录APP_PATH // 当前项目目录APP_NAME // 当前项目名称MODULE_NAME //当前模块名称ACTION_NAME // 当前操作名称TMPL_PATH // 项目模版目录LIB_PATH // 项目类库目录CACHE_PATH // 项目模版缓存目录CONFIG_PATH //项目配置文件目录LOG_PATH // 项目日志文件目录LANG_PATH // 项目语言文件目录TEMP_PATH //项目临时文件目录PLUGIN_PATH // 项目插件文件目录VENDOR_PATH // 第三方类库目录DATA_PATH // 项目数据文件目录IS_APACHE // 是否属于 ApacheIS_IIS //是否属于 IISIS_WIN //是否属于Windows 环境IS_LINUX //是否属于 Linux 环境IS_FREEBSD //是否属于 FreeBsd 环境NOW_TIME // 当前时间戳MEMORY_LIMIT_ON // 是否有内存使用限制OUTPUT_GZIP_ON // 是否开启输出压缩MAGIC_QUOTES_GPC // MAGIC_QUOTES_GPCTHINK_VERSION //ThinkPHP 版本号LANG_SET // 浏览器语言TEMPLATE_NAME //当前模版名称TEMPLATE_PATH //当前模版路径ROOT // 网站根目录地址APP // 当前项目（入口文件）地址URL // 当前模块地址ACTION // 当前操作地址SELF // 当前 URL 地址TMPL_FILE_NAME //当前操作的默认模版名（含路径）WEB_PUBLIC_URL //网站公共目录APP_PUBLIC_URL //项目公共模版目录 ROOT // 网站根目录地址APP // 当前项目（入口文件）地址URL // 当前模块地址ACTION // 当前操作地址SELF // 当前 URL 地址PUBLIC // 网站公共目录../Public (不区分大小写) // 项目公共模版目录注：当我们使用常量时，在模板被加载后在浏览器查看源码，我们观察某些使用了常量的URL，会发现一个现象，看不到服务器的ip地址，URL是从项目名开始的，那为什么能正确访问对应的控制器呢？实际上这是浏览器给我们开了一个玩笑，当我们将鼠标移动到该URL上，单击右键，复制源码中的URL，粘贴到别的地方，服务器的ip就会显示出来了，可见服务器ip是被包含进了该URL中使用的常量的。 在项目文件夹 （如：Home） 中的Common文件夹下新建common.php加入如下语句：define(‘XXX’, XXX); //第一个参数是常量名，第二个参数是常量值","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/ThinkPHP/"}]},{"title":"ThinkPHP生成二维码","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/ThinkPHP生成二维码/","text":"在php中，大致生成二维码的方法有两种：一种是引用别家提供的api然后进行自动生成， google有提供api专门生成二维码，而国内的新浪也有api专门提供， 新浪的api地址是：http://qrcoder.sinaapp.com?t=http://www.gbtags.com t=后面加上想要生成的url即可 生成二维码的另一种方法：通过开源的phpqrcode进行自动生成。 以下是源码： protected function qrcode($data, $filename=false, $picPath = false, $logo = false, $size = '4', $level = 'L', $padding = 2, $saveandprint = false) { /* * function qrcode(){ * $filename='qrcode.png'; * $logo=SITE_PATH.\"\\\\Public\\\\Home\\\\images\\\\logo_80.png\"; * qrcode('http://www.dellidc.com',$filename,false,$logo,8,'L',2,true); * } * * @param $data 二维码包含的文字内容 * @param $filename 保存二维码输出的文件名称，*.png * @param bool $picPath 二维码输出的路径 * @param bool $logo 二维码中包含的LOGO图片路径 * @param string $size 二维码的大小 * @param string $level 二维码编码纠错级别：L、M、Q、H * @param int $padding 二维码边框的间距 * @param bool $saveandprint 是否保存到文件并在浏览器直接输出，true:同时保存和输出，false:只保存文件 * return string */ vendor ( \"phpqrcode.phpqrcode\" ); // 引入工具包 // 下面注释了把二维码图片保存到本地的代码,如果要保存图片,用$fileName替换第二个参数false $path = $picPath ? $picPath : SITE_PATH . \"\\\\Uploads\\\\Picture\\\\QRcode\"; // 图片输出路径 mkdir ( $path ); // 在二维码上面添加LOGO if (empty ( $logo ) || $logo === false) { // 不包含LOGO if ($filename == false) { \\QRcode::png ( $data, false, $level, $size, $padding, $saveandprint ); // 直接输出到浏览器，不含LOGO } else { $filename = $path . '/' . $filename; // 合成路径 \\QRcode::png ( $data, $filename, $level, $size, $padding, $saveandprint ); // 直接输出到浏览器，不含LOGO } } else { // 包含LOGO if ($filename == false) { // $filename=tempnam('','').'.png';//生成临时文件 die ( '参数错误' ); } else { // 生成二维码,保存到文件 $filename = $path . $filename; // 合成路径 } \\QRcode::png ( $data, $filename, $level, $size, $padding ); $QR = imagecreatefromstring ( file_get_contents ( $filename ) ); $logo = imagecreatefromstring ( file_get_contents ( $logo ) ); $QR_width = imagesx ( $QR ); $QR_height = imagesy ( $QR ); $logo_width = imagesx ( $logo ); $logo_height = imagesy ( $logo ); $logo_qr_width = $QR_width / 5; $scale = $logo_width / $logo_qr_width; $logo_qr_height = $logo_height / $scale; $from_width = ($QR_width - $logo_qr_width) / 2; imagecopyresampled ( $QR, $logo, $from_width, $from_width, 0, 0, $logo_qr_width, $logo_qr_height, $logo_width, $logo_height ); if ($filename === false) { Header ( \"Content-type: image/png\" ); imagepng ( $QR ); } else { if ($saveandprint === true) { imagepng ( $QR, $filename ); header ( \"Content-type: image/png\" ); // 输出到浏览器 imagepng ( $QR ); } else { imagepng ( $QR, $filename ); } } } return $filename; } 其中，在使用该类的时候必须把下载到的phpqrcode文件夹放入ThinkPHP\\Library\\Vendor目录下，大致的路径是ThinkPHP\\Library\\Vendor\\phpqrcode phpqrcode的下载地址是：点我","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/ThinkPHP/"},{"name":"验证码","slug":"验证码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/验证码/"}]},{"title":"关于centos6.5 lamp搭建好后外网无法访问的一些经验总结","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/关于centos6.5 lamp搭建好后外网无法访问的一些经验总结/","text":"外网不能访问aoache，查看了apache的access_log，发现根本没有访问到服务器，直接就被拒绝了，所以在想可能是防火墙把80端口关了，百度了之后发现了原因所在。 因为防火墙把80端口给禁了，所以把80端口开放出来就可以让外网访问到apache服务器 CentOS防火墙设置开启80端口访问 我们以添加80端口为例操作如下： [root@centos httpd]# /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT 保存 [root@centos httpd]# /etc/rc.d/init.d/iptables save iptables：将防火墙规则保存到 /etc/sysconfig/iptables： [确定] 如果上面的步骤还没好的话，可能是这个iptables文件使用的是包含调用。 一般的在/etc/sysconfig/iptables这个路径上 或者使用vi打开这个文件修改手动添加。 [root@centos httpd]# vi /etc/sysconfig/iptables # Generated by iptables-save v1.4.7 on Tue Feb 14 07:32:18 2012 *filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [7:640] -A INPUT -p tcp -m tcp --dport 10000 -j ACCEPT -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p icmp -j ACCEPT -A INPUT -i lo -j ACCEPT -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-host-prohibited -A FORWARD -j REJECT --reject-with icmp-host-prohibited COMMIT # Completed on Tue Feb 14 07:32:18 2012 重新启动服务 [root@centos httpd]# service iptables restart iptables：清除防火墙规则： [确定] iptables：将链设置为政策 ACCEPT：filter [确定] iptables：正在卸载模块： [确定] iptables：应用防火墙规则： [确定] 查看端口是否生效: [root@centos httpd]# /etc/init.d/iptables status 表格：filter Chain INPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:10000 2 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 3 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED, 4 ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 5 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 6 ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp 7 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with ic Chain FORWARD (policy ACCEPT) num target prot opt source destination 1 REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with ic Chain OUTPUT (policy ACCEPT) num target prot opt source destination","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Centos/"}]},{"title":"Linux的文件目录安全修改","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/Linux的文件目录安全修改/","text":"准备把代码放在服务器centos6.5上跑的时候，在更改了documentroot以后，发现无论如何服务器都返回一个403 forbidden，十分之无奈和纠结，把所有都allow from all了一遍然而还是不行。最后找到一个答案，原来是linux的文件的安全问题，以下献上方法 ls -Z -d public_html/ ＃显示文件／目录的安全语境－Z, --context Display security context so it fits on most displays. Displays only mode, user, group, security context and file name.-d, --directory list directory entries instead of contents, and do not dereference symbolic links chcon -R -t httpd_user_content_t public_html/ ＃修改文件／目录的安全语境-R, --recursive change files and directories recursively-t, --type set type TYPE in the target security context","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"}]},{"title":"ubuntu14.04关于Some index files failed to download. They have been ignored, or old ones used instead.的错误","date":"2015-11-16T11:24:25.000Z","path":"2015/11/16/ubuntu14.04关于Some index files failed to download. They have been ignored, or old ones used instead.的错误/","text":"今天在用PHP的时候发现PHP没有安装CURL拓展，于是打算用 apt-get php5-curl去自动安装，却发现了这样的提示： php5-curl : 依赖: php5-common (= 5.5.9+dfsg-1ubuntu4) 但是 5.5.9+dfsg-1ubuntu4.14 正要被安装 于是百度了很久，终于找到了答案，原来是DNS的问题，直接到系统文件中修改一下DNS： 1.修改/etc/resolv.conf文件：为nameserver=8.8.8.8 2.sudo rm /var/lib/apt/lists/* -vf 3.sudo apt-get update 搞定","tags":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Ubuntu/"}]},{"title":"关于ping++对接的一点看法","date":"2015-11-16T10:24:25.000Z","path":"2015/11/16/关于ping++对接的一点看法/","text":"首先是处理支付方式的一个方法： function deal_way($channel) { $extra = array (); switch ($channel) { case 'alipay_wap' : $extra = array ( 'success_url' =&gt; 'http://127.0.0.1/index.php/Home/Index/success', 'cancel_url' =&gt; 'http://127.0.0.1/index.php/Home/Index/cancel' ); break; case 'upmp_wap' : $extra = array ( 'result_url' =&gt; 'http://127.0.0.1/index.php/Home/Index/result?code=' ); break; case 'bfb_wap' : $extra = array ( 'result_url' =&gt; 'http://127.0.0.1/index.php/Home/Index/result?code=', 'bfb_login' =&gt; true ); break; case 'upacp_wap' : $extra = array ( 'result_url' =&gt; 'http://127.0.0.1/index.php/Home/Index/result?code=' ); break; case 'wx_pub' : $extra = array ( 'open_id' =&gt; 'Openid' ); break; case 'wx_pub_qr' : $extra = array ( 'product_id' =&gt; 'Productid' ); break; default : break; } return $extra; } 接下来是创建charge对象的php代码： public function get_charge() { $channel = 'alipay_wap'; $extra = deal_way ( $channel ); \\Pingpp\\Pingpp::setApiKey ( 'sk_test_CijTyHCmzzb5GerTSG5m9qHK' ); $charge = \\Pingpp\\Charge::create ( array ( 'subject' =&gt; 'Your Subject', 'body' =&gt; 'Your Body', 'amount' =&gt; 10000, 'order_no' =&gt; 111111111, 'currency' =&gt; 'cny', 'extra' =&gt; $extra, 'channel' =&gt; $channel, 'client_ip' =&gt; '127.0.0.1', 'app' =&gt; array ( 'id' =&gt; 'app_SabjH8bjzHa1XLyr' ) ) ); $this-&gt;response ( $charge ); } 最后是ajax的写法： function wap_pay(channel) { var amount = document . getElementById ( 'amount' ) . value * 100; var send_data=\"channel=\"+channel+\"&amp;amount=\"+amount; var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"!:C('PAY')!/Pay/get_charge\", true); xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.send(send_data); xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { console.log(xhr.responseText); pingpp.createPayment(xhr.responseText, function(result, err) { console.log(result); console.log(err); }); } } } 在这里要注意，ajax的Content-Type要写成application/x-www-form-urlencoded","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"分页","slug":"分页","permalink":"https://github.com/kong36088/kong36088.github.io/tags/分页/"}]},{"title":"一个使用的分页方法","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/一个使用分页的方法/","text":"/** * $count 总页数 * $page 当前页号 * $num 显示的页码数 **/ function pagebar($count, $page, $num) { $num = min ( $count, $num ); // 处理显示的页码数大于总页数的情况 if ($page &gt; $count || $page &lt; 1) return; // 处理非法页号的情况 $end = $page + floor ( $num / 2 ) &lt;= $count ? $page + floor ( $num / 2 ) : $count; // 计算结束页号 $start = $end - $num + 1; // 计算开始页号 if ($start &lt; 1) { // 处理开始页号小于1的情况 $end -= $start - 1; $start = 1; } for($i = $start; $i &lt;= $end; $i ++) { // 输出分页条，请自行添加链接样式 if ($i == $page) echo \"[$i]\"; else echo \" $i \"; } echo \"($page)&lt;br /&gt;\"; } 输出的结果： 14 15 16 17 [18] 19 20 21 22 (18)","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"分页","slug":"分页","permalink":"https://github.com/kong36088/kong36088.github.io/tags/分页/"}]},{"title":"thinkPHP验证码的几个要点","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/thinkPHP验证码的几个要点/","text":"在使用验证码之前，首先要确保服务器端的php装有GD2的拓展库 class IndexController extends Controller { function index() { $this-&gt;display (); } function log() { $code = I ( 'post.code', '' ); // 获取POST得到的验证码信息 $Verify = new ThinkVerify (); if (! $this-&gt;check_verify ( $code )) { echo \"succeed\"; } else { echo \"failed\"; } } function verify() { // 生成验证码，可以在HTML中直接访问该控制器获得 $Verify = new ThinkVerify (); $Verify-&gt;entry (); } protected function check_verify($code, $id = \"\") { // 一个简单的检测验证码的函数 $verify = new ThinkVerify (); return $verify-&gt;check ( $code, $id ); } } &lt;!--more--&gt; 在对应的模板文件：目录下新建文件Index_index.html，内容如下： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;HCI官方网站&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"!:U('Home/Index/log')!\" method=\"post\" &gt; &lt;h2&gt;简易后台登录系统&lt;/h2&gt; 验证码：&lt;input type=\"code\" name=\"code\" /&gt; &lt;img src=\"/index.php/Home/Index/verify\" id=\"code\" onclick=\"this.src=this.src+'?'+Math.random()\"/&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/ThinkPHP/"},{"name":"验证码","slug":"验证码","permalink":"https://github.com/kong36088/kong36088.github.io/tags/验证码/"}]},{"title":"dirname(__FILE__) 的使用总结","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/dirname(__FILE__) 的使用总结/","text":"dirname(FILE)php中定义了一个很有用的常数，即file 这个内定常数是当前php程序的就是完整路径（路径+文件名）。 即使这个文件被其他文件引用(include或require)，file始终是它所在文件的完整路径，而不是引用它的那个文件完整路径。 请看下面例子：/home/data/demo/test/a.php $the_full_name=__FILE__; $the_dir=dirname(__FILE__); echo $the_full_name; //返回/home/data/demo/test/a.php echo $the_dir; //返回/home/data/demo/test FILE 返回当前 路径+文件名dirname(FILE) 返回当前文件路径的 路径部分dirname(dirname(FILE));得到的是文件上一层目录名（不含最后一个“/”号）","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"}]},{"title":"一个使用的分页方法","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/PHP中迭代器模式的使用和体会/","text":"迭代器模式提供一种访问一个容器对象中的各个元素，而又不暴露其内部细节的方法。在应用中，我们时常会遇到各种变量代码，foreach在很多代码处都可以见到，使用迭代器可以对不同数据结构的集合封装，外部只需调用迭代器提供的接口即可，提高了应用的可扩展性。 迭代器的使用可以遍历容器内的数据，是一种十分之实用的方法。 class travel implements \\Iterator { // 继承迭代器接口 protected $index = 0; protected $example = array (); public function __construct() { $this-&gt;index = 0; // 初始化index，迭代器初始化 $connect = mysqli_connect ( 'localhost', 'root', 'root', 'sphr' ) or die ( 'can not connect' ); mysqli_query ( $connect, 'set names utf8' ); // 设置utf8编码模式，防止乱码 $result = mysqli_query ( $connect, 'SELECT * FROM sp_candidate' ); $this-&gt;example = mysqli_fetch_all ( $result, MYSQLI_ASSOC ); } public function rewind() { $this-&gt;index = 0; } public function current() { return $this-&gt;example [$this-&gt;index]; } public function key() { return $this-&gt;index; } public function next() { $this-&gt;index ++; } public function valid() { return isset ( $this-&gt;example [$this-&gt;index] ); } } 迭代器的接口模式为： class myIterator implements Iterator { private $position = 0; private $array = array (); public function __construct() { $this-&gt;position = 0; } function rewind() { $this-&gt;position = 0; } function current() { return $this-&gt;array [$this-&gt;position]; } function key() { return $this-&gt;position; } function next() { ++ $this-&gt;position; } function valid() { return isset ( $this-&gt;array [$this-&gt;position] ); } } $it = new myIterator (); foreach ( $it as $key =&gt; $value ) { var_dump ( $key, $value ); echo \"\\n\"; }","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"迭代器","slug":"迭代器","permalink":"https://github.com/kong36088/kong36088.github.io/tags/迭代器/"}]},{"title":"JS破解微信防盗链","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/JS破解微信防盗链/","text":"2015年微信公众号的图片加入了防盗链功能，使得不能直接用这种方式引用图片，但是针对如此问题，研究了一个下午，尝试过php的curl进行访问，但是却是失败告终，最终找到了解决方案： function showImg( url ,frameid) { //url是要访问的连接，frameid是一个独立的frameid //frameid可以自行传入 // var frameid = 'frameimg' + Math.random(); window.img = '&lt;img id=\"img\" src=\\''+url+'?'+Math.random()+'\\' height=\"500px\" width=\"500px\" /&gt;&lt;script&gt;window.onload = function() { parent.document.getElementById(\\''+frameid+'\\').height = document.getElementById(\\'img\\').height+\\'px\\'; }&lt;'+'/script&gt;'; // document.write('&lt;iframe id=\"'+frameid+'\" src=\"javascript:parent.img;\" frameBorder=\"0\" scrolling=\"no\" width=\"100%\"&gt;&lt;/iframe&gt;'); } //通过以下方法调用 showImg(result.img,result.id); $('#content').append('&lt;iframe id=\"'+result.id+'\" src=\"javascript:parent.img;\" frameBorder=\"0\" scrolling=\"no\" width=\"100%\" height=\"100%\"&gt;&lt;/iframe&gt;');","tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/kong36088/kong36088.github.io/tags/javascript/"},{"name":"微信","slug":"微信","permalink":"https://github.com/kong36088/kong36088.github.io/tags/微信/"}]},{"title":"PHP爬虫（信软官网）","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/PHP爬虫（信软官网）/","text":"信软官网：点我 源码： // 爬虫 class Crawler { private $crawler_url; function __construct($url) { $this-&gt;crawler_url = $url; } function GetUrlContent() { $url = $this-&gt;crawler_url; $handle = fopen ( \"$url\", \"r\" ); if ($handle) { $content = stream_get_contents ( $handle, 1024 * 2048 ); return $content; } else { return false; } } function get_url_result() { $match = '/href=[\\'\\\"]{0,1}\\/news-[0-9]*\\.asp\\\" title=[\\'\\\"][^a-zA-Z]*\\\"/'; $content = $this-&gt;GetUrlContent (); if (preg_match_all ( $match, $content, $result )) { return $result; } else { return false; } } function deal_result() { $result = $this-&gt;get_url_result (); foreach ( $result as $list ) { $list = str_replace ( 'href=', \"http://info.scau.edu.cn\", $list ); $list = str_replace ( '\"', '', $list ); $results [] = str_replace ( 'title=', ' ', $list ); } return $results; } function write() { $result = $this-&gt;deal_result (); $fp = fopen ( \"list.txt\", \"w\" ); foreach ( $result as $lists ) { foreach ( $lists as $list ) { fputs ( $fp, $list . \"\\r\\n\" ); } } fclose ( $fp ); echo \"succeed\"; } } $crawler = new Crawler ( \"http://info.scau.edu.cn\" ); $crawler-&gt;write ();","tags":[{"name":"PHP","slug":"PHP","permalink":"https://github.com/kong36088/kong36088.github.io/tags/PHP/"},{"name":"爬虫","slug":"爬虫","permalink":"https://github.com/kong36088/kong36088.github.io/tags/爬虫/"}]},{"title":"Sphinx的安装","date":"2015-11-16T06:24:25.000Z","path":"2015/11/16/Sphinx的安装/","text":"Sphinx不推荐在windows下使用 在ubuntu和debian关于Sphinx的安装有两种途径，一种是通过deb包安装，另一种则是通过PPA的途径 Deb包: 利用apt-get安装libpq5拓展 $ sudo apt-get install mysql-client unixodbc libpq5 安装deb包 $ sudo dpkg -i sphinxsearch_2.3.1-beta-0ubuntu11~trusty_amd64.deb 通过PPA的方式 （仅限于ubuntu） 用PPA的方式来安装Sphinx会简单许多 添加软件源 $ sudo add-apt-repository ppa:builds/sphinxsearch-rel23 $ sudo apt-get update 安装Sphinx$ sudo apt-get install sphinxsearch然后我们就可以通过命令来开启Sphinx了 $ sudo service sphinxsearch start","tags":[{"name":"Sphnix","slug":"Sphnix","permalink":"https://github.com/kong36088/kong36088.github.io/tags/Sphnix/"}]},{"title":"关于前端制作的一些心得体会","date":"2015-10-21T06:24:25.000Z","path":"2015/10/21/关于前端制作的一些心得体会/","text":"对于第一次使用CSS3进行网页制作，体会还是不错的。 CSS3的功能十分之强大，颠覆了从前老土的特效，其中感受最深的是transition，该样式可以十分之好的支持样式的渐变过程，变化不再是那么的突兀，但是浏览器对于CSS3的支持参差不齐，所以要根据不同的内核加上类似-webkit- -moz-等如此的前缀以作区分。 当然，动作渐变的过程也可以通过jquery的animate来实现。 对于页面布局中还是采用%而减少采用px以适应不同屏幕的分辨率。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://github.com/kong36088/kong36088.github.io/tags/随笔/"}]},{"title":"数据库设计的三个范式","date":"2015-10-17T16:33:25.000Z","path":"2015/10/18/数据库设计的三个范式/","text":"第一范式 是数据库规范化中所使用的一种正规形式。第一范式是为了要排除 重复组 的出现，所采用的方法是要求数据库的每个字段都只能存放单一值，而且每笔记录都要能利用一个惟一的主键来加以识别。 重复组 重复组通常会出现在会计账上，每一笔记录可能有不定个数的值。举例来说： 交易顾客 日期 数量Pete Monday 19.00-28.20Pete Wednesday -84.00Sarah Friday 100.00150.00-40.00‘数量’ 就是所谓的重复组了，而在这种情况下这份数据就不符合第一范式。想要消除重复组的话，只要把每笔记录都转化为单一记录即可： 交易顾客 日期 数量Pete Monday 19.00Pete Monday -28.20Pete Wednesday -84.00Sarah Friday 100.00Sarah Friday 150.00Sarah Friday -40.00 缺乏唯一识别码 一样是在交易这个例子中，同一天同一个人买了同样的数量，这样的交易做了两次： 交易顾客 日期 数量Pete Monday 19.00Pete Monday 19.00如上所示，这两笔交易可以说是一模一样，也就是说如果只靠这些数据我们没有办法分辨这两笔记录。我们之所以说它不符合第一范式，是因为上面这样的表示法欠缺一个唯一识别码，可以是一个字段，也可以是一组字段，而且可以保证在这个数据中唯一识别码不会重复出现。要将它正规化到符合第一范式的原则只需要加入一个唯一识别码即可： 交易交易 ID 顾客 日期 数量1 Pete Monday 19.002 Pete Monday 19.00 第二范式 是数据库规范化中所使用的一种正规形式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系；如果有哪些数据只和主键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的主键只有单一一个字段的话，它就一定符合第二范式。 一个数据表符合第二范式当且仅当 它符合第一范式所有非主键的字段都一定和主键有关有一个数据表记录了设备组件的信息，如下所示： 组件来源组件 ID (主键) 价格 供应商ID (主键) 供应商名称 供应商住址65 59.99 1 Stylized Parts VA73 20.00 1 Stylized Parts VA65 69.99 2 ACME Industries CA这个数据表的每个值都是单一值，所以它符合第一范式。因为同一个组件有可能由不同的供应商提供，所以得把组件 ID 和供应商 ID 合在一起组成一个主键。 组件(关键词)和价格之间的关系很正确：同一个组件在不同供应商有可能会有不同的报价，所以价格确实和主键完全相关(完全依赖)。 另一方面，供应商的名称和住址就只和供应商 ID 有关(部分依赖)，这不符合第二范式的原则。仔细看就会发现 “Stylized Parts” 这个名称和 “VA” 这个住址重复出现了两次；要是它改名了或是被其他公司并购了怎么办？这时候最好把这些数据存到第二个数据表中： 供应商供应商 ID (主键) 名称 住址2 ACME Industries CA1 Stylized Parts VA这么一来，原本的 “组件来源” 数据表就得要做相对应的改动： 组件来源组件 ID (主键主键) 价格 供应商 ID（主键、非关键词）65 59.99 173 20.00 165 69.99 2 第三范式 是数据库规范化中所使用的一种正规形式，用来检验是否所有非键属性都只和候选键有相关性，也就是说所有非键属性互相之间应该是无关的。 第三范式和第二范式不同的地方在于，在第三范式里，所有的非键属性都必须和每个候选键有直接相关。如果再对第三范式做进一步加强就成了BC范式，它所强调的重点就在于 “数据间的关系是奠基在键上、以整个键为考量、而且除了键之外不考虑其他因素”。 以下面这个定义机械组件的关系为例： 机械组件组件编号(主键) 制造商名称 制造商地址1000 Toyota Park Avenue1001 Mitsubishi Lincoln Street1002 Toyota Park Avenue本例中制造商地址很明显地不该被列在这个关系里面，因为和组件本身比起来，制造商地址应该和制造商比较有关系；正确的做法应该是把独立成为一个新的数据表： 制造商制造商名称(主键) 制造商地址Toyota Park AvenueMitsubishi Lincoln Street然后把原本的数据表改成这样： 机械组件组件编号(主键) 制造商名称1000 Toyota1001 Mitsubishi1002 Toyota先前那个数据表的问题在于每提到一次制造商名称就要多存一次它的地址，而这就不符合第三范式的原则。 下面提供了另一个例子： 订单 (Order)订单编号 (ORDER NUMBER)(主键) 客户名称 (CUSTOMER NAME) 单价 (UNIT PRICE) 数量 (QUANTITY) 小计 (TOTAL)1000 David $35.00 3 $105.001001 Jim $25.00 2 $50.001002 Bob $25.00 3 $75.00在本例中，非主键字段完全依赖于主键订单编号,也就是说唯一的订单编号能导出唯一非主键字段值，符合第二范式。第三范式要求非主键字段之间不能有依赖关系，显然本例中小计依赖于非主键字段单价和数量，不符合第三范式。小计不应该放在这个数据表里面，只要把单价乘上数量就可以得到小计了；如果想要符合第三范式的话，就把小计拿掉吧 (不过在做查询的时候，本来用 “SELECT Order.Total FROM Order” 就要改成用 “SELECT UnitPrice * Quantity FROM Order” 了)。 订单 (Order)订单编号 (ORDER NUMBER)(主键) 客户名称 (CUSTOMER NAME) 单价 (UNIT PRICE) 数量 (QUANTITY)1000 David $35.00 31001 Jim $25.00 21002 Bob $25.00 3","tags":[{"name":"数据库","slug":"数据库","permalink":"https://github.com/kong36088/kong36088.github.io/tags/数据库/"},{"name":"范式","slug":"范式","permalink":"https://github.com/kong36088/kong36088.github.io/tags/范式/"}]},{"title":"优化 SQL SELECT 语句性能的 6 个简单技巧(转)","date":"2015-10-12T16:24:25.000Z","path":"2015/10/13/优化 SQL SELECT 语句性能的 6 个简单技巧(转)/","text":"SELECT语句的性能调优有时是一个非常耗时的任务，在我看来它遵循帕累托原则。20%的努力很可能会给你带来80%的性能提升，而为了获得另外20%的性能提升你可能需要花费80%的时间。除非你在金星工作，那里的每一天都等于地球上的243天，否则交付期限很有可能使你没有足够的时间来调优SQL查询。 根据我多年编写和运行SQL语句的经验，我开始开发一个检查列表，当我试图提高查询性能时供我参考。在进行查询计划和阅读我使用的数据库文档之前，我会参考其中的内容，数据库文档有时会很复杂。我的检查列表绝对说不上全面或科学，它更像是一个保守计算，但我可以说，遵循这些简单的步骤大部分时间我确实能得到性能提升。检查列表如下。 #检查索引# 在SQL语句的WHERE和JOIN部分中用到的所有字段上，都应该加上索引。进行这个3分钟SQL性能测试。不管你的成绩如何，一定要阅读那些带有信息的结果。 #限制工作数据集的大小# 检查那些SELECT语句中用到的表，看看你是否可以应用WHERE子句进行过滤。一个典型的例子是，当表中只有几千行记录时，一个查询能够很好地执行。但随着应用程序的成长，查询慢了下来。解决方案或许非常简单，限制查询来查看当前月的数据即可。 当你的查询语句带有子查询时，注意在子查询的内部语句上使用过滤，而不是在外部语句上。 #只选择你需要的字段# 额外的字段通常会增加返回数据的纹理，从而导致更多的数据被返回到SQL客户端。另外： •使用带有报告和分析功能的应用程序时，有时报告性能低是因为报告工具必须对收到的、带有详细形式的数据做聚合操作。•偶尔查询也可能运行地足够快，但你的问题可能是一个网络相关的问题，因为大量的详细数据通过网络发送到报告服务器。•当使用一个面向列的DBMS时，只有你选择的列会从磁盘读取。在你的查询中包含的列越少，IO开销就越小。 #移除不必要的表# 移除不必要的表的原因，和移除查询语句中不需要的字段的原因一致。 编写SQL语句是一个过程，通常需要大量编写和测试SQL语句的迭代过程。在开发过程中，你可能将表添加到查询中，而这对于SQL代码返回的数据可能不会有任何影响。一旦SQL运行正确，我发现许多人不会回顾他们的脚本，不会删除那些对最终的返回数据没有任何影响和作用的表。通过移除与那些不必要表的JOINS操作，你减少了大量数据库必须执行的流程。有时，就像移除列一样，你会发现你减少的数据又通过数据库返回来了。 #移除外部连接查询# 这说起来容易做起来难，它取决于改变表的内容有多大的影响。一个解决办法是通过在两个表的行中放置占位符来删除OUTER JOINS操作。假设你有以下的表，它们通过定义OUTER JOINS来确保返回所有的数据： CUSTOMER_ID CUSTOMER_NAME1 John Doe2 Mary Jane3 Peter Pan4 Joe SoapCUSTOMER_ID SALES_PERSONNULL Newbee Smith2 Oldie Jones1 Another OldieNULL Greenhorn解决办法是在customer表的行中增加一个占位符，并更新sales表中的所有NULL值到占位符。 CUSTOMER_ID CUSTOMER_NAME0 NO CUSTOMER1 John Doe2 Mary Jane3 Peter Pan4 Joe SoapCUSTOMER_ID SALES_PERSON0 Newbee Smith2 Oldie Jones1 Another Oldie0 Greenhorn你不只是删除了对OUTER JOIN操作的依赖，同时标准化了没有客户的销售人员如何表示。其他开发人员不必编写额外语句，例如ISNULL(customer_id, “No customer yet”)。 #删除JOIN和WHERE子句中的计算字段# 这是另外一个有时可能说起来容易做起来难的技巧，它取决于你更改表模式的权限大小。可以将连接语句中用到的计算字段作为一个新字段在表中创建。给出以下SQL语句： 12FROM sales aJOIN budget b ON ((YEAR(a.sale_date)* 100) + MONTH(a.sale_date)) = b.budget_year_month在sales表中利用年和月增加一列，可以提高性能。更新后的SQL语句将如下: 12SELECT * FROM PRODUCTSFROM sales aJOIN budget b ON a.sale_year_month = b.budget_year_month总结 上边的建议可以归结为以下几点： •检查索引•在所需要的最小数据集上操作•移除不必要的字段和表•移除你JOIN和WHERE子句中的计算操作 如果所有的这些建议都没能提高你的SQL查询性能，最后一个建议是搬去金星吧。你需要的就是一天能调优你的SQL语句。 转自CSDN","tags":[{"name":"SQL","slug":"SQL","permalink":"https://github.com/kong36088/kong36088.github.io/tags/SQL/"},{"name":"优化","slug":"优化","permalink":"https://github.com/kong36088/kong36088.github.io/tags/优化/"}]}]