title: 设计模式（创建型 二）——单例模式和原型模式
categories: PHP##分类
tags: [PHP,设计模式]##标签，多标签格式为 [tag1,tag2,...]
keywords: PHP,设计模式##文章关键词，多关键词格式为 keyword1,keywords2,...
description: PHP设计模式——单例模式和原型模式学习以及介绍
date: 2016/07/25 18:24:25 
---
本文主要讲解设计模式：
单例模式（Singleton）、原型模式（Prototype）

# 单例模式

单例模式可以使一些特殊的类只被实例化一次，保持每次只使用同一个类
关于适用性：
1）当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
2）当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

关于单例模式的实现也非常简单
以下是实现的代码
``` php
<?php  
class  Singleton {  
    static  private  $_instance = null;//静态成员保存唯一实例  
    /** 
     * 私有构造函数，保证不能被外部访问 
     * 
     */  
    private function __construct() {}   
    /** 
     * 静态方法将创建这个实例的操作并保证只有一个实例被创建 
     * 
     * @return unknown 
     */  
    public static function getInstance() {  
        if (!self::$_instance) {  
            self::$_instance = new self();  
        }  
        return self::$_instance;  
    }  
}  
```
同时，通过改造单例模式也可以实现多例模式
``` php
<?php  
class  Singleton {  
    static  private  $_instance[] = array();//静态成员保存唯一实例  
    private $uid;
    /** 
     * 私有构造函数，保证不能被外部访问 
     * 
     */  
    private function __construct($uid) {
    	$this->uid = $uid;
	}   
    /** 
     * 静态方法将创建这个实例的操作并保证只有一个实例被创建 
     * 
     * @return unknown 
     */  
    public static function getInstance($uid = 0) {  
        if (!self::$_instance || !isset(self::$_instance[$uid])) {  
            self::$_instance[$uid] = new self($uid);  
        }  
        return self::$_instance[$uid]; 
    }  
} 
```

# 原型模式

原型模式适用于初始化过程非常繁琐的类当中。通过clone()这一方法可以更为简单的得到初始化之后的类
同时也适用于已经改变结构的类。简而言之，简化初始化过程，提高计算效率

1 ) 运行时刻增加和删除产品： Prototype允许只通过客户注册原型实例就可以将一个新的具体产品类并入系统。它比其他创建型模式更为灵活，因为客户可以在运行时刻建立和删除原型。
2 ) 改变值以指定新对象： 高度动态的系统允许你通过对象复合定义新的行为—例如，通过为一个对象变量指定值—并且不定义新的类。你通过实例化已有类并且将这些实例注册为客户对象的原型，就可以有效定义新类别的对象。客户可以将职责代理给原型，从而表现出新的行为。这种设计使得用户无需编程即可定义新“类” 。实际上，克隆一个原型类似于实例化一个类。Prototype模式可以极大的减少系统所需要的类的数目。
3) 改变结构以指定新对象：许多应用由部件和子部件来创建对象。
4) 减少子类的构造 Factory Method 经常产生一个与产品类层次平行的 Creator类层次。Prototype模式使得你克隆一个原型而不是请求一个工厂方法去产生一个新的对象。因此你根本不需要Creator类层次。这一优点主要适用于像 C + +这样不将类作为一级类对象的语言。像Smalltalk和Objective C这样的语言从中获益较少，因为你总是可以用一个类对象作为生成者。在这些语言中，类对象已经起到原型一样的作用了。
5) 用类动态配置应用 一些运行时刻环境允许你动态将类装载到应用中。在像 C + +这样的语言中，Prototype模式是利用这种功能的关键。一个希望创建动态载入类的实例的应用不能静态引用类的构造器。而应该由运行环境在载入时自动创建每个类的实例，并用原型管理器来注册这个实例（参见实现一节） 。这样应用就可以向原型管理器请求新装载的类的实例，这些类原本并没有和程序相连接。 E T + +应用框架[ W G M 8 8 ]有一个运行系统就是使用这一方案的。

以下是代码示例
``` php
/** 
 * 原型模式  
 */  
   
/** 
 * 抽象原型角色 
 */  
interface Prototype {  
    public function copy();  
}  
   
/** 
 * 具体原型角色 
 */  
class ConcretePrototype implements Prototype{  
   
    private  $_name;  
   
    public function __construct($name) {  
        $this->_name = $name;  
    }  
   
    public function setName($name) {  
        $this->_name = $name;  
    }  
   
    public function getName() {  
        return $this->_name;  
    }  
   
    public function copy() {  
       /** 深拷贝 */  
       return  clone  $this;      
       /** 浅拷贝 */  
       //return  $this;     
    }  
}  
```

# 参考文章
[设计模式（二）单件模式Singleton（创建型）](http://blog.csdn.net/hguisu/article/details/7515416)
[设计模式（四）原型模式Prototype（创建型）](http://blog.csdn.net/hguisu/article/details/7518947)