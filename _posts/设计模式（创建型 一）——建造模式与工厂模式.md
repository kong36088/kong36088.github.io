title: 设计模式（创建型 一）——建造模式与工厂模式
categories: PHP##分类
tags: [PHP,设计模式]##标签，多标签格式为 [tag1,tag2,...]
keywords: PHP,设计模式##文章关键词，多关键词格式为 keyword1,keywords2,...
description: PHP设计模式——建造模式与工厂模式学习以及介绍
date: 2016/07/25 14:24:25 
---
创建型的设计模式主要包括：工厂模式、建造模式、单例模式、原型模式
本文主要针对建造模式类似的两种设计模式进行学习记录总结
主要介绍：工厂模式Factory、建造者模式（Builder）

# 工厂模式

工厂模式在日常设计开发中较为常见。
使用场景：
1)当客户程序不需要知道要使用对象的创建过程。 
2)客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。

由产品类、工厂类、客户类三中类构成
这里举个例子

产品类：
``` php
/** 
 * 车子系列 
 * 
 */  
abstract Class BWM{  
	function __construct($pa) {  
	  
	}  
}  
Class BWM320 extends BWM{  
	function __construct($pa) {  
	  
	}  
}  
Class BMW523 extends BWM{  
	function __construc($pb){  
	  
	}
}
```
工厂类
``` php
/** 
 * 创建工厂的接口 
 * 
 */  
interface FactoryBMW {   
    function createBMW();   
}   
  
  
/** 
 *  
 * 创建BWM320车 
 */  
class FactoryBWM320 implements FactoryBMW {  
   function  createBMW($type){  
      return new BWM320();  
   }  
}  
  
  
/** 
 *  
 * 创建BWM523车 
 */  
class FactoryBWM523 implements FactoryBMW {  
   function  createBMW($type){  
      return new BMW523();  
   }  
}  
```

客户类
``` php
/** 
 *  
 * 客户得到车 
 */  
class Customer {  
   private $BMW;  
   function  getBMW($type){  
      switch ($type) {  
        case 320:  
           $BWM320 = new FactoryBWM320();  
           return $BWM320->createBMW();  
        case 523:  
           $BWM523 = new FactoryBWM523();  
           return $BWM320->createBMW();  
            //....  
      }
  }
}
```

工厂模式较为适合进行未知产品类型的开发，在需要进行多种不同类型的产品的开发时，使用单一的工厂可以保持产品的单一入口，从而提高代码的复用率和开发时效率

# 建造者模式

建造者模式和工厂模式较为相似，但是在生成复杂产品的时候使用建造者模式会比较的适合
建造者模式比工厂模式多出一个指导者类，用于组装builder生产出的组件
以下是例子：

指导者类
``` php 
<?php  
/** 
 * 指导者:收银员 
 * 
 */  
class DirectorCashier  
{  
    /** 
     * 收银餐馆员工返回的食物 
     * 
     */  
    public function buildFood(Builder $builder) {  
        $builder->buildPart1();  
        $builder->buildPart2();  
    }  
}  
```

建造者类（不同的产品有不同的组件）：
``` php
/** 
 * 具体建造者类:餐馆员工,返回的套餐是：汉堡两个+饮料一个 
 * 
 */  
class ConcreteBuilder1 extends Builder  
{  
	protected $_product = null;//产品对象  
	function __construct(){  
	    $this->_product = new Product();  
	}  

	/** 
	 * 创建产品的第一部分::汉堡=2 
	 */  
	public  function buildPart1()  
	{  
	    $this->_product->add('Hamburger',2);  
	}  
	/** 
	 *  
	 * 创建产品的第二部分： 
	 */  
	public  function buildPart2()  
	{  
	    $this->_product->add('Drink', 1);  
	}  
	/** 
	 * 返回产品对象 : 
	 *  
	 */  
	public function  getProduct()  {  
	    return  $this->_product;  
	}  
	}  

	/** 
	* 具体建造者类:餐馆员工，汉堡1个+饮料2个 
	* 
	*/  
class ConcreteBuilder2 extends Builder  
{  
	protected $_product = null;//产品对象  
	function __construct(){  
		$this->_product = new Product();  
	}  

	/** 
	 * 创建产品的第一部分:汉堡 
	 */  
	public  function buildPart1()  
	{  
	    $this->_product->add('Hamburger', 1);  
	}  
	/** 
	 *  
	 * 创建产品的第二部分:drink=2 
	 */  
	public  function buildPart2()  
	{  
	    $this->_product->add('Drink', 2);  
	}  
	/** 
	 * 返回产品对象 : 
	 *  
	 */  
	public function  getProduct()  {  
	    return  $this->_product;  
	}  
}  
```

产品类
``` php
/** 
  * 产品类 
  */  
class Product  
{  
    public $products = array();  
    /** 
     * 添加具体产品 
     */  
    public function add($name,  $value) {  
        $this->products[$name] = $value;  
    }  
    /** 
     * 给顾客查看产品 
     */  
    public function showToClient()  
    {  
        foreach ($this->products as $key => $v) {  
            echo $key , '=' , $v ,'<br>';  
        }  
    }  
 }  
```

客户程序
``` php
 class Client  
 {  
    /** 
     * 顾客购买套餐 
     * 
     */  
    public  function buy($type) {  
        //指导者，收银员  
         $director  = new DirectorCashier();   
         //餐馆员工，收银员  
         $class = new ReflectionClass('ConcreteBuilder' .$type );  
         $concreteBuilder  = $class->newInstanceArgs();  
         //收银员组合员工返回的食物  
         $director->buildFood($concreteBuilder);  
         //返回给顾客  
         $concreteBuilder->getProduct()->showToClient();  
    }  
 }  
   
 //测试  
 ini_set('display_errors', 'On');  
 $c = new Client();  
 $c->buy(1);//购买套餐1  
 $c->buy(2);//购买套餐1
```

如果产品的建造很复杂，使用工厂模式
如果产品的建造更加复杂，使用建造者模式
按照个人理解来说，其实建造者模式就是工厂模式的上升，在生产出产品的类上再次封装一层，使得代码封装程度更高，更加便于维护
建造模式把生产出产品之上再加一层，工厂生产出的只是组件，还需要指导者去组装这些组件使之成为产品


# 参考文章
[设计模式（一）工厂模式Factory（创建型）](http://blog.csdn.net/hguisu/article/details/7505909)
[设计模式（三）建造者模式Builder（创建型）](http://blog.csdn.net/hguisu/article/details/7518060)